id,desc,data,time_limit,memory_limit,std,test,cate,difficulty
1,"Given a sequence of length \( n \), there are \( q \) queries to find the maximum value in specified intervals. Return the XOR sum of the answers to these \( q \) queries.

solution main function
```cpp
class Solution
{
    public:
    int solve(vector<int >& num, vector<pair<int,int> > q)
    {

    }
}
```

Example 1:
Input: num = [5,4,8,9,3,4,6] , q = [[0,3],[3,5]]
Output: 0

Constraints:

1 <= n,q <= @data
1 <= s_i <= 10^9

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[12800, 6400, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve1(vector<int>& nums, vector<pair<int, int>>& queries) {
        int xorSum = 0;

        for (const auto& q : queries) {
            int l = q.first;
            int r = q.second;
            int maxVal = INT_MIN;

            for (int i = l; i <= r; ++i) {
                maxVal = max(maxVal, nums[i]);
            }

            xorSum ^= maxVal;
        }

        return xorSum;
    }
    int solve2(vector<int>& nums, vector<pair<int, int>>& queries) {
        int n = nums.size();
        int blockSize = sqrt(n); 
        int numBlocks = (n + blockSize - 1) / blockSize; 

        vector<int> blockMax(numBlocks, INT_MIN);
        for (int i = 0; i < n; ++i) {
            int blockIndex = i / blockSize;
            blockMax[blockIndex] = max(blockMax[blockIndex], nums[i]);
        }

        auto query = [&](int l, int r) -> int {
            int maxVal = INT_MIN;

            while (l <= r && l % blockSize != 0) {
                maxVal = max(maxVal, nums[l]);
                ++l;
            }
            while (l + blockSize - 1 <= r) { 
                int blockIndex = l / blockSize;
                maxVal = max(maxVal, blockMax[blockIndex]);
                l += blockSize;
            }
            while (l <= r) { 
                maxVal = max(maxVal, nums[l]);
                ++l;
            }

            return maxVal;
        };

        int xorSum = 0;
        for (const auto& q : queries) {
            int l = q.first;
            int r = q.second;
            xorSum ^= query(l, r);
        }

        return xorSum;
    }
    int solve3(vector<int>& nums, vector<pair<int, int>>& queries) {
        int n = nums.size();
        int log = log2(n) + 1;

        // Sparse Table initialization
        vector<vector<int>> sparse(n, vector<int>(log));

        // Build Sparse Table: Fill for intervals of size 1
        for (int i = 0; i < n; ++i) {
            sparse[i][0] = nums[i];
        }

        // Build Sparse Table: Fill for larger intervals
        for (int j = 1; (1 << j) <= n; ++j) {
            for (int i = 0; i + (1 << j) - 1 < n; ++i) {
                sparse[i][j] = max(sparse[i][j - 1], sparse[i + (1 << (j - 1))][j - 1]);
            }
        }

        // Function to query maximum in range [l, r]
        auto query = [&](int l, int r) -> int {
            int len = r - l + 1;
            int k = log2(len); // Largest power of 2 that fits in the range
            return max(sparse[l][k], sparse[r - (1 << k) + 1][k]);
        };

        // XOR the results of all queries
        int xorSum = 0;
        for (const auto& q : queries) {
            int l = q.first;
            int r = q.second;
            xorSum ^= query(l, r);
        }

        return xorSum;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    vector< int > s;
    vector< pair<int,int> > q;
    for(int i=1,x;i<=n;i++)
    {
        scanf(""%d"",&x);
        s.push_back(x);
    }
    for(int i=1,x,y;i<=m;i++)
    {
        scanf(""%d"",&x);
        scanf(""%d"",&y);
        q.push_back({x,y});
    }
    // solve
    Solution solution;
    auto result = solution.solve(s,q);
    
    // output
    cout << result << ""\n"";

    return 0;
}",data_structures,medium
2,"Given a sequence of length n, there are q queries for the product of a subarray.  Each query's answer is mod p. Return the XOR sum of the answers to the q queries.

solution main function
```cpp
class Solution
{
    public:
    int solve(vector<int >& num, vector<pair<int,int> > q,int p)
    {

    }
}
```

Example 1:
Input: num = [5,4,8,9,3,4,6] , q = [[0,3],[3,5]] p = 10
Output: 8

Constraints:

1 <= n,q <= @data
1 <= s_i <= 10^9

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[18000, 6400, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution
{
public:
    int solve1(vector<int>& num, vector<pair<int, int>>& queries, int p)
    {
        #define int long long
        int xor_sum = 0;
        for (auto& query : queries)
        {
            int l = query.first, r = query.second;
            long long product = 1;
            for (int i = l; i <= r; ++i)
            {
                product = (product * num[i]) % p;
            }
            xor_sum ^= product;
        }
        return xor_sum;
        #undef int
    }

    int solve2(vector<int>& num, vector<pair<int, int>>& queries, int p)
    {
        #define int long long
        int n = num.size();
        int block_size = sqrt(n);
        vector<long long> block_product((n + block_size - 1) / block_size, 1);

        for (int i = 0; i < n; ++i)
        {
            block_product[i / block_size] = (block_product[i / block_size] * num[i]) % p;
        }

        int xor_sum = 0;
        for (auto& query : queries)
        {
            int l = query.first, r = query.second;
            long long product = 1;

            int start_block = l / block_size;
            int end_block = r / block_size;

            if (start_block == end_block)
            {
                for (int i = l; i <= r; ++i)
                {
                    product = (product * num[i]) % p;
                }
            }
            else
            {
                for (int i = l; i < (start_block + 1) * block_size; ++i)
                {
                    product = (product * num[i]) % p;
                }
                for (int i = start_block + 1; i < end_block; ++i)
                {
                    product = (product * block_product[i]) % p;
                }
                for (int i = end_block * block_size; i <= r; ++i)
                {
                    product = (product * num[i]) % p;
                }
            }
            xor_sum ^= product;
        }
        return xor_sum;
        #undef int
    }

    int solve3(vector<int>& num, vector<pair<int, int>>& queries, int p)
    {
        #define int long long
        int n = num.size();
        int log_n = log2(n) + 1;
        vector<vector<long long>> st(n, vector<long long>(log_n));

        for (int i = 0; i < n; ++i)
        {
            st[i][0] = num[i] % p;
        }

        for (int j = 1; (1 << j) <= n; ++j)
        {
            for (int i = 0; i + (1 << j) - 1 < n; ++i)
            {
                st[i][j] = (st[i][j - 1] * st[i + (1 << (j - 1))][j - 1]) % p;
            }
        }

        auto query_product = [&](int l, int r) {
            long long product = 1;
            for (int j = log_n - 1; j >= 0; --j)
            {
                if ((1 << j) <= r - l + 1)
                {
                    product = (product * st[l][j]) % p;
                    l += (1 << j);
                }
            }
            return product;
        };

        int xor_sum = 0;
        for (auto& query : queries)
        {
            xor_sum ^= query_product(query.first, query.second);
        }
        return xor_sum;
        #undef int
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m,p; cin>>n>>m>>p;
    vector< int > s;
    vector< pair<int,int> > q;
    for(int i=1,x;i<=n;i++)
    {
        scanf(""%d"",&x);
        s.push_back(x);
    }
    for(int i=1,x,y;i<=m;i++)
    {
        scanf(""%d"",&x);
        scanf(""%d"",&y);
        q.push_back({x,y});
    }
    // solve
    Solution solution;
    auto result = solution.solve(s,q,p);
    
    // output
    cout << result << ""\n"";

    return 0;
}",data_structures,medium
3,"You are given a dictionary `dic` consisting of `n` strings (with characters numbered starting from 0), and then `m` strings `q`. Each string in `q` represents a query asking whether the string exists in the dictionary. If it does, return the corresponding string's index; otherwise, return 0. The final answer is the XOR sum of all the returned values.

solution main function
```cpp
class Solution
{
    public:
    int solve(vector<string>& dic, vector<string>& q)
    {

    }
}
```

Example 1:
Input: num = [""abc"",""ac"",""ab"",""cd""] , q = [""abc"",""cd"",""dc"",""ac""]
Output: 2

Constraints:

1 <= n <= @data
the length of string <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[50, 500, 1000]",1000.0,"[[12800, 6400, 640]]","#include<bits/stdc++.h>
#include <unordered_map>
using namespace std;
class Solution
{
public:
    int solve1(vector<string>& dic, vector<string>& q)
    {
        #define ull unsigned long long
        const ull bas=13331ull;
        int ans=0;
        unordered_map<ull,int> mp;
        for(int i=0;i<dic.size();i++)
        {
            string str=dic[i];
            ull has=0;
            for(auto it:str)
                has=has*bas+it;
            if(mp.find(has)==mp.end()) mp.insert({has,i});
            else mp[has]^=i;
        }
        for(auto str:q)
        {
            ull has=0;
            for(auto it:str)
                has=has*bas+it;
            if(mp.find(has)!=mp.end())
                ans^=(mp.find(has)->second);
        }
        return ans;
    }
    int solve2(vector<string>& dic, vector<string>& q)
    {
        #define ull unsigned long long
        int ans=0;
        for(auto str:q)
        {
            for(int i=0;i<dic.size();i++)
                if(dic[i]==str)
                    ans^=i;
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    vector< string > a,b;
    for(int i=1,x;i<=n;i++)
    {
        string str; cin>>str;
        a.push_back(str);
    }
    for(int i=1,x;i<=m;i++)
    {
        string str; cin>>str;
        b.push_back(str);
    }
    // solve
    Solution solution;
    auto result = solution.solve(a,b);
    
    // output
    cout << result << ""\n"";

    return 0;
}",string,medium
4,"There are $n$ elements. The $i$-th element has three attributes: $a_i$, $b_i$, and $c_i$. Let $f(i)$ denote the number of $j$'s that satisfy $a_j \leq a_i$, $b_j \leq b_i$, $c_j \leq c_i$, and $j \neq i$. 

Returns the result of all $f(i)$ ' xor '

solution main function
```cpp
class Solution
{
    public:
    int solve(vector<vector<int> >& s)
    {

    }
}
```

Example 1:
Input: num = [[3,3,3],[2,3,3],[2,3,1],[3,1,1],[3,1,2],[1,3,1],[1,1,2],[1,2,2],[1,3,2],[1,2,1]]
Output: 8

Constraints:

1 <= s.length <= @data
s[i].length == 3
Each element in s is $[a_i,b_i,c_i]$
1 <= $a_i,b_i,c_i$ <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[12800, 6400, 640]]","#include<bits/stdc++.h>
#include <unordered_map>
using namespace std;
class Solution
{
    public:
    struct Node
    {
        int a,b,c,t,sum;
        bool operator == (Node x) const
        {
            return a==x.a&&b==x.b&&c==x.c;
        }
    };
    vector<Node> s,f;
    vector<int> ans;
    struct BIT
    {
        int lim;
        vector<int> tre;
        inline int lowbit(int x){return x&(-x);}
        inline void insert(int x,int val){for(int i=x;i<=lim;i+=lowbit(i))tre[i]+=val;}
        inline int query(int x){int sum=0;for(int i=x;i>0;i-=lowbit(i))sum+=tre[i];return sum;}
    }T;
    inline void CDQ(int l,int r)
    {
        if(l>=r) return ;
        int mid=(l+r)>>1;
        CDQ(l,mid); CDQ(mid+1,r);
        int i=l,j=mid+1,k=l;
        while(i<=mid&&j<=r)
            if(s[i].b<=s[j].b) T.insert(s[i].c,s[i].t),f[k++]=s[i++];
            else s[j].sum+=T.query(s[j].c),f[k++]=s[j++];
        while(i<=mid) T.insert(s[i].c,s[i].t),f[k++]=s[i++];
        while(j<=r) s[j].sum+=T.query(s[j].c),f[k++]=s[j++];
        for(i=l;i<=mid;i++) T.insert(s[i].c,-s[i].t);
        for(i=l;i<=r;i++) s[i]=f[i];
    }
    int solve1(vector<vector<int> >& num)
    {
        sort(num.begin(),num.end());
        int n=num.size(); int m=n;
        int cnt=0,out=0; T.lim = m;
        s.resize(n+1,{0,0,0,0,0});
        f.resize(n+1,{0,0,0,0,0});
        ans.resize(n+1,0);
        T.tre.resize(m+1,0);
        for(int i=1;i<=n;i++)
        {
            s[i].a=num[i-1][0]; s[i].b=num[i-1][1];
            s[i].c=num[i-1][2]; s[i].t=1; s[i].sum=0;
        }
        for(int i=1;i<=n;i++)
            if(s[i]==s[i-1]) s[cnt].t++;
            else s[++cnt]=s[i];
        CDQ(1,cnt);
        for(int i=1;i<=cnt;i++) ans[s[i].sum+s[i].t-1]+=s[i].t;
        for(int i=0;i<n;i++) if(ans[i]&1) out^=i;
        return out;
    }
    int solve2(vector<vector<int> >& s)
    {
        sort(s.begin(),s.end());
        int n=s.size(),ans=0;
        for(int i=0;i<n;i++)
        {
            int temp=0;
            for(int j=0;j<i;j++)
                if(s[i][1]>=s[j][1])
                    if(s[i][2]>=s[j][2])
                        temp++;
            int j=i+1;
            while(j<n&&s[j][0]==s[i][0])
            {
                if(s[j][1]<=s[i][1]&&s[j][2]<=s[i][2])
                    temp++;
                j++;
            }
            ans^=temp;
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector< vector<int> > s;
    for(int i=1,x;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=3;j++)
            cin>>x,temp.push_back(x);
        s.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    cout << result << ""\n"";

    return 0;
}",data_structures,medium
5,"# Problem Statement
Even after copying the paintings from famous artists for ten years, unfortunately, Eric is still unable to become a skillful impressionist painter. He wants to forget something, but the white bear phenomenon just keeps hanging over him.

Eric still remembers $n$ pieces of impressions in the form of an integer array. He records them as $w_1, w_2, \ldots, w_n$. However, he has a poor memory of the impressions. For each $1 \leq i \leq n$, he can only remember that $l_i \leq w_i \leq r_i$.

Eric believes that impression $i$ is unique if and only if there exists a possible array $w_1, w_2, \ldots, w_n$ such that $w_i \neq w_j$ holds for all $1 \leq j \leq n$ with $j \neq i$.

Please help Eric determine whether impression $i$ is unique for every $1 \leq i \leq n$, **independently** for each $i$. Perhaps your judgment can help rewrite the final story.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    void solve(int &n, vector<int> &l, vector<int> &r, string &res) {
        // write your code here
    }
};
```
where:  
- return: a string containing $n$ characters. The $i$-th character should be '1' if impression $i$ is unique, and '0' otherwise. The string has been given as input and should be modified in place.

# Example 1:  
- Input:  
n = 2
l = [1, 1]
r = [1, 1]
- Output:  
00

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq l[i] \leq r[i] \leq 2 * n$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[100, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    void solve1(int &n, vector<int> &l, vector<int> &r, string &res)
    {
        vector<int> cnt(2 * n);
        vector<int> pre(2 * n + 1);
        for (int i = 0; i < n; i++)
        {
            l[i]--;
            if (l[i] + 1 == r[i])
            {
                cnt[l[i]]++;
            }
        }
        for (int i = 0; i < 2 * n; i++)
        {
            pre[i + 1] = pre[i] + (cnt[i] == 0);
        }

        for (int i = 0; i < n; i++)
        {
            if (l[i] + 1 < r[i])
            {
                res += (pre[l[i]] != pre[r[i]]) + '0';
            }
            else
            {
                res += (cnt[l[i]] == 1) + '0';
            }
        }
    }
    void solve2(int &n, vector<int> &l, vector<int> &r, string &res)
    {
        for (int i = 0; i < n; i++)
        {
            for (int j = l[i]; j <= r[i]; j++)
            {
                int flag = 0;
                for (int k = 0; k < n; k++)
                {
                    if (k == i)
                        continue;
                    if (l[k] == r[k] && l[k] == j)
                    {
                        flag = 1;
                        break;
                    }
                }
                if (flag == 0)
                {
                    res += '1';
                    break;
                }
                if (j == r[i])
                    res += '0';
            }
        }
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> l(n), r(n);
    for (int i = 0; i < n; i++)
    {
        cin >> l[i] >> r[i];
    }

    // solve
    Solution solution;
    string result;
    solution.solve(n, l, r, result);

    // output
    cout << result << ""\n"";

    return 0;
}","binary,data_structures,greedy",hard
6,"# Problem Statement
Robin's brother and mother are visiting, and Robin gets to choose the start day for each visitor.

All days are numbered from $1$ to $n$. Visitors stay for $d$ continuous days, all of those $d$ days must be between day $1$ and $n$ inclusive.

Robin has a total of $k$ risky 'jobs' planned. The $i$\-th job takes place between days $l_i$ and $r_i$ inclusive, for $1 \le i \le k$. If a job takes place on any of the $d$ days, the visit overlaps with this job (the length of overlap is unimportant).

Robin wants his brother's visit to overlap with the maximum number of **distinct jobs**, and his mother's the minimum.

Find suitable start days for the visits of Robin's brother and mother. If there are multiple suitable days, choose the earliest one.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    pair<int, int> solve(int &n, int &d, int &k, vector<int> &l, vector<int> &r) {
        // write your code here
    }
};
```
where:  
- return: pair of integers, the start days for Robin's brother and mother respectively.

# Example 1:  
- Input: 
n = 2, d = 1, k = 1
l = [1], r = [2] 
- Output:  
(1, 1)

# Constraints:  
- $1 \leq d, k \leq n \leq @data$
- $1 \leq l[i] \leq r[i] \leq n$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    pair<int, int> solve1(int &n, int &d, int &k, vector<int> &l, vector<int> &r)
    {
        vector<int> L(n + 1), R(n + 1);
        for (int i = 0; i < k; i++)
        {
            int ll = l[i], rr = r[i];
            ll--;
            L[ll]++;
            R[rr]++;
        }
        for (int i = 1; i <= n; i++)
        {
            R[i] += R[i - 1];
        }
        for (int i = n - 1; i >= 0; i--)
        {
            L[i] += L[i + 1];
        }

        int mx = -1;
        int imx = -1;
        int mn = n + 1;
        int imn = -1;

        for (int i = 0; i <= n - d; i++)
        {
            int v = R[i] + L[i + d];
            if (v > mx)
            {
                mx = v;
                imx = i + 1;
            }
            if (v < mn)
            {
                mn = v;
                imn = i + 1;
            }
        }

        return {imn, imx};
    }
    pair<int, int> solve2(int &n, int &d, int &k, vector<int> &l, vector<int> &r)
    {
        int max = -1;
        int min = k + 1;
        int maxl = -1;
        int minl = -1;
        for (int i = 1; i + d - 1 <= n; i++)
        {
            int count = 0;
            for (int j = 0; j < k; j++)
            {
                if (!(r[j] < i || l[j] > i + d - 1))
                {
                    count++;
                }
            }
            if (count > max)
            {
                max = count;
                maxl = i;
            }
            if (count < min)
            {
                min = count;
                minl = i;
            }
        }
        return {maxl, minl};
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, d, k;
    cin >> n >> d >> k;
    vector<int> l(k), r(k);
    for (int i = 0; i < k; i++)
    {
        cin >> l[i] >> r[i];
    }

    // solve
    Solution solution;
    auto result = solution.solve(n, d, k, l, r);

    // output
    cout << result.first << "" "" << result.second << ""\n"";

    return 0;
}",data_structures,hard
7,"# Problem Statement
Polycarp was given an array $a$ of $n$ integers. He really likes triples of numbers, so for each $j$ ($1 \le j \le n - 2$) he wrote down a triple of elements $[a_j, a_{j + 1}, a_{j + 2}]$.

Polycarp considers a pair of triples $b$ and $c$ beautiful if they differ in exactly one position, that is, one of the following conditions is satisfied:

-   $b_1 \ne c_1$ and $b_2 = c_2$ and $b_3 = c_3$;
-   $b_1 = c_1$ and $b_2 \ne c_2$ and $b_3 = c_3$;
-   $b_1 = c_1$ and $b_2 = c_2$ and $b_3 \ne c_3$.

Find the number of beautiful pairs of triples among the written triples $[a_j, a_{j + 1}, a_{j + 2}]$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the number of beautiful pairs of triples among the pairs of the form [aj,aj+1,aj+2].

# Example 1:  
- Input:  
n = 5
a = [3, 2, 2, 2, 3]
- Output:  
2

# Constraints:  
- $3 \leq n \leq @data$
- $1 \leq a[i] \leq 10^6$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[12800, 1280, 64]]","class Solution
{
public:
    long long solve1(int &n, vector<int> &a)
    {
        long long ans = 0;
        map<array<int, 2>, int> mp[3];
        map<array<int, 3>, int> mp2;
        for (int i = 0; i + 2 < n; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                array<int, 2> v{(a[i + (j + 1) % 3]), (a[i + (j + 2) % 3])};
                if (mp[j].find(v) != mp[j].end())
                {
                    ans += mp[j][v];
                }
            }
            for (int j = 0; j < 3; j++)
            {
                array<int, 2> v{(a[i + (j + 1) % 3]), (a[i + (j + 2) % 3])};
                mp[j][v] += 1;
            }
            if (mp2.find({a[i], a[i + 1], a[i + 2]}) != mp2.end())
            {
                ans -= 3 * mp2[{a[i], a[i + 1], a[i + 2]}];
            }
            mp2[{a[i], a[i + 1], a[i + 2]}] += 1;
        }
        return ans;
    }
    long long solve2(int &n, vector<int> &a)
    {
        long long ans = 0;
        for (int i = 0; i + 2 < n; i++)
        {
            for (int j = 0; j + 2 < n; j++)
            {
                if (i == j)
                    continue;
                if ((a[i] != a[j] && a[i+1]==a[j+1] && a[i+2]==a[j+2])||(a[i] == a[j] && a[i+1]!=a[j+1] && a[i+2]==a[j+2])||(a[i] == a[j] && a[i+1]==a[j+1] && a[i+2]!=a[j+2]))
                {
                    ans++;
                }
            }
        }
        return ans/2;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",data_structures,hard
8,"# Problem Statement
Maxim has an array $a$ of $n$ integers and an array $b$ of $m$ integers ($m \le n$).

Maxim considers an array $c$ of length $m$ to be good if the elements of array $c$ can be rearranged in such a way that at least $k$ of them match the elements of array $b$.

For example, if $b = [1, 2, 3, 4]$ and $k = 3$, then the arrays $[4, 1, 2, 3]$ and $[2, 3, 4, 5]$ are good (they can be reordered as follows: $[1, 2, 3, 4]$ and $[5, 2, 3, 4]$), while the arrays $[3, 4, 5, 6]$ and $[3, 4, 3, 4]$ are not good.

Maxim wants to choose every subsegment of array $a$ of length $m$ as the elements of array $c$. Help Maxim count how many selected arrays will be good.

In other words, find the number of positions $1 \le l \le n - m + 1$ such that the elements $a_l, a_{l+1}, \dots, a_{l + m - 1}$ form a good array.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &m, int &k, vector<int> &a, vector<int> &b) { 
        // write your code here
    }
};
```
where:  
- return: the number of good arrays.

# Example 1:  
- Input:  
n = 7, m = 4, k = 2
a = [4, 1, 2, 3, 4, 5, 6]
b = [1, 2, 3, 4]
- Output:  
4

# Constraints:  
- $1 \leq k \leq m \leq n \leq @data$
- $1 \leq a[i], b[i] \leq 10^6$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[100, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve1(int &n, int &m, int &k, vector<int> &a, vector<int> &b)
    {
        map<int, int> cnt;
        for (int i = 0; i < m; i++)
        {
            cnt[b[i]]++;
        }
        int ans = 0;
        int good = 0;
        for (int i = 0; i < m - 1; i++)
        {
            good += cnt[a[i]]-- > 0;
        }
        for (int i = 0; i <= n - m; i++)
        {
            good += cnt[a[i + m - 1]]-- > 0;
            ans += (good >= k);
            good -= ++cnt[a[i]] > 0;
        }
        return ans;
    }
    int solve2(int &n, int &m, int &k, vector<int> &a, vector<int> &b)
    {
        int ans = 0;
        sort(b.begin(), b.end());
        for (int i = 0; i <= n - m; i++)
        {
            int good = 0;
            int pre = 0;
            int num = 0;
            for (int j = 0; j < m; j++)
            {
                if (pre != b[j])
                {
                    if (pre != 0)
                        good += min(num, (int)count(a.begin() + i, a.begin() + i + m, pre));
                    num = 1;
                    pre = b[j];
                }
            }
            if (pre != 0)
                good += count(a.begin() + i, a.begin() + i + m, pre);
            if (good >= k)
                ans++;
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, m, k;
    cin >> n >> m >> k;
    vector<int> a(n), b(m);
    for (int i = 0; i < n; i++)
        cin >> a[i];
    for (int i = 0; i < m; i++)
        cin >> b[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, m, k, a, b);

    // output
    cout << result << ""\n"";

    return 0;
}","data_structures,two_pointers",medium
9,"# Problem Statement
A progressive square of size $n$ is an $n \times n$ matrix. Maxim chooses three integers $a_{1,1}$, $c$, and $d$ and constructs a progressive square according to the following rules:

$$
a_{i+1,j} = a_{i,j} + c
$$

$$
a_{i,j+1} = a_{i,j} + d
$$

For example, if $n = 3$, $a_{1,1} = 1$, $c=2$, and $d=3$, then the progressive square looks as follows:

$$
\begin{pmatrix} 1 & 4 & 7 \\ 3 & 6 & 9 \\ 5 & 8 & 11 \end{pmatrix}
$$

Last month Maxim constructed a progressive square and remembered the values of $n$, $c$, and $d$. Recently, he found an array $b$ of $n^2$ integers in random order and wants to make sure that these elements are the elements of **that specific** square.

It can be shown that for any values of $n$, $a_{1,1}$, $c$, and $d$, there exists exactly one progressive square that satisfies all the rules.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, int &c, int &d, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- output ""YES"" in a separate line if a progressive square for the given n, c, and d can be constructed from the array elements a, otherwise output ""NO"".

# Example 1:  
- Input:  
n = 3, c = 2, d = 3
b = [3, 9, 6, 5, 7, 1, 10, 4, 8]
- Output:  
NO

# Constraints:  
- $1 \leq n * n \leq @data$
- $1 \leq c, d \leq 10^6$
- $1 \leq b[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve1(int &n, int &c, int &d, vector<int> &a)
    {
        sort(a.begin(), a.end());
        vector<int> b(n * n);
        for (int i = 0; i < n * n; i++)
        {
            b[i] = a[0] + i / n * c + i % n * d;
        }
        sort(b.begin(), b.end());
        if (a == b)
        {
            return ""YES"";
        }
        else
        {
            return ""NO"";
        }
    }
    string solve2(int &n, int &c, int &d, vector<int> &a)
    {
        sort(a.begin(), a.end());
        int x = a[0];
        for (int i = 0; i < n * n; i++)
        {
            int tar = x + i / n * c + i % n * d;
            for (int j = 0; j < n * n; j++)
            {
                if (a[j] == tar)
                {
                    a[j] = -1;
                    break;
                }
                if (j == n * n - 1)
                {
                    return ""NO"";
                }
            }
        }
        return ""YES"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, c, d;
    cin >> n >> c >> d;
    vector<int> a(n * n);
    for (int i = 0; i < n * n; i++)
    {
        cin >> a[i];
    }

    // solve
    Solution solution;
    auto result = solution.solve(n, c, d, a);

    // output
    cout << result << ""\n"";

    return 0;
}","sort,data_structures",medium
10,"# Problem Statement
Iulia has $n$ glasses arranged in a line. The $i$\-th glass has $a_i$ units of juice in it. Iulia drinks only from odd-numbered glasses, while her date drinks only from even-numbered glasses.

To impress her date, Iulia wants to find a contiguous subarray of these glasses such that both Iulia and her date will have the same amount of juice in total if only the glasses in this subarray are considered. Please help her to do that.

More formally, find out if there exists two indices $l$, $r$ such that $1 \leq l \leq r \leq n$, and $a_l + a_{l + 2} + a_{l + 4} + \dots + a_{r} = a_{l + 1} + a_{l + 3} + \dots + a_{r-1}$ if $l$ and $r$ have the same parity and $a_l + a_{l + 2} + a_{l + 4} + \dots + a_{r - 1} = a_{l + 1} + a_{l + 3} + \dots + a_{r}$ otherwise.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- output ""YES"" if there exists a subarray satisfying the condition, and ""NO"" otherwise.

# Example 1:  
- Input:  
n = 3
a = [1, 3, 2]
- Output:  
YES

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve1(int &n, vector<int> &a)
    {
        set<long long> s = {0};
        long long sum = 0;
        for (int i = 0; i < n; i++)
        {
            sum += i % 2 ? a[i] : -a[i];
            s.insert(sum);
        }
        return s.size() == n + 1 ? ""NO"" : ""YES"";
    }
    string solve2(int &n, vector<int> &a)
    {
        for (int i = 0; i < n; i++)
        {
            long long sum = 0;
            for (int j = i; j < n; j++)
            {
                sum += j % 2 ? a[j] : -a[j];
                if (sum == 0)
                    return ""YES"";
            }
        }
        return ""NO"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","data_structures,math",medium
11,"# Problem Statement
In the summer, Vika likes to visit her country house. There is everything for relaxation: comfortable swings, bicycles, and a river.

There is a wooden bridge over the river, consisting of $n$ planks. It is quite old and unattractive, so Vika decided to paint it. And in the shed, they just found cans of paint of $k$ colors.

After painting each plank in one of $k$ colors, Vika was about to go swinging to take a break from work. However, she realized that the house was on the other side of the river, and the paint had not yet completely dried, so she could not walk on the bridge yet.

In order not to spoil the appearance of the bridge, Vika decided that she would still walk on it, but only stepping on planks of the same color. Otherwise, a small layer of paint on her sole will spoil the plank of another color. Vika also has a little paint left, but it will only be enough to repaint **one** plank of the bridge.

Now Vika is standing on the ground in front of the first plank. To walk across the bridge, she will choose some planks of the same color (after repainting), which have numbers $1 \le i_1 &lt; i_2 &lt; \ldots &lt; i_m \le n$ (planks are numbered from $1$ from left to right). Then Vika will have to cross $i_1 - 1, i_2 - i_1 - 1, i_3 - i_2 - 1, \ldots, i_m - i_{m-1} - 1, n - i_m$ planks as a result of each of $m + 1$ steps.

Since Vika is afraid of falling, she does not want to take too long steps. Help her and tell her the minimum possible maximum number of planks she will have to cross **in one step**, if she can repaint one (**or zero**) plank a different color while crossing the bridge.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &k, vector<int> &c) {
        // write your code here
    }
};
```
where:  
- return: the minimum possible maximum number of planks that Vika will have to step over in one step.

# Example 1:  
- Input:  
n = 5, k = 2
a = [1, 1, 2, 1, 1]
- Output:  
0

# Constraints:  
- $1 \leq k \leq n \leq @data$
- $1 \leq c[i] \leq k$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 1280, 64]]","class Solution
{
public:
    int solve1(int &n, int &k, vector<int> &c)
    {
        vector<int> lst(k, -1);
        vector<vector<int>> f(k);
        for (int i = 0; i < n; i++)
        {
            c[i]--;
            f[c[i]].push_back(i - 1 - lst[c[i]]);
            lst[c[i]] = i;
        }

        int ans = n;
        for (int i = 0; i < k; i++)
        {
            f[i].push_back(n - 1 - lst[i]);
            sort(f[i].begin(), f[i].end(), greater<int>());

            int res = f[i][0] / 2;
            if (f[i].size() > 1)
            {
                res = max(res, f[i][1]);
            }
            ans = min(ans, res);
        }

        return ans;
    }
    int solve2(int &n, int &k, vector<int> &c)
    {
        int ans = n;
        for (int i = 1; i <= k; i++)
        {
            int pre = -1;
            int mx1 = 0, mx2 = 0;
            for (int j = 0; j < n; j++)
            {
                if (c[j] == i)
                {
                    int x = j - pre;
                    if (x > mx1)
                    {
                        mx2 = mx1;
                        mx1 = x;
                    }
                    else if (x > mx2)
                    {
                        mx2 = x;
                    }
                    pre = j;
                }
            }
            int x = n - pre;
            if (x > mx1)
            {
                mx2 = mx1;
                mx1 = x;
            }
            else if (x > mx2)
            {
                mx2 = x;
            }
            ans = min(ans, max(mx2 - 1, (mx1 - 1) / 2));
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, k;
    cin >> n >> k;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, k, a);

    // output
    cout << result << ""\n"";

    return 0;
}","binary,data_structures,greedy,sort",hard
12,"# Problem Statement
There is a deck of $n$ cards, each of which is characterized by its power. There are two types of cards:

-   a hero card, the power of such a card is always equal to $0$;
-   a bonus card, the power of such a card is always positive.

You can do the following with the deck:

-   take a card from the top of the deck;
-   if this card is a bonus card, you can put it **on top** of your bonus deck or discard;
-   if this card is a hero card, then the power of **the top** card from your bonus deck is added to his power (if it is not empty), after that the hero is added to your army, and the used bonus discards.

Your task is to use such actions to gather an army with the maximum possible total power.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, vector<int> &s) {
        // write your code here
    }
};
```
where:  
- return: the maximum possible total power of the army that can be achieved.

# Example 1:  
- Input:  
n = 5
s = [3, 3, 3, 0, 0]
- Output:  
6

# Constraints:  
- $1 \leq n \leq @data$
- $0 \leq s[i] \leq 10^6$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve1(int &n, vector<int> &s)
    {
        priority_queue<int> q;
        long long ans = 0;
        for (int i = 0; i < n; i++)
        {
            if (s[i] == 0)
            {
                if (!q.empty())
                {
                    ans += q.top();
                    q.pop();
                }
            }
            else
            {
                q.push(s[i]);
            }
        }
        return ans;
    }
    long long solve2(int &n, vector<int> &s)
    {
        long long ans = 0;
        for (int i = 0; i < n; i++)
        {
            if (s[i] == 0)
            {
                int max = 0;
                int maxIndex = -1;
                for (int j = 0; j < i; j++)
                {
                    if (s[j] > max)
                    {
                        max = s[j];
                        maxIndex = j;
                    }
                }
                if (maxIndex != -1)
                {
                    ans += max;
                    s[maxIndex] = 0;
                }
            }
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","data_structures,greedy",medium
13,"# Problem Statement
To destroy humanity, The Monster Association sent $n$ monsters to Earth's surface. The $i$\-th monster has health $h_i$ and power $p_i$.

With his last resort attack, True Spiral Incineration Cannon, Genos can deal $k$ damage to all monsters alive. In other words, Genos can reduce the health of all monsters by $k$ (if $k &gt; 0$) with a single attack.

However, after every attack Genos makes, the monsters advance. With their combined efforts, they reduce Genos' attack damage by the power of the $^\dagger$weakest monster $^\ddagger$alive. In other words, the minimum $p_i$ among all currently living monsters is subtracted from the value of $k$ after each attack.

$^\dagger$The Weakest monster is the one with the least power.

$^\ddagger$A monster is alive if its health is strictly greater than $0$.

Will Genos be successful in killing all the monsters?

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, int &k, vector<int> &h, vector<int> &p) {
        // write your code here
    }
};
```
where:  
- return: YES if Genos could kill all monsters and NO otherwise. 

# Example 1:  
- Input:
n = 6, k = 7
h = [18, 5, 13, 9, 10, 1]
p = [2, 7, 2, 1, 2, 6]  
- Output:  
YES

# Constraints:  
- $1 \leq n, k \leq @data$
- $1 \leq h[i], p[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve1(int &n, int &k, vector<int> &h, vector<int> &p)
    {
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;
        for (int i = 0; i < n; i++)
            q.push({p[i], h[i]});
        int cnt = k;
        while (!q.empty())
        {
            auto [x, y] = q.top();
            q.pop();
            if (cnt >= y)
                continue;
            q.push({x, y});
            k -= x;
            if (k <= 0)
            {
                return ""NO"";
            }
            cnt += k;
        }
        return ""YES"";
    }
    string solve2(int &n, int &k, vector<int> &h, vector<int> &p)
    {
        int cnt = k;
        while (1)
        {
            int mn = 1e9;
            int pos = -1;
            for (int i = 0; i < n; i++)
            {
                if (p[i] == 0)
                    continue;
                if (p[i] < mn)
                {
                    mn = p[i];
                    pos = i;
                }
            }
            if (pos == -1)
                break;
            p[pos] = 0;
            if (cnt >= h[pos])
                continue;
            k -= mn;
            if (k <= 0)
            {
                return ""NO"";
            }
            cnt += k;
        }
        return ""YES"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, k;
    cin >> n >> k;
    vector<int> h(n), p(n);
    for (int i = 0; i < n; i++)
    {
        cin >> h[i];
    }
    for (int i = 0; i < n; i++)
    {
        cin >> p[i];
    }

    // solve
    Solution solution;
    auto result = solution.solve(n, k, h, p);

    // output
    cout << result << ""\n"";

    return 0;
}","binary,data_structures,math,sort",medium
14,"A ramp in an integer array nums is a pair (i, j) for which i < j and nums[i] <= nums[j]. The width of such a ramp is j - i.

Given an integer array nums, return the maximum width of a ramp in nums. If there is no ramp in nums, return 0.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [6,0,8,2,1,5]
Output: 4

Example 2:
Input: nums = [9,8,1,0,1,9,4,0,4,1]
Output: 7

Constraints:

2 <= nums.length <= @data
0 <= nums[i] <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve1(vector<int>& nums) {
        int n = nums.size();
        stack<int> indicesStack;

        // Fill the stack with indices in increasing order of their values
        for (int i = 0; i < n; i++) {
            if (indicesStack.empty() || nums[indicesStack.top()] > nums[i]) {
                indicesStack.push(i);
            }
        }

        int maxWidth = 0;

        // Traverse the array from the end to the start
        for (int j = n - 1; j >= 0; j--) {
            while (!indicesStack.empty() &&
                   nums[indicesStack.top()] <= nums[j]) {
                maxWidth = max(maxWidth, j - indicesStack.top());
                // Pop the index since it's already processed
                indicesStack.pop();
            }
        }

        return maxWidth;
    }
    int solve2(vector<int>& nums) {
        int n = nums.size();
        int maxWidth = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (nums[i] <= nums[j]) {
                    maxWidth = max(maxWidth, j - i);
                }
            }
        }
        return maxWidth;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int > num;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num);
    
    // output
    cout << result << ""\n"";

    return 0;
}",two_pointers,medium
15,"There are several squares being dropped onto the X-axis of a 2D plane.

You are given a 2D integer array positions where positions[i] = [lefti, sideLengthi] represents the ith square with a side length of sideLengthi that is dropped with its left edge aligned with X-coordinate lefti.

Each square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands on the top side of another square or on the X-axis. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved.

After each square is dropped, you must record the height of the current tallest stack of squares.

Return an integer array ans where ans[i] represents the height described above after dropping the ith square.

solution main function
```cpp
class Solution {
public:
    vector<int> solve(vector<vector<int>>& positions) {
        
    }
};
```

Example 1:
Input: positions = [[1,2],[2,3],[6,1]]
Output: [2,5,5]

Example 2:
Input: positions = [[100,100],[200,100]]
Output: [100,100]

Constraints:

1 <= positions.length <= @data
1 <= lefti <= 10^8
1 <= sideLengthi <= 10^6

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[64000, 6400, 800]]","#include<bits/stdc++.h>
using namespace std;
struct SegmentTree {

    SegmentTree(int n) : n(n) {
        size = 1;
        while (size < n) {
            size <<= 1;
        }
        tree.resize(2 * size);
        lazy.resize(2 * size);
    }

    void add_range(int l, int r, int h) {
        l += size;
        r += size;

        tree[l] = max(tree[l], h);
        tree[r] = max(tree[r], h);
        if (l != r) {
            if (!(l & 1)) {
                lazy[l + 1] = max(lazy[l - 1], h);
            }
            if (r & 1) {
                lazy[r - 1] = max(lazy[r - 1], h);
            }
        }
        l >>= 1;
        r >>= 1;
        while (l != r) {
            tree[l] = max(tree[2 * l], tree[2 * l + 1]);
            tree[r] = max(tree[2 * r], tree[2 * r + 1]);
            if (l / 2 != r / 2) {
                if (!(l & 1)) {
                    lazy[l + 1] = max(lazy[l + 1], h);
                }
                if (r & 1) {
                    lazy[r - 1] = max(lazy[r - 1], h);
                }
            }
            l >>= 1;
            r >>= 1;
        }
        while (l > 0) {
            tree[l] = max(tree[2 * l], tree[2 * l + 1]);
            l >>= 1;
        }
    }
    int max_range(int l, int r) {
        l += size;
        r += size;

        int max_val = max(tree[l], tree[r]);
        while (l / 2 != r / 2) {
            if (!(l & 1)) {
                max_val = max(tree[l + 1], max_val);
                max_val = max(lazy[l + 1], max_val);
            }
            if (r & 1) {
                max_val = max(tree[r - 1], max_val);
                max_val = max(lazy[r - 1], max_val);
            }
            max_val = max(max_val, lazy[l]);
            max_val = max(max_val, lazy[r]);

            l >>= 1;
            r >>= 1;
        }
        max_val = max(max_val, lazy[r]);

        while (l / 2 > 0) {
            max_val = max(lazy[l], max_val);
            l >>= 1;
        }
        return max_val;
    }
    int global_max() { return max_range(0, n - 1); }
    int size;
    int n;
    vector<int> tree;
    vector<int> lazy;
};
class Solution
{
public:
    vector<int> solve1(vector<vector<int>>& positions) {
        vector<int> qans(positions.size());

        for (int i = 0; i < positions.size(); i++) {
            int left = positions[i][0];
            int size = positions[i][1];
            int right = left + size;
            qans[i] += size;

            for (int j = i + 1; j < positions.size(); j++) {
                int left2 = positions[j][0];
                int size2 = positions[j][1];
                int right2 = left2 + size2;
                if (left2 < right && left < right2) { //intersect
                    qans[j] = max(qans[j], qans[i]);
                }
            }
        }

        vector<int> ans;
        int cur = -1;
        for (int x: qans) {
            cur = max(cur, x);
            ans.push_back(cur);
        }
        return ans;        
    }

    vector<int> solve2(vector<vector<int>>& positions) {

        vector<int> points;
        for (const auto& rect : positions) {
            points.push_back(rect[0]);
            points.push_back(rect[0] + rect[1] - 1);
        }
        sort(begin(points), end(points));
        auto new_end = unique(begin(points), end(points));
        points.resize(distance(begin(points), new_end));

        SegmentTree st(points.size());

        vector<int> results;

        int max_height = 0;
        for (const auto& rect : positions) {
            int x_1 = rect[0];
            int x_2 = rect[0] + rect[1] - 1;

            int l = distance(begin(points),
                             lower_bound(begin(points), end(points), x_1));
            int r = distance(begin(points),
                             lower_bound(begin(points), end(points), x_2));

            int cur_height = st.max_range(l, r);
            int new_height = rect[1] + cur_height;
            max_height = max(new_height, max_height);
            st.add_range(l, r, new_height);
            results.push_back(max_height);
        }
        return results;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector< vector<int> > s;
    for(int i=1,x,y;i<=n;i++)
    {
        scanf(""%d"",&x);
        scanf(""%d"",&y);
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        s.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    for(auto it:result) printf(""%d "",it);
    // cout << result << ""\n"";

    return 0;
}",data_structures,hard
16,"There are n soldiers standing in a line. Each soldier is assigned a unique rating value.
You have to form a team of 3 soldiers amongst them under the following rules:
    Choose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j], rating[k]).
    A team is valid if: (rating[i] < rating[j] < rating[k]) or (rating[i] > rating[j] > rating[k]) where (0 <= i < j < k < n).
Return the number of teams you can form given the conditions. (soldiers can be part of multiple teams).

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& rating) {

    }
};
```

Example 1:
Input: rating = [2,5,3,4,1]
Output: 3

Example 2:
Inputrating = [2,1,3]
Output: 0

Constraints:
n == rating.length
3 <= n <= @data
1 <= rating[i] <= 10^5
All the integers in rating are unique.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",3000.0,"[[128000, 12800, 1280]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:

    vector<int> ordered;
    vector<int> tree;

    void update(int index, int val) {
        for (int i=index+1; i<tree.size(); i += i & -i) {
            tree[i] += val;
        }
    }

    int sum(int r) {
        int res = 0;
        for (int i=r+1; i > 0; i &= i-1) {
            res += tree[i];
        }
        return res;
    }

    int solve1(vector<int>& rating) {
        int n = rating.size();
        tree.resize(n+1);

        ordered = rating;
        sort(ordered.begin(), ordered.end());

        auto get_idx = [&](int rate) {
            return lower_bound(ordered.begin(), ordered.end(), rate) - ordered.begin();
        };

        vector<int> lo(n), hi(n);

        for (int i=0; i<n; i++) {
            int cur_rate = rating[i];
            int ridx = get_idx(cur_rate);
            lo[i] = sum(ridx);
            update(ridx, 1);
        }
        for (int i=0; i<n; i++) {
            int ridx = get_idx(rating[i]);
            update(ridx, -1);
            hi[i] = sum(n-1) - sum(ridx);
        }

        int ans = 0;
        for (int i=0; i<n; i++) {
            ans += lo[i] * hi[i];
            ans += (i - lo[i]) * (n-1-i-hi[i]);
        }
        return ans;
    }
    int solve2(vector<int>& rating) {
        int n = rating.size();
        int ans = 0;
        for (int j = 1; j < n - 1; ++j) {
            int iless = 0, imore = 0;
            int kless = 0, kmore = 0;
            for (int i = 0; i < j; ++i) {
                if (rating[i] < rating[j]) {
                    ++iless;
                }
                else if (rating[i] > rating[j]) {
                    ++imore;
                }
            }
            for (int k = j + 1; k < n; ++k) {
                if (rating[k] < rating[j]) {
                    ++kless;
                }
                else if (rating[k] > rating[j]) {
                    ++kmore;
                }
            }
            ans += iless * kmore + imore * kless;
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    cin>>n;
    vector<int> rat;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        rat.push_back(x);
    }
    // solve
    Solution solution;
            auto result = solution.solve(rat);
    
    // output
    cout<<result;
    return 0;
}",data_structures,medium
17,"Given a string s, return the number of palindromic substrings in it.
A string is a palindrome when it reads the same backward as forward.
A substring is a contiguous sequence of characters within the string.

solution main function
```cpp
class Solution {
public:
    int solve(string s) {

    }
};
```

Example 1:
Input: s = ""abc""
Output: 3

Example 2:
Input: s = ""aaa""
Output: 6

Constraints:
1 <= s.length <= @data
s consists of lowercase English letters.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 100, 1000]",1000.0,"[[12800, 1280, 128]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve1(string s) {
        int n = s.size();
        string t = ""$#"";
        for (const char &c: s) {
            t += c;
            t += '#';
        }
        n = t.size();
        t += '!';

        auto f = vector <int> (n);
        int iMax = 0, rMax = 0, ans = 0;
        for (int i = 1; i < n; ++i) {
            f[i] = (i <= rMax) ? min(rMax - i + 1, f[2 * iMax - i]) : 1;
            while (t[i + f[i]] == t[i - f[i]]) ++f[i];
            if (i + f[i] - 1 > rMax) {
                iMax = i;
                rMax = i + f[i] - 1;
            }
            ans += (f[i] / 2);
        }

        return ans;
    }
    int solve2(string s) {
        int n = s.size(), ans = 0;
        for (int i = 0; i < 2 * n - 1; ++i) {
            int l = i / 2, r = i / 2 + i % 2;
            while (l >= 0 && r < n && s[l] == s[r]) {
                --l;
                ++r;
                ++ans;
            }
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string str; cin>>str;
    // solve
    Solution solution;
            auto result = solution.solve(str);
    
    // output
    cout<<result;
    return 0;
}",string,easy
18,"You are given a 2D matrix of size m x n, consisting of non-negative integers. You are also given an integer k.
The value of coordinate (a, b) of the matrix is the XOR of all matrix[i][j] where 0 <= i <= a < m and 0 <= j <= b < n (0-indexed).
Find the kth largest value (1-indexed) of all the coordinates of matrix.

solution main function
```cpp
class Solution {
public:
    int solve(vector<vector<int>>& matrix, int k) {

    }
};
```

Example 1:
Input: matrix = [[5,2],[1,6]], k = 1
Output: 7

Example 2:
Inputmatrix = [[5,2],[1,6]], k = 2
Output: 5

Constraints:
m == matrix.length
n == matrix[i].length
1 <= m, n <= @data
0 <= matrix[i][j] <= 10^6
1 <= k <= m * n
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 100, 1000]",1000.0,"[[12800, 8000, 4000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve1(vector<vector<int>>& matrix, int k) {
        int m = matrix.size(), n = matrix[0].size();
        // vector<vector<int>> pre(m + 1, vector<int>(n + 1));
        vector<int> results;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if(i-1>=0) matrix[i][j] ^= matrix[i - 1][j];
                if(j-1>=0) matrix[i][j] ^= matrix[i][j - 1];
                if(i-1>=0&&j-1>=0) matrix[i][j] ^= matrix[i - 1][j - 1];
                results.push_back(matrix[i][j]);
            }
        }
        nth_element(results.begin(), results.begin() + k - 1, results.end(), greater<int>());
        return results[k - 1];
    }
    int solve2(vector<vector<int>>& matrix, int k) {
        int n = matrix.size(), m = matrix[0].size();
        priority_queue<int, vector<int>, greater<int>> pq;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                matrix[i][j] ^=
                    (i - 1 > -1 ? matrix[i - 1][j] : 0) ^
                    (j - 1 > -1 ? matrix[i][j - 1] : 0) ^
                    (i - 1 > -1 && j - 1 > -1 ? matrix[i - 1][j - 1] : 0);
                if (pq.size() < k)
                    pq.push(matrix[i][j]);
                else {
                    if (pq.top() < matrix[i][j]) {
                        pq.pop();
                        pq.push(matrix[i][j]);
                    }
                }
            }
        }
        return pq.top();
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m,k;cin>>n>>m>>k;
    vector<vector<int> > num;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=m;j++)
        {
            int x; cin>>x;
            temp.push_back(x);
        }
        num.push_back(temp);
    }
    // solve
    Solution solution;
            auto result = solution.solve(num,k);
    
    // output
    cout<<result;
    return 0;
}",bit_manipulation,medium
19,"Given an array of integers arr.
We want to select three indices i, j and k where (0 <= i < j <= k < arr.length).
Let's define a and b as follows:
    a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
    b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]
Note that ^ denotes the bitwise-xor operation.
Return the number of triplets (i, j and k) Where a == b.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& arr) {

    }
};
```

Example 1:
Input: arr = [2,3,1,6,7]
Output: 4

Example 2:
Input: arr = [2,3,1,6,7]
Output: 4

Constraints:
1 <= arr.length <= @data
1 <= arr[i] <= 10^8
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 100, 1000]",1000.0,"[[12800, 1280, 128]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve1(vector<int>& arr) {
            int ans = 0;
            int n = arr.size();
            for (int i = 0; i < n - 1; ++i) {
                int temp = arr[i];
                for (int j = i + 1; j < n; ++j) {
                    temp ^= arr[j];
                    if (temp == 0)
                        ans += j - i;
                }
            }
            return ans;
        }
    int solve2(vector<int> &arr) {
        int n = arr.size();
        unordered_map<int, int> cnt, total;
        int ans = 0, s = 0;
        for (int k = 0; k < n; ++k) {
            int val = arr[k];
            if (cnt.count(s ^ val)) {
                ans += cnt[s ^ val] * k - total[s ^ val];
            }
            ++cnt[s];
            total[s] += k;
            s ^= val;
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> arr;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        arr.push_back(x);
    }
    // solve
    Solution solution;
            auto result = solution.solve(arr);
    
    // output
    cout<<result;
    return 0;
}","dp,bit_manipulation",medium
20,"You are given an integer array prices where prices[i] is the price of the ith item in a shop.
There is a special discount for items in the shop. If you buy the ith item, then you will receive a discount equivalent to prices[j] where j is the minimum index such that j > i and prices[j] <= prices[i]. Otherwise, you will not receive any discount at all.
Return an integer array answer where answer[i] is the final price you will pay for the ith item of the shop, considering the special discount.

solution main function
```cpp
class Solution
{
    public:
    vector<int> solve(vector<int>& prices)
}
```

Example 1:
Inputprices = [8,4,6,2,3]
Output: [4,2,4,2,3]

Example 2:
Inputprices = [1,2,3,4,5]
Output: [1,2,3,4,5]

Constraints:
1 <= prices.length <= @data
1 <= prices[i] <= 10^3
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 1000, 10000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> solve1(vector<int>& prices) {
        int n = prices.size();
        vector<int> ans(n);
        stack<int> st;
        for (int i = n - 1; i >= 0; i--) {
            while (!st.empty() && st.top() > prices[i]) {
                st.pop();
            }
            ans[i] = st.empty() ? prices[i] : prices[i] - st.top();
            st.emplace(prices[i]);
        }
        return ans;
    }
    vector<int> solve2(vector<int>& prices) {
        int n = prices.size();
        vector<int> ans;
        for (int i = 0; i < n; ++i) {
            int discount = 0;
            for (int j = i + 1; j < n; ++j) {
                if(prices[j] <= prices[i]){
                    discount = prices[j];
                    break;
                }
            }
            ans.emplace_back(prices[i] - discount);
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    cin>>n;
    vector<int> price;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        price.push_back(x);
    }
    // solve
    Solution solution;
            auto result = solution.solve(price);
    
    // output
    for(auto it:result) cout<<it<<' ';

    return 0;
}",data_structures,easy
21,"Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.

solution main function
```cpp
class Solution {
public:
    vector<vector<int>> solve(vector<int>& nums) {

    }
};
```

Example 1:
Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
Output: 3

Example 2:
Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
Output: 5

Constraints:
1 <= nums1.length, nums2.length <= @data
0 <= nums1[i], nums2[i] <= 100
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 100, 1000]",1000.0,"[[12800, 1280, 128]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    const int mod = 1000000009;
    const int base = 113;

    long long qPow(long long x, long long n) {
        long long ret = 1;
        while (n) {
            if (n & 1) {
                ret = ret * x % mod;
            }
            x = x * x % mod;
            n >>= 1;
        }
        return ret;
    }

    bool check(vector<int>& A, vector<int>& B, int len) {
        long long hashA = 0;
        for (int i = 0; i < len; i++) {
            hashA = (hashA * base + A[i]) % mod;
        }
        unordered_set<long long> bucketA;
        bucketA.insert(hashA);
        long long mult = qPow(base, len - 1);
        for (int i = len; i < A.size(); i++) {
            hashA = ((hashA - A[i - len] * mult % mod + mod) % mod * base + A[i]) % mod;
            bucketA.insert(hashA);
        }
        long long hashB = 0;
        for (int i = 0; i < len; i++) {
            hashB = (hashB * base + B[i]) % mod;
        }
        if (bucketA.count(hashB)) {
            return true;
        }
        for (int i = len; i < B.size(); i++) {
            hashB = ((hashB - B[i - len] * mult % mod + mod) % mod * base + B[i]) % mod;
            if (bucketA.count(hashB)) {
                return true;
            }
        }
        return false;
    }

    int solve1(vector<int>& A, vector<int>& B) {
        int left = 1, right = min(A.size(), B.size()) + 1;
        while (left < right) {
            int mid = (left + right) >> 1;
            if (check(A, B, mid)) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left - 1;
    }
    int maxLength(vector<int>& A, vector<int>& B, int addA, int addB, int len) {
        int ret = 0, k = 0;
        for (int i = 0; i < len; i++) {
            if (A[addA + i] == B[addB + i]) {
                k++;
            } else {
                k = 0;
            }
            ret = max(ret, k);
        }
        return ret;
    }
    int solve2(vector<int>& A, vector<int>& B) {
        int n = A.size(), m = B.size();
        int ret = 0;
        for (int i = 0; i < n; i++) {
            int len = min(m, n - i);
            int maxlen = maxLength(A, B, i, 0, len);
            ret = max(ret, maxlen);
        }
        for (int i = 0; i < m; i++) {
            int len = min(n, m - i);
            int maxlen = maxLength(A, B, 0, i, len);
            ret = max(ret, maxlen);
        }
        return ret;
    }
};","#include <bits/stdc++.h>
#include <iterator>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    vector<int> num1,num2;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num1.push_back(x);
    }
    for(int i=1;i<=m;i++)
    {
        int x; cin>>x;
        num2.push_back(x);
    }
    // solve
    Solution solution;
            auto result = solution.solve(num1,num2);
    
    // output
    cout<<result;
    return 0;
}","dp,binary,string",medium
22,"The chess knight has a unique movement, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagram:
We have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell (i.e. blue cell).
1 2 3
4 5 6
7 8 9
* 0 #

'*' and '#' are red,the others are blue
Given an integer n, return how many distinct phone numbers of length n we can dial.
You are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps.
As the answer may be very large, return the answer modulo 10^9 + 7.

solution main function
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

Example 1:
Input: n = 1
Output: 10

Example 2:
Input: n = 2
Output: 20

Constraints:
1 <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000000, 1000000000]",1000.0,"[[256000, 25600, 2560]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
    static constexpr int mod = 1e9 + 7;

public:
    int solve1(int n) {
        vector<vector<int>> moves = {
            {4, 6},
            {6, 8},
            {7, 9},
            {4, 8},
            {3, 9, 0},
            {},
            {1, 7, 0},
            {2, 6},
            {1, 3},
            {2, 4}
        };
        vector<vector<int>> d(2, vector<int>(10, 0));
        fill(d[1].begin(), d[1].end(), 1);
        for (int i = 2; i <= n; i++) {
            int x = i & 1;
            for (int j = 0; j < 10; j++) {
                d[x][j] = 0;
                for (int k : moves[j]) {
                    d[x][j] = (d[x][j] + d[x ^ 1][k]) % mod;
                }
            }
        }
        int res = 0;
        for (auto x : d[n % 2]) {
            res = (res + x) % mod;
        }
        return res;
    }
    vector<vector<int>> mul(const vector<vector<int>> &lth, const vector<vector<int>> &rth) {
        vector<vector<int>> res(lth.size(), vector<int>(rth[0].size(), 0));
        for (int k = 0; k < lth[0].size(); k++) {
            for (int i = 0; i < lth.size(); i++) {
                for (int j = 0; j < rth[0].size(); j++) {
                    res[i][j] = (res[i][j] + 1ll * lth[i][k] * rth[k][j] % mod) % mod;
                }
            }
        }
        return res;
    }

    int solve2(int n) {
        vector<vector<int>> base = {
            {0, 0, 0, 0, 1, 0, 1, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 1, 0, 1, 0},
            {0, 0, 0, 0, 0, 0, 0, 1, 0, 1},
            {0, 0, 0, 0, 1, 0, 0, 0, 1, 0},
            {1, 0, 0, 1, 0, 0, 0, 0, 0, 1},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 1, 0, 0, 0, 0, 0, 1, 0, 0},
            {0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0},
            {0, 0, 1, 0, 1, 0, 0, 0, 0, 0}
        };
        vector<vector<int>> res = {
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
        };

        vector<vector<int>> base2 = vector<vector<int>>(10, vector<int>(10, 0));
        for (int i = 0; i < 10; i++) {
            base2[i][i] = 1;
        }
        n--;
        while (n > 0) {
            if (n & 1) {
                base2 = mul(base2, base);
            }
            base = mul(base, base);
            n >>= 1;
        }
        res = mul(res, base2);
        int ret = 0;
        for (auto x : res[0]) {
            ret = (ret + x) % mod;
        }

        return ret;
    }
};","#include <bits/stdc++.h>
#include <iterator>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
            auto result = solution.solve(n);
    
    // output
    cout<<result;
    return 0;
}",math,medium
23,"You are given a 0-indexed integer array nums of length n.

You can perform the following operation as many times as you want:

    Pick an index i that you havent picked before, and pick a prime p strictly less than nums[i], then subtract p from nums[i].

Return true if you can make nums a strictly increasing array using the above operation and false otherwise.

A strictly increasing array is an array whose each element is strictly greater than its preceding element.

solution main function

```cpp
class Solution {
public:
    bool solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [4,9,6,10]
Output: true

Example 2:
Input: nums = [6,8,11,12]
Output: true

Constraints:

1 <= nums.length <= @data
1 <= nums[i] <= @data*10
nums.length == n

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    bool solve1(vector<int>& nums) {
        int maxElement = *max_element(nums.begin(), nums.end());

        // Store the sieve array.
        vector<int> sieve(maxElement + 1, 1);
        sieve[1] = 0;
        for (int i = 2; i <= sqrt(maxElement + 1); i++) {
            if (sieve[i] == 1) {
                for (int j = i * i; j <= maxElement; j += i) {
                    sieve[j] = 0;
                }
            }
        }

        // Start by storing the currValue as 1, and the initial index as 0.
        int currValue = 1;
        int i = 0;
        while (i < nums.size()) {
            // Store the difference needed to make nums[i] equal to currValue.
            int difference = nums[i] - currValue;

            // If difference is less than 0, then nums[i] is already less than
            // currValue. Return false in this case.
            if (difference < 0) {
                return 0;
            }

            // If the difference is prime or zero, then nums[i] can be made
            // equal to currValue.
            if (sieve[difference] == 1 or difference == 0) {
                i++;
                currValue++;
            } else {
                // Otherwise, try for the next currValue.
                currValue++;
            }
        }
        return 1;
    }
    bool checkPrime(int x) {
        for (int i = 2; i <= sqrt(x); i++) {
            if (x % i == 0) {
                return 0;
            }
        }
        return 1;
    }
    bool solve2(vector<int>& nums) {
        for (int i = 0; i < nums.size(); i++) {
            int bound;
            // In case of first index, we need to find the largest prime less
            // than nums[0].
            if (i == 0) {
                bound = nums[0];
            } else {
                // Otherwise, we need to find the largest prime, that makes the
                // current element closest to the previous element.
                bound = nums[i] - nums[i - 1];
            }

            // If the bound is less than or equal to 0, then the array cannot be
            // made strictly increasing.
            if (bound <= 0) {
                return 0;
            }

            // Find the largest prime less than bound.
            int largestPrime = 0;
            for (int j = bound - 1; j >= 2; j--) {
                if (checkPrime(j)) {
                    largestPrime = j;
                    break;
                }
            }

            // Subtract this value from nums[i].
            nums[i] = nums[i] - largestPrime;
        }
        return 1;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    vector<int> num;
    cin>>n;
    for(int i=1,x;i<=n;i++)
    {
        cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num);
    
    // output
    cout<<result;
    return 0;
}","math,greedy,binary",hard
24,"You are given a positive integer array skill of even length n where skill[i] denotes the skill of the ith player. Divide the players into n / 2 teams of size 2 such that the total skill of each team is equal.

The chemistry of a team is equal to the product of the skills of the players on that team.

Return the sum of the chemistry of all the teams, or return -1 if there is no way to divide the players into teams such that the total skill of each team is equal.

solution main function

```cpp
class Solution {
public:
    long long solve(vector<int>& skill) {
        
    }
};
```

Example 1:
Input: skill = [3,2,5,1,3,4]
Output: 22

Example 2:
Input: skill = [3,4]
Output: 12

Constraints:


2 <= skill.length <= @data
skill.length is even.
1 <= skill[i] <= 1000

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 10000, 100000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    long long solve1(vector<int>& skill) {
        int n = skill.size();
        int totalSkill = 0;
        vector<int> skillFrequency(2001, 0);

        // Calculate total skill and skill frequency
        for (int playerSkill : skill) {
            totalSkill += playerSkill;
            skillFrequency[playerSkill]++;
        }

        // Check if total skill can be evenly distributed among teams
        if (totalSkill % (n / 2) != 0) {
            return -1;
        }

        int targetTeamSkill = totalSkill / (n / 2);
        long long totalChemistry = 0;

        // Calculate total chemistry while verifying valid team formations
        for (int playerSkill : skill) {
            int partnerSkill = targetTeamSkill - playerSkill;

            // Check if a valid partner exists
            if (skillFrequency[partnerSkill] == 0) {
                return -1;
            }

            totalChemistry += (long long)playerSkill * (long long)partnerSkill;
            skillFrequency[partnerSkill]--;
        }

        // Return half of totalChemistry as each pair is counted twice
        return totalChemistry / 2;
    }
    long long solve2(vector<int>& skill) {
        sort(skill.begin(), skill.end());
        int total = skill.front() + skill.back();
        long long chemistry = 0;
        for (int i = 0, j = skill.size() - 1; i < j; ++i, --j) {
            if (skill[i] + skill[j] != total) return -1;
            chemistry += (long long)skill[i] * skill[j];
        }
        return chemistry;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    vector<int> num;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num);
    
    // output
    cout<<result;
    return 0;
}","two_pointers,sort",easy
25,"You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray.

Return the sum of all subarray ranges of nums.

A subarray is a contiguous non-empty sequence of elements within an array.

solution main function

```cpp
class Solution {
public:
    long long solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [1,2,3]
Output: 4

Example 2:
Input: nums = [1,3,3]
Output: 4

Constraints:


1 <= nums.length <= @data
-10^6 <= nums[i] <= 10^6


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    long long solve1(vector<int>& nums) {
        int n = nums.size();
        long long answer = 0;
        stack<int> stk;

        // Find the sum of all the minimum.
        for (int right = 0; right <= n; ++right) {
            while (!stk.empty() &&
                   (right == n || nums[stk.top()] >= nums[right])) {
                int mid = stk.top();
                stk.pop();
                int left = stk.empty() ? -1 : stk.top();
                answer -= (long long)nums[mid] * (right - mid) * (mid - left);
            }
            stk.push(right);
        }

        // Find the sum of all the maximum.
        stk.pop();
        for (int right = 0; right <= n; ++right) {
            while (!stk.empty() &&
                   (right == n || nums[stk.top()] <= nums[right])) {
                int mid = stk.top();
                stk.pop();
                int left = stk.empty() ? -1 : stk.top();
                answer += (long long)nums[mid] * (right - mid) * (mid - left);
            }
            stk.push(right);
        }
        return answer;
    }
    long long solve2(vector<int>& nums) {
        int n = int(nums.size());
        long long answer = 0;

        for (int left = 0; left < n; ++left) {
            int minVal = nums[left], maxVal = nums[left];
            for (int right = left; right < n; ++right) {
                maxVal = max(maxVal, nums[right]);
                minVal = min(minVal, nums[right]);
                answer += maxVal - minVal;
            }
        }

        return answer;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector< int > a;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        a.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(a);
    
    // output
    cout << result << ""\n"";

    return 0;
}",math,medium
26,"# Problem Statement
Given an array with $n$ intergers $a_1, a_2, \dots, a_n$, and $m$ operations, the $i$-th operation is
    * $1, p, b$: Given $p$ and $b$, update $a_p = b$.
    * $2, l, r$: Given $l$ and $r$, return the sum of values in interval $[l, r]$.

The solution's main function is:  
```cpp
class Solution {
public:
    long long solve(int &n, vector<int> &a, int &m, vector<array<int, 3>> &ops) {
        // write your code here
    }
};
```
where:
- `op` is an array of 3 integers, $op[0]$ is the operation type, $op[1]$ and $op[2]$ are the parameters of the operation.
- return the xor value of all operation 2 answers, please return the result in a `long long` type.

# Example 1  
- Input:  
n = 5
a = [1, 2, 3, 4, 5]
m = 3
ops = [[2, 1, 3], [1, 2, 6], [2, 1, 3]]
- Output:  
12

# Constraints:  
- $1 \leq n, m \leq @data$
- $1 \leq a_i, b \leq 10^6$
- $1 \leq p, l, r \leq n$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[5000, 50000, 100000]",1000.0,"[[6400, 640, 40]]","class Solution
{
public:
    long long solve1(int &n, vector<int> &a, int &m, vector<array<int, 3>> &ops)
    {
        vector<long long> b(n + 1);
        auto add = [&](int i, int x)
        {
            for (; i <= n; i += i & -i)
                b[i] += x;
        };
        auto ask = [&](int i)
        {
            long long res = 0;
            for (; i > 0; i -= i & -i)
                res += b[i];
            return res;
        };
        for (int i = 0; i < n; i++)
            add(i + 1, a[i]);
        long long ans = 0;
        for (auto &[op, l, r] : ops)
        {
            if (op == 1)
            {
                add(l, -a[l - 1]);
                a[l - 1] = r;
                add(l, r);
            }
            else
                ans = ans ^ (ask(r) - ask(l - 1));
        }
        return ans;
    }
    long long solve2(int &n, vector<int> &a, int &m, vector<array<int, 3>> &ops)
    {
        long long ans = 0;
        for (auto &[op, l, r] : ops)
        {
            if (op == 1)
                a[l - 1] = r;
            else
            {
                long long sum = 0;
                for (int i = l - 1; i < r; i++)
                    sum += a[i];
                ans = ans ^ sum;
            }
        }
        return ans;
    }
    long long solve3(int &n, vector<int> &a, int &m, vector<array<int, 3>> &ops)
    {
        int blockSize = static_cast<int>(sqrt(n)) + 1;
        int blockCount = (n + blockSize - 1) / blockSize;
        vector<long long> blockSum(blockCount, 0);
        for (int i = 0; i < n; ++i)
            blockSum[i / blockSize] += a[i];
        long long result = 0;
        for (const auto &op : ops)
        {
            int type = op[0];
            if (type == 1)
            {
                int p = op[1] - 1;
                int b = op[2];
                int blockIndex = p / blockSize;
                blockSum[blockIndex] += b - a[p];
                a[p] = b;
            }
            else if (type == 2)
            {
                int l = op[1] - 1;
                int r = op[2] - 1;
                long long sum = 0;
                int startBlock = l / blockSize;
                int endBlock = r / blockSize;
                if (startBlock == endBlock)
                    for (int i = l; i <= r; ++i)
                        sum += a[i];
                else
                {
                    for (int i = l; i < (startBlock + 1) * blockSize; ++i)
                        sum += a[i];
                    for (int i = startBlock + 1; i < endBlock; ++i)
                        sum += blockSum[i];
                    for (int i = endBlock * blockSize; i <= r; ++i)
                        sum += a[i];
                }
                result ^= sum;
            }
        }
        return result;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];
    int m;
    cin >> m;
    vector<array<int, 3>> ops(m);
    for (int i = 0; i < m; i++)
        cin >> ops[i][0] >> ops[i][1] >> ops[i][2];

    // solve
    Solution solution;
    auto result = solution.solve(n, a, m, ops);

    // output
    cout << result << ""\n"";

    return 0;
}",data_structures,medium
27,"# Problem Statement
Dora has a set $s$ containing integers. In the beginning, she will put all integers in $[l, r]$ into the set $s$. That is, an integer $x$ is initially contained in the set if and only if $l \leq x \leq r$. Then she allows you to perform the following operations:

-   Select three **distinct** integers $a$, $b$, and $c$ from the set $s$, such that $\gcd(a, b) = \gcd(b, c) = \gcd(a, c) = 1^\dagger$.
-   Then, remove these three integers from the set $s$.

What is the maximum number of operations you can perform?

$^\dagger$Recall that $\gcd(x, y)$ means the [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers $x$ and $y$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &l, int &r) {
        // write your code here
    }
};
```
where:  
- return: the maximum number of operations you can perform.

# Example 1:  
- Input:  
l = 1, r = 3
- Output:  
1

# Constraints:  
- $1 \leq l \leq r \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 1000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &l, int &r)
    {
        int ans = 0;
        for (int i = l; i + 2 <= r; i++)
        {
            if (i % 2 == 0)
                continue;
            ans++;
            i += 2;
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int l, r;
    cin >> l >> r;

    // solve
    Solution solution;
    auto result = solution.solve(l, r);

    // output
    cout << result << ""\n"";

    return 0;
}",math,medium
28,"Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1). 

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [3,4,5,2]
Output: 12 

Example 2:
Input: nums = [1,5,4,5]
Output: 16

Constraints:


2 <= nums.length <= @data
1 <= nums[i] <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(),nums.end());

        int result = (nums[n-1] - 1) * (nums[n-2] - 1);
        return result;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> num;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num);
    // output
    cout << result << ""\n"";
    // for(auto it:result) cout<<it<<' ';
    return 0;
}",math,easy
29,"There is a safe protected by a password. The password is a sequence of n digits where each digit can be in the range [0, k - 1].
The safe has a peculiar way of checking the password. When you enter in a sequence, it checks the most recent n digits that were entered each time you type a digit.
    For example, the correct password is ""345"" and you enter in ""012345"":
        After typing 0, the most recent 3 digits is ""0"", which is incorrect.
        After typing 1, the most recent 3 digits is ""01"", which is incorrect.
        After typing 2, the most recent 3 digits is ""012"", which is incorrect.
        After typing 3, the most recent 3 digits is ""123"", which is incorrect.
        After typing 4, the most recent 3 digits is ""234"", which is incorrect.
        After typing 5, the most recent 3 digits is ""345"", which is correct and the safe unlocks.
Return any string of minimum length that will unlock the safe at some point of entering it.

solution main function
```cpp
class Solution
{
    public:
    string solve(int n, int k)
}
```
Example 1:
Inputn = 1, k = 2
Output: ""10""

Example 2:
Inputn = 2, k = 2
Output: ""01100""

Constraints:
1 <= n <= 4
1 <= k <= @data
1 <= k^n <= 4096
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[3, 5, 10]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    string solve(int n, int k) {
        int nodeNum = pow(k, n - 1);
        int nedge = pow(k, n);
        std::vector<int> vecNode(nodeNum, k - 1);
        std::string strret(nedge + (n - 1), '0');
        for (int i = n - 1, idx = 0; i < strret.length(); ++i) {
            int& curedge = vecNode[idx];
            strret[i] = curedge + '0';
            idx = (idx * k + curedge) % nodeNum;
            --curedge;
        }
        return strret;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,k;
    cin>>n>>k;
    // solve
    Solution solution;
            auto result = solution.solve(n,k);
    
    // output
    for(auto it:result) cout<<it<<' ';

    return 0;
}",graph,hard
30,"# Problem Statement
You are given an array consisting of $n$ integers $a_1$, $a_2$, ..., $a_n$. Initially $a_x = 1$, all other elements are equal to $0$.

You have to perform $m$ operations. During the $i$\-th operation, you choose two indices $c$ and $d$ such that $l_i \le c, d \le r_i$, and swap $a_c$ and $a_d$.

Calculate the number of indices $k$ such that it is possible to choose the operations so that $a_k = 1$ in the end.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &x, int &m, vector<int> &l, vector<int> &r) {
        // write your code here
    }
};
```
where:  
- return: the number of indices k such that it is possible to choose the operations so that ak=1 in the end.

# Example 1:  
- Input:  
n = 6, x = 4, m = 3
l = [1,2,5]
r = [6,3,5] 
- Output:  
6

# Constraints:  
- $1 \leq m \leq @data$
- $1 \leq x \leq n \leq 10^9$
- $1 \leq l[i] \leq r[i] \leq n$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, int &x, int &m, vector<int> &l, vector<int> &r)
    {
        int cl, cr;
        cl = x;
        cr = x;
        for (int i = 0; i < m; i++)
        {
            if (max(l[i], cl) <= min(r[i], cr))
            {
                cl = min(l[i], cl);
                cr = max(r[i], cr);
            }
        }
        return cr - cl + 1;
    }
};
","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n,x,m;
    cin >> n >> x >> m;
    vector<int> l(m),r(m);
    for (int i = 0; i < m; i++)
        cin >> l[i] >> r[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, x, m, l, r);

    // output
    cout << result << ""\n"";

    return 0;
}","math,two_pointers",hard
31,"# Problem Statement:
You work in the quality control department of technical support for a large company. Your job is to make sure all client issues have been resolved.

Today you need to check a copy of a dialog between a client and a technical support manager. According to the rules of work, each message of the client must be followed by **one or several** messages, which are the answer of a support manager. However, sometimes clients ask questions so quickly that some of the manager's answers to old questions appear after the client has asked some new questions.

Due to the privacy policy, the full text of messages is not available to you, only the order of messages is visible, as well as the type of each message: a customer question or a response from the technical support manager. **It is guaranteed that the dialog begins with the question of the client.**

You have to determine, if this dialog may correspond to the rules of work described above, or the rules are certainly breached.

The main function of the solution is defined as: 
```cpp
class Solution {
public:
    string solve(int &n, string &s) {
        // write your code here
    }
};
```
Where:  
- `n` is an integer representing the number of messages in the conversation.  
- `s` is a string where each character represents the type of a message:
  - `'Q'` for a customer query.
  - `'A'` for a manager's response.
- The return value is a string: `""YES""` if the dialog may correspond to the rules of work, and `""NO""` otherwise.

# Example 1: 
- Input:  
n = 3  
s = ""QAA""
- Output:  
YES

# Constraints:
- $1 \leq n \leq @data$ 
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(int &n, string &s)
    {
        int cur = 0;
        for (int i=n-1;i>=0;i--)
        {
            if (s[i] == 'A')
                cur++;
            else
                cur--;
            if (cur < 0)
                return ""NO"";
        }
        return ""YES"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    string s;
    cin >> s;

    // solve
    Solution solution;
    auto result = solution.solve(n, s);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,math",medium
32,"There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.
Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.
The answer is modulus 998244353.

solution main function
```cpp
class Solution {
public:
    int solve(int m,int n) {

    }
};
```

Example 1:
Input: m = 3, n = 7
Output: 28

Example 2:
Input: m = 3, n = 2
Output: 3

Constraints:
1 <= m, n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 1000000]",1000.0,"[[12800, 1280, 128]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    const long long mod=998244353;
    int power(long long x,long long y)
    {
        long long temp=1;
        while(y)
        {
            if(y&1) temp=temp*x%mod;
            x=x*x%mod; y>>=1;
        }
        return temp;
    }
    int solve(int m,int n) {
        long long ans = 1,tx=1,ty=1;
        for (int x = n, y = 1; y < m; ++x, ++y) {
            tx=tx*x%mod; ty=ty*y%mod;
        }
        return tx*power(ty,mod-2)%mod;
    }
};","#include <bits/stdc++.h>
#include <iterator>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    // solve
    Solution solution;
            auto result = solution.solve(n,m);
    
    // output
    cout<<result;
    return 0;
}",math,medium
33,"# Problem Statement
You are given a list of $n$ integers. You can perform the following operation: you choose an element $x$ from the list, erase $x$ from the list, and subtract the value of $x$ from all the remaining elements. Thus, in one operation, the length of the list is decreased by exactly $1$.

Given an integer $k$ ($k&gt;0$), find if there is some sequence of $n-1$ operations such that, after applying the operations, the only remaining element of the list is equal to $k$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, int &k, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return ""YES"" if there is a sequence of operations that results in the only remaining element of the list being equal to $k$, otherwise return ""NO"".

# Example 1:  
- Input:  
n = 4, k = 5
a = [4, 2, 2, 7]
- Output: 
YES

# Constraints:  
- $2 \leq n \leq @data$
- $1 \leq k \leq 10^9$
- $-10^9 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(int &n, int &k, vector<int> &a)
    {
        sort(a.begin(), a.end());
        bool ok = false;
        for (int i = 0; i < n; i++)
        {
            int x = a[i] + k;
            auto it = lower_bound(a.begin(), a.end(), x);
            if (it != a.end() && (*it) == x)
            {
                ok = true;
                break;
            }
        }
        return (ok ? ""YES"" : ""NO"");
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, k;
    cin >> n >> k;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, k, a);

    // output
    cout << result << ""\n"";

    return 0;
}","data_structures,greedy,math,two_pointers",hard
34,"# Problem Statement
You have an array of **zeros** $a_1, a_2, \ldots, a_n$ of length $n$.

You can perform two types of operations on it:

1.  Choose an index $i$ such that $1 \le i \le n$ and $a_i = 0$, and assign $1$ to $a_i$;
2.  Choose a pair of indices $l$ and $r$ such that $1 \le l \le r \le n$, $a_l = 1$, $a_r = 1$, $a_l + \ldots + a_r \ge \lceil\frac{r - l + 1}{2}\rceil$, and assign $1$ to $a_i$ for all $l \le i \le r$.

What is the minimum number of operations of the **first type** needed to make all elements of the array equal to one?

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n) {
        // write your code here
    }
};
```
where:  
- return:the minimum number of needed operations of first type.

# Example 1:  
- Input:  
n = 1
- Output:  
1

# Constraints:  
- $1 \leq n \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n)
    {
        int ans = 1;
        int k = 1;
        while (k < n)
        {
            k = (k + 1) * 2;
            ans++;
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;

    // solve
    Solution solution;
    auto result = solution.solve(n);

    // output
    cout << result << ""\n"";

    return 0;
}","constructive_algorithms,math",easy
35,"# Problem Statement
Jonathan is fighting against DIO's Vampire minions. There are $n$ of them with strengths $a_1, a_2, \dots, a_n$. 

Denote $(l, r)$ as the group consisting of the vampires with indices from $l$ to $r$. Jonathan realizes that the strength of any such group is in its weakest link, that is, the bitwise AND. More formally, the strength level of the group $(l, r)$ is defined as

$$
f(l,r) = a_l \and a_{l+1} \and a_{l+2} \and \ldots \and a_r.
$$
 Here, $\and$ denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND).

Because Jonathan would like to defeat the vampire minions fast, he will divide the vampires into contiguous groups, such that each vampire is in **exactly** one group, and the **sum** of strengths of the groups is **minimized**. Among all ways to divide the vampires, he would like to find the way with the **maximum** number of groups.

Given the strengths of each of the $n$ vampires, find the **maximum number** of groups among all possible ways to divide the vampires with the smallest sum of strengths.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the maximum number of groups among all possible ways to divide the vampires with the smallest sum of strengths.

# Example 1:  
- Input:  
n = 3
a = [1, 2, 3]
- Output:  
1

# Constraints:  
- $1 \leq n \leq @data$
- $0 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        int all = ~0;
        for (int i = 0; i < n; i++)
            all &= a[i];
        if (all != 0)
        {
            return 1;
        }
        int ans = 0;
        int res = ~0;
        for (int i = 0; i < n; i++)
        {
            res &= a[i];
            if (res == 0)
            {
                ans++;
                res = ~0;
            }
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","bit_manipulation,two_pointers,greedy",hard
36,"Given a list of 24-hour clock points in the format ""HH:MM"", return the minimum minute difference between any two points in the list.

solution main function

```cpp
class Solution {
public:
    int solve(vector<string>& timePoints) {
        
    }
};
```

Example 1:
Input: timePoints = [""23:59"",""00:00""]
Output: 1

Example 2:
Input: timePoints = [""00:00"",""23:59"",""00:00""]
Output: 0

Constraints:

2 <= timePoints.length <= @data
timePoints[i] is in the format ""HH:MM""

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[20, 100, 100000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<string>& timePoints) {
        // create buckets array for the times converted to minutes
        vector<bool> minutes(24 * 60, false);
        for (string time : timePoints) {
            int h = stoi(time.substr(0, 2));
            int m = stoi(time.substr(3));
            int min = h * 60 + m;
            if (minutes[min]) return 0;
            minutes[min] = true;
        }
        int prevIndex = INT_MAX;
        int firstIndex = INT_MAX;
        int lastIndex = INT_MAX;
        int ans = INT_MAX;

        // find differences between adjacent elements in sorted array
        for (int i = 0; i < 24 * 60; i++) {
            if (minutes[i]) {
                if (prevIndex != INT_MAX) {
                    ans = min(ans, i - prevIndex);
                }
                prevIndex = i;
                if (firstIndex == INT_MAX) {
                    firstIndex = i;
                }
                lastIndex = i;
            }
        }

        return min(ans, 24 * 60 - lastIndex + firstIndex);
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector< string > a;
    for(int i=1;i<=n;i++)
    {
        string x; cin>>x;
        a.push_back(x);
    }
    // solve
    Solution solution;
    int result = solution.solve(a);
    
    // output
    cout << result << ""\n"";

    return 0;
}","math,sort,string",easy
37,"# Problem Statement
Freya the Frog is traveling on the 2D coordinate plane. She is currently at point $(0,0)$ and wants to go to point $(x,y)$. In one move, she chooses an integer $d$ such that $0 \leq d \leq k$ and jumps $d$ spots forward in the direction she is facing.

Initially, she is facing the positive $x$ direction. After every move, she will alternate between facing the positive $x$ direction and the positive $y$ direction (i.e., she will face the positive $y$ direction on her second move, the positive $x$ direction on her third move, and so on).

What is the minimum amount of moves she must perform to land on point $(x,y)$?

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &x, int &y, int &k) {
        // write your code here
    }
};
```
where:  
- return: the number of jumps Freya needs to make on a new line.

# Example 1:  
- Input:  
x = 9, y = 11, k = 3
- Output:  
8

# Constraints:  
- $0 \leq x, y \leq @data$
- $1 \leq k \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &x, int &y, int &k)
    {
        x = (x + k - 1) / k;
        y = (y + k - 1) / k;

        return max(2 * x - 1, 2 * y);
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int x, y, k;
    cin >> x >> y >> k;

    // solve
    Solution solution;
    auto result = solution.solve(x, y, k);

    // output
    cout << result << ""\n"";

    return 0;
}",math,medium
38,"# Problem Statement:
You find yourself on an unusual crossroad with a weird traffic light. That traffic light has three possible colors: red (r), yellow (y), green (g). It is known that the traffic light repeats its colors every $n$ seconds and at the $i$\-th second the color $s_i$ is on.

That way, the order of the colors is described by a string. For example, if $s=$""rggry"", then the traffic light works as the following: red-green-green-red-yellow-red-green-green-red-yellow- ... and so on.

More formally, you are given a string $s_1, s_2, \ldots, s_n$ of length $n$. At the first second the color $s_1$ is on, at the second  $s_2$, ..., at the $n$\-th second the color $s_n$ is on, at the $n + 1$\-st second the color $s_1$ is on and so on.

You need to cross the road and that can only be done when the green color is on.

You know which color is on the traffic light at the moment, but you don't know the current moment of time. You need to find the minimum amount of time in which you are guaranteed to cross the road.

You can assume that you cross the road immediately.

For example, with $s=$""rggry"" and the current color r there are two options: either the green color will be on after $1$ second, or after $3$. That way, the answer is equal to $3$  that is the number of seconds that we are guaranteed to cross the road, if the current color is r.

The main function of the solution is defined as: 
```cpp
class Solution {
public:
    int solve(int &n, char &c, string &s) {   
        // write your code here
    }
};
```
Where:  
- `n` is an integer representing the length of the string \(s\).  
- `c` is a character representing the current color of the traffic light.  
- `s` is a string representing the sequence of colors in the traffic light.  
- The function should return an integer: the minimum guaranteed time in seconds after which you can cross the road.

# Example 1:
- Input:  
n = 5  
c = 'r'  
s = ""rggry""
- Output:  
3

# Constraints:
- $1 \leq n \leq @data$  
- $c, s_i \in \{r, g, y\}$
- Guaranteed solution exists
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, char &c, string &s)
    {
        int ans = 0, x = 0;
        for (int t = 0; t < 2; t++)
        {
            for (int i = n - 1; i >= 0; i--)
            {
                if (s[i] == 'g')
                    x = 0;
                else
                    x++;
                if (s[i] == c && t)
                    ans = max(ans, x);
            }
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    char c;
    cin >> c;
    string s;
    cin >> s;

    // solve
    Solution solution;
    auto result = solution.solve(n, c, s);

    // output
    cout << result << ""\n"";

    return 0;
}","two_pointers,binary",medium
39,"You are given two 0-indexed integer arrays, cost and time, of size n representing the costs and the time taken to paint n different walls respectively. There are two painters available:

    A paid painter that paints the ith wall in time[i] units of time and takes cost[i] units of money.
    A free painter that paints any wall in 1 unit of time at a cost of 0. But the free painter can only be used if the paid painter is already occupied.

Return the minimum amount of money required to paint the n walls.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& cost, vector<int>& time) {
        
    }
};
```

Example 1:
Input: cost = [1,2,3,2], time = [1,2,3,2]
Output: 3

Example 2:
Input: cost = [2,3,4,2], time = [1,1,1,1]
Output: 4

Constraints:


1 <= cost.length <= @data
cost.length == time.length
1 <= cost[i] <= 10^6
1 <= time[i] <= 500


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[50, 100, 1000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& cost, vector<int>& time) {
        // what i get it right: the sum of time i pick shoud larger than the remaining time entries  --> define gain = sum of time - remaining time entries  --> combine them into one variable
        // problem: we don't need binary search + dp. Dp already keep track of all possible cost. we only need to choose the minimum cost so that gain exceeds some level.
        // problem: dp[i] --> maximum number of wall we finish with money i or minimum cost to finish i walls? This affects our speed.
        // problem: here the range of cost is sum(cost), the range of gain is the number of walls (cost.size)  --> we loop # walls ; Also, since it asks for minimum cost to pain n walls. So dp[i] should represent the minimum cost
        
        int maxCost = accumulate(cost.begin(), cost.end(), 0);
        vector<int> dp(cost.size()+1, maxCost);  // dp[j]: up to item i, the minimum cost to finish j walls
        dp[0] = 0;

        for (int end=0; end<cost.size(); ++end)
        {
            for (int wall=cost.size(); wall>0; wall--)
            {
                // currently: dp[j]: the minimum cost to finish j walls considering only the first i-1 items
                dp[wall] = min(dp[wall], dp[max(wall-time[end]-1, 0)] + cost[end]);

            }
        }

        return dp[cost.size()];
    }


};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> a,b;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        a.push_back(x);
    }
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        b.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(a,b);
    
    // output
    cout << result << ""\n"";

    return 0;
}",dp,hard
40,"# Problem Statement
Doremy's new city is under construction! The city can be regarded as a simple undirected graph with $n$ vertices. The $i$\-th vertex has altitude $a_i$. Now Doremy is deciding which pairs of vertices should be connected with edges.

Due to economic reasons, there should be no self-loops or multiple edges in the graph.

Due to safety reasons, there should not be **pairwise distinct** vertices $u$, $v$, and $w$ such that $a_u \leq a_v \leq a_w$ and the edges $(u,v)$ and $(v,w)$ exist.

Under these constraints, Doremy would like to know the maximum possible number of edges in the graph. Can you help her?

Note that the constructed graph is allowed to be disconnected.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return the maximum possible number of edges in the graph.

# Example 1:  
- Input:  
n = 4
a = [2,2,3,1]
- Output:  
3

# Constraints:  
- $2 \leq n \leq @data$
- $1 \leq a[i] \leq 10^6$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(int &n, vector<int> &a)
    {
        sort(a.begin(), a.end());
        long long ans = n / 2;
        for (int i = 0; i < n; i++)
        {
            if(i == n - 1 || a[i] != a[i + 1])
            ans = max(ans, (long long) (i + 1) * (n - i - 1));

        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",graph,hard
41,"In an infinite binary tree where every node has two children, the nodes are labelled in row order.

In the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.

solution main function
```cpp
class Solution {
public:
    vector<int> solve(int label) {
        
    }
};
```

Example 1:
Input: label = 14
Output: [1,3,4,14]

Example 2:
Input: label = 26
Output: [1,2,6,10,26]

Constraints:

1 <= label <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 10000, 1000000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> solve(int label) {
        vector<int>ans;
        ans.push_back(label);
        int level = log2(label);

        if(label==1)  return ans;

        while(level>0) {
            int parent = label/2;
            int start = pow(2,level-1);
            int end = 2*start-1;
            int complement = start+end-parent;
            ans.push_back(complement);
            label = complement;
            level--;
        }
        reverse(ans.begin(),ans.end());
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
    auto result = solution.solve(n);
    
    // output
    for(auto it:result) cout<<it<<' ';
    // cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","graph,other",medium
42,"# Problem Statement
On the board Ivy wrote down all integers from $l$ to $r$, inclusive.

In an operation, she does the following:

-   pick two numbers $x$ and $y$ on the board, erase them, and in their place write the numbers $3x$ and $\lfloor \frac{y}{3} \rfloor$. (Here $\lfloor \bullet \rfloor$ denotes rounding down to the nearest integer).

What is the minimum number of operations Ivy needs to make all numbers on the board equal $0$? We have a proof that this is always possible.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &l, int &r) {
        // write your code here
    }
};
```
where: the minimum number of operations needed to make all numbers on the board equal 0.
- return: 

# Example 1:  
- Input:  
l = 1, r = 3
- Output:  
5

# Constraints:  
- $1 \leq l \leq r \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10000, 1000000, 100000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &l, int &r)
    {
        int ans = 0;
        int mn = -1;
        for (int x = 1, t = 1; x <= r; x *= 3, t++)
        {
            if (l >= x)
                mn = t;
            ans += max(0, min(r, 3 * x - 1) - max(l, x) + 1) * t;
        }
        ans += mn;
        return ans;
    }
};
","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int l, r;
    cin >> l >> r;

    // solve
    Solution solution;
    auto result = solution.solve(l, r);

    // output
    cout << result << ""\n"";

    return 0;
}","sort,two_pointers",hard
43,"You are given an integer array arr of length n that represents a permutation of the integers in the range [0, n - 1].

We split arr into some number of chunks (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.

Return the largest number of chunks we can make to sort the array.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& arr) {
        
    }
};
```

Example 1:
Input: arr = [4,3,2,1,0]
Output: 1

Example 2:
Input: arr = [1,0,2,3,4]
Output: 4

Constraints:

n == arr.length
1 <= n <= @data
0 <= arr[i] < n
All the elements of arr are unique.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& arr) {
        int n = arr.size();
        int chunks = 0, maxElement = 0;

        // Iterate over the array
        for (int i = 0; i < n; i++) {
            // Update maxElement
            maxElement = max(maxElement, arr[i]);

            if (maxElement == i) {
                // All values in range [0, i] belong to the prefix arr[0:i];
                // a new chunk can be formed
                chunks++;
            }
        }

        return chunks;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    vector<int > num;
    cin>>n;
    for(int i=1,x;i<=n;i++)
    {
        cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num);
    
    // output
    cout<<result;
    return 0;
}","sort,greedy",medium
44,"There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges that connect the center node with every other node.

You are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph.
solution main function
```cpp
class Solution
{
    public:
    int solve(vector<vector<int>>& edges)
}
```

Example 1:
Input: edges = [[1,2],[2,3],[4,2]]
Output: 2

Constraints:

2 <= n <= @data
edges.length == n - 1
edges[i].length == 2
1 <= ui, vi <= n
ui ! = vi
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<vector<int>>& edges) {
        return edges[0][0] == edges[1][0] || edges[0][0] == edges[1][1] ? edges[0][0] : edges[0][1];
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<vector<int> > edge;
    for(int i=1;i<n;i++)
    {
        int x,y;cin>>x>>y;
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        edge.push_back(temp);
    }
    // solve
    Solution solution;
            auto result = solution.solve(edge);
    
    // output
    cout << result << ""\n"";

    return 0;
}",graph,easy
45,"You are given a 0-indexed integer array nums, where nums[i] is a digit between 0 and 9 (inclusive).

The triangular sum of nums is the value of the only element present in nums after the following process terminates:

    Let nums comprise of n elements. If n == 1, end the process. Otherwise, create a new 0-indexed integer array newNums of length n - 1.
    For each index i, where 0 <= i < n - 1, assign the value of newNums[i] as (nums[i] + nums[i+1]) % 10, where % denotes modulo operator.
    Replace the array nums with newNums.
    Repeat the entire process starting from step 1.

Return the triangular sum of nums.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [1,2,3,4,5]
Output: 8

Example 2:
Input: nums = [5]
Output: 5

Constraints:

1 <= nums.length <= @data
0 <= nums[i] <= 9

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums) {
        int result = 0;
        int m = nums.size() - 1;
        int mck = 1, exp2 = 0, exp5 = 0;
        int inv[] = {0, 1, 0, 7, 0, 0, 0, 3, 0, 9};
        int pow2mod10[] = {6, 2, 4, 8};        
        for (int k = 0; true; k++) {
            if (!exp2 || !exp5) {
                int mCk_ = exp2 ? mck * pow2mod10[exp2 % 4] :
                        exp5 ? mck * 5 : mck;
                result = (result + mCk_ * nums[k]) % 10;
            }
            if (k == m)
                return result;

            // mCk *= m - k
            int mul = m - k;
            while (mul % 2 == 0) {
                mul /= 2;
                exp2++;
            }
            while (mul % 5 == 0) {
                mul /= 5;
                exp5++;
            }
            mck = mck * mul % 10;

            // mCk /= k + 1
            int div = k + 1;
            while (div % 2 == 0) {
                div /= 2;
                exp2--;
            }
            while (div % 5 == 0) {
                div /= 5;
                exp5--;
            }
            mck = mck * inv[div % 10] % 10;
        }
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","math,other",medium
46,"You are given a string s consisting of the characters 'a', 'b', and 'c' and a non-negative integer k. Each minute, you may take either the leftmost character of s, or the rightmost character of s.

Return the minimum number of minutes needed for you to take at least k of each character, or return -1 if it is not possible to take k of each character.

solution main function

```cpp
class Solution {
public:
    int solve(string s, int k) {
        
    }
};
```

Example 1:
Input: s = ""aabaaaacaabc"", k = 2
Output: 8

Example 2:
Input: s = ""a"", k = 1
Output: -1

Constraints:

1 <= s.length <= @data
s consists of only the letters 'a', 'b', and 'c'.
0 <= k <= s.length

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    static int solve(string& s, int k) {
        const int n=s.size();
        int freq[3]={0};
        for(char c: s)
            freq[c-'a']++;
        if (any_of(freq, freq+3, [k](int f){ return f<k;}))
            return -1;
    //    print(freq);
        int ans=n;
        for(int l=0, r=0; r<n; r++){
            int x=s[r]-'a';
            freq[x]--;
            while (l<=r && any_of(freq, freq+3, [k](int f){ return f<k;})){
                freq[s[l]-'a']++;
                l++;
            }
            ans=min(ans, n-(r-l+1));
        }
        return ans;
    }
};



auto init = []() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    return 'c';
}();","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int k; string s;
    cin>>s>>k;
    // solve
    Solution solution;
    auto result = solution.solve(s,k);
    
    // output
    cout << result << ""\n"";

    return 0;
}",string,hard
47,"You have an undirected, connected graph of n nodes labeled from 0 to n - 1. You are given an array graph where graph[i] is a list of all the nodes connected with node i by an edge.

Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.

solution main function
```cpp
class Solution {
public:
    vector<int> solve(int n, vector<vector<int>>& edges) {
        
    }
};
```

Example 1:
Input: graph = [[1,2,3],[0],[0],[0]]
Output: 4

Example 2:
Input: graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]
Output: 4

Constraints:


n == graph.length
1 <= n <= @data
0 <= graph[i].length < n
graph[i] does not contain i.
If graph[a] contains b, then graph[b] contains a.
The input graph is always connected.


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[4, 8, 12]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int dp[13][5000]; 
    
    int solve(std::vector<std::vector<int>>& graph) {
        int n = graph.size();
        memset(dp, -1, sizeof(dp));
        queue<pair<int, int>> q;
        for (int i = 0; i < n; ++i) {
            q.push({i, (1 << i)});
            dp[i][(1 << i)] = 0; 
        }

        while (!q.empty()) {
            auto [node, visited] = q.front();
            q.pop();
            for (int neigh : graph[node]) {
                int new_visited = visited | (1 << neigh);
                if (dp[neigh][new_visited] == -1) {
                    dp[neigh][new_visited] = dp[node][visited] + 1;
                    q.push({neigh, new_visited});
                }
            }
        }

       
        int all_visited = (1 << n) - 1;
        int ans = INT_MAX;
        for (int i = 0; i < n; ++i) {
            if (dp[i][all_visited] != -1) {
                ans = std::min(ans, dp[i][all_visited]);
            }
        }

        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    cin>>n;
    vector<vector<int>> e(n);
    for(int i=1;i<n;i++)
    {
        int x,y; cin>>x>>y;
        e[x].push_back(y);
        e[y].push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(e);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    printf(""%d"",result);
    return 0;
}","graph,dynamic_programming,search,other",hard
48,"You are given an integer n. There is an undirected graph with n vertices, numbered from 0 to n - 1. You are given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting vertices ai and bi.
Return the number of complete connected components of the graph.
A connected component is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.
A connected component is said to be complete if there exists an edge between every pair of its vertices.

solution main function
```cpp
class Solution
{
    public:
    int solve(int n, vector<vector<int>>& edges)
}
```

Example 1:
Inputn = 6, edges = [[0,1],[0,2],[1,2],[3,4]]
Output: 3

Example 2:
Inputn = 6, edges = [[0,1],[0,2],[1,2],[3,4],[3,5]]
Output: 1

Constraints:
1 <= n <= @data
0 <= edges.length <= 3*n
edges[i].length == 2
0 <= ai, bi <= n - 1
ai != bi
There are no repeated edges.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 100, 10000]",1000.0,"[[6400, 640, 120]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int find(vector<int>& G, int n)
    {
        while (G[n] >= 0){
            n = G[n];
        }
        return n;
    }

    int solve(int n, vector<vector<int>>& edges) {
        vector<int> G(n,-1);
        vector<int> edge(n,0);
        int cnt = 0;
        for (int i=0; i<edges.size(); i++){
            int r1 = find(G,edges[i][0]);
            int r2 = find(G,edges[i][1]);
            int t1 = fmin(r1,r2), t2 = fmax(r1,r2);
            r1 = t1;
            r2 = t2;
            if (r1 != r2){
                G[r1] += G[r2];
                G[r2] = r1;
                edge[r1] += edge[r2];
            }
            edge[r1]++;
        }
        for (int i=0; i<n; i++){
            if (G[i] < 0 && G[i] < 0 && edge[i] == (-G[i]-1)*(-G[i])/2){
                cnt++;
            }
        }
        return cnt;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m;
    cin>>n>>m;
    vector<vector<int> > g;
    for(int i=1;i<=m;i++)
    {
        vector<int> temp;
        int x,y; cin>>x>>y;
        temp.push_back(x);
        temp.push_back(y);
        g.push_back(temp);
    }
    // solve
    Solution solution;
            auto result = solution.solve(n,g);
    
    // output
    cout<<result;
    return 0;
}","graph,search,data_structures",medium
49,"There is an undirected graph of n nodes. You are given a 2D array edges, where edges[i] = [ui, vi, lengthi] describes an edge between node ui and node vi with a traversal time of lengthi units.

Additionally, you are given an array disappear, where disappear[i] denotes the time when the node i disappears from the graph and you won't be able to visit it.

Note that the graph might be disconnected and might contain multiple edges.

Return the array answer, with answer[i] denoting the minimum units of time required to reach node i from node 0. If node i is unreachable from node 0 then answer[i] is -1.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& vals, vector<vector<int>>& edges, int k) {
        
    }
};
```

Example 1:
Input: n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,1,5]
Output: [0,-1,4]

Example 2:
Input: n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,3,5]
Output: [0,2,3]

Constraints:

1 <= n <= @data
0 <= edges.length <= 10^5
edges[i] == [ui, vi, lengthi]
0 <= ui, vi <= n - 1
1 <= lengthi <= 10^5
disappear.length == n
1 <= disappear[i] <= 10^5

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> solve(int n, vector<vector<int>>& v, vector<int>& d) {
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;
        vector<pair<int,int>>adj[n];
        for(int i=0;i<v.size();i++) {
            int a=v[i][0],b=v[i][1],t=v[i][2];
            if(a==b)
                continue;
            adj[a].push_back({b,t});
            adj[b].push_back({a,t});
        }
        q.push({0,0});
        vector<int>dist(n,INT_MAX);
        vector<bool>vis(n,0);
        dist[0]=0;
        while(!q.empty()) {
            pair<int,int>p=q.top();
            q.pop();
            int t=p.first,s=p.second;
            if(vis[s]==1)
                continue;
            if(t>=d[s])
                continue;
            vis[s]=1;
            for(auto i:adj[s]) {
                if(t+i.second<dist[i.first] && t+i.second<=d[i.first]) {
                    dist[i.first]=t+i.second;
                    q.push({t+i.second,i.first});
                }
            }
        }
        vector<int>ans;
        for(int i=0;i<n;i++) {
            if(dist[i]<d[i]) 
                ans.push_back(dist[i]);
            else
                ans.push_back(-1);
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m,k; cin>>n>>m;
    vector<vector<int> > edge;
    vector< int > val;
    for(int i=1,x,y,z;i<=m;i++)
    {
        scanf(""%d"",&x);
        scanf(""%d"",&y);
        scanf(""%d"",&z);
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        temp.push_back(z);
        edge.push_back(temp);
    }
    for(int i=1,x;i<=n;i++)
    {
        scanf(""%d"",&x);
        val.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(n,edge,val);
    
    // output
    for(auto it:result) cout<<it<<' ';
    // printf(""%d"",result);
    return 0;
}","graph,search",medium
50,"# Problem Statement
An array $b$ of length $m$ is good if for all $i$ the $i$\-th element is greater than or equal to $i$. In other words, $b$ is good if and only if $b_i \geq i$ for all $i$ ($1 \leq i \leq m$).

You are given an array $a$ consisting of $n$ positive integers. Find the number of pairs of indices $(l, r)$, where $1 \le l \le r \le n$, such that the array $[a_l, a_{l+1}, \ldots, a_r]$ is good.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return:  the number of suitable pairs of indices, please use `long long` type.

# Example 1:  
- Input:  
n = 3
a = [1, 2, 3]
- Output:  
6

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq n$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(int &n, vector<int> &a)
    {
        long long result = 0;
        int l = 0;
        for (int r = 0; r < n; ++r)
        {
            while (l <= r && a[r] < (r - l + 1))
                l++;
            result += (r - l + 1);
        }

        return result;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","two_pointers,binary",medium
51,"The beauty of a string is the difference in frequencies between the most frequent and least frequent characters.

    For example, the beauty of ""abaacc"" is 3 - 1 = 2.

Given a string s, return the sum of beauty of all of its substrings.


solution main function
```cpp
class Solution {
public:
    int solve(string s) {
        
    }
};
```

Example 1:
Input: s = ""aabcb""
Output: 5

Example 2:
Input: s = ""aabcbaa""
Output: 17


Constraints:

1 <= s.length <= @data
s consists of only lowercase English letters.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[50, 100, 500]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    pair<int,int>calMinAndMax(int freq[]){
        int minCnt=INT_MAX;
        int maxCnt=0;
        for(int i=0;i<26;++i){
            if(freq[i]!=0){
                minCnt=min(minCnt,freq[i]);
                maxCnt=max(maxCnt,freq[i]);
            }

        }
        return {maxCnt,minCnt};
    }
    int solve(string s) {
        int sum=0;
        for(int i=0;i<s.length();++i){
            int freq[26]={0};
            for(int j=i;j<s.length();++j){
                freq[s[j]-'a']++;
                pair<int,int>cnt=calMinAndMax(freq);
                int maxCnt=cnt.first;
                int minCnt=cnt.second;
                sum+=(maxCnt-minCnt);

            }
        }
        return sum;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string s; cin>>s;
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",other,medium
52,"# Problem Statement
Given an array $a$ of $n$ positive integers.

In one operation, you can pick any pair of indexes $(i, j)$ such that $a_i$ and $a_j$ have **distinct** parity, then replace the smaller one with the sum of them. More formally:

-   If $a_i &lt; a_j$, replace $a_i$ with $a_i + a_j$;
-   Otherwise, replace $a_j$ with $a_i + a_j$.

Find the minimum number of operations needed to make all elements of the array have the same parity.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the minimum number of operations required.

# Example 1:  
- Input:  
n = 5
a = [1, 3, 5, 7, 9]
- Output:  
0

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
	int solve(int &n, vector<int> &a)
	{
		int ans = 0, flag = 0;
		long long mx = -1;
		for (int i = 0; i < n; i++)
		{
			if (a[i] % 2 == 1)
				flag = 1;
		}
		if (!flag)
		{
			return 0;
		}
		for (int i = 0; i < n; i++)
		{
			if (a[i] % 2 == 0)
				ans++;
			if (a[i] % 2 == 1)
				mx = max(mx, 1ll * a[i]);
		}
		sort(a.begin(), a.end());
		for (int i = 0; i < n; i++)
		{
			if (a[i] % 2 == 1)
				continue;
			if (a[i] > mx)
			{
				ans++;
				break;
			}
			mx += a[i];
		}
		return ans;
	}
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",constructive_algorithms,medium
53,"# Problem Statement
There are $n$ cows participating in a coding tournament. Cow $i$ has a Cowdeforces rating of $a_i$ (all distinct), and is initially in position $i$. The tournament consists of $n-1$ matches as follows:

-   The first match is between the cow in position $1$ and the cow in position $2$.
-   Subsequently, each match $i$ is between the cow in position $i+1$ and the winner of match $i-1$.
-   In each match, the cow with the higher Cowdeforces rating wins and proceeds to the next match.

You are the owner of cow $k$. For you, winning the tournament is not important; rather, you want your cow to win in as many matches as possible. As an acquaintance of the tournament organizers, you can ask them to swap the position of your cow with another cow **only once**, or you can choose to do nothing.

Find the maximum number of wins your cow can achieve.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &k, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the maximum number of wins cow k can achieve if you choose to swap (or do nothing) optimally.

# Example 1:  
- Input:  
n = 6, k = 1
a = [12, 10, 14, 11, 8, 3]
- Output:  
1

# Constraints:  
- $2 \leq n \leq @data$
- $1 \leq k \leq n$
- $1 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, int &k, vector<int> &a)
    {
        int pos1 = -1, pos2 = -1;
        for (int i = 0; i < n; i++)
        {
            if (a[i] > a[k - 1])
            {
                if (pos1 == -1)
                    pos1 = i + 1;
                else
                {
                    pos2 = i + 1;
                    break;
                }
            }
        }
        int ans = 0;
        if (pos1 == -1)
            ans = n - 1;
        else if (pos2 == -1)
        {
            if (pos1 < k)
            {
                int tem = k - pos1;
                if (pos1 == 1)
                    tem--;
                ans = max({pos1 - 2, tem, 0});
            }
            else
            {
                ans = max(0, pos1 - 2);
            }
        }
        else
        {
            if (pos1 < k)
            {
                if (pos2 > k)
                {
                    int tem = k - pos1;
                    if (pos1 == 1)
                        tem--;
                    ans = max({pos1 - 2, tem, 0});
                }
                else if (k > pos2)
                {
                    int tem = pos2 - pos1;
                    if (pos1 == 1)
                        tem--;
                    ans = max({pos1 - 2, tem, 0});
                }
            }
            else if (k < pos1)
            {
                ans = max(0, pos1 - 2);
            }
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, k;
    cin >> n >> k;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, k, a);

    // output
    cout << result << ""\n"";

    return 0;
}",greedy,hard
54,"You are given a 0-indexed array of positive integers nums. Find the number of triplets (i, j, k) that meet the following conditions:

    0 <= i < j < k < nums.length
    nums[i], nums[j], and nums[k] are pairwise distinct.
        In other words, nums[i] != nums[j], nums[i] != nums[k], and nums[j] != nums[k].

Return the number of triplets that meet the conditions.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [4,4,2,4,3]
Output: 3

Example 2:
Input: nums = [1,1,1,1,1]
Output: 0

Constraints:

3 <= nums.length <= @data
1 <= nums[i] <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums) {
        unordered_map<int, int> freq;
        for (int i : nums){
            freq[i]++;
        }
        int left = 0;
        int right = nums.size();
        int res = 0;
        for (auto i : freq){
            int value = i.second;
            int mid = value;
            right -= value;
            res += left * value * right;
            left += value;
        }
        return res;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","sort,other",easy
55,"You are given a positive integer array nums.

Partition nums into two arrays, nums1 and nums2, such that:

    Each element of the array nums belongs to either the array nums1 or the array nums2.
    Both arrays are non-empty.
    The value of the partition is minimized.

The value of the partition is |max(nums1) - min(nums2)|.

Here, max(nums1) denotes the maximum element of the array nums1, and min(nums2) denotes the minimum element of the array nums2.

Return the integer denoting the value of such partition.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [1,3,2,4]
Output: 1

Example 2:
Input: nums = [100,1,10]
Output: 9

Constraints:

2 <= nums.length <= @data
1 <= nums[i] <= 10^9

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums) {
        int ans = 1e9;
        sort(nums.begin(), nums.end());
        for(int i = 1; i < nums.size(); i++){
            ans = min(ans, nums[i] - nums[i - 1]);
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","sort,other",medium
56,"You are given an integer array target. You have an integer array initial of the same size as target with all elements initially zeros.

In one operation you can choose any subarray from initial and increment each value by one.

Return the minimum number of operations to form a target array from initial.

The test cases are generated so that the answer fits in a 32-bit integer.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& target) {
        
    }
};
```

Example 1:
Input: target = [1,2,3,2,1]
Output: 3

Example 2:
Input: target = [3,1,1,2]
Output: 4

Constraints:

1 <= target.length <= @data
1 <= target[i] <= 10^5

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& target) {
        int noOfOperations = target[0];
        for(int i = 1; i < target. size(); i++) {
            if(target[i] > target[i-1]) 
                noOfOperations += (target[i]-target[i-1]);
        }
        return noOfOperations;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","dynamic_programming,greedy,other",hard
57,"There are numBottles water bottles that are initially full of water. You can exchange numExchange empty water bottles from the market with one full water bottle.

The operation of drinking a full water bottle turns it into an empty bottle.

Given the two integers numBottles and numExchange, return the maximum number of water bottles you can drink.

solution main function

```cpp
class Solution {
public:
    int solve(int numBottles, int numExchange) {
        
    }
};
```

Example 1:
Input: numBottles = 9, numExchange = 3
Output: 13

Example 2:
Input: numBottles = 15, numExchange = 4
Output: 19

Constraints:

1 <= numBottles <= @data
2 <= numExchange <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(int numBottles, int numExchange) {
        int consumedBottles = 0;

        while (numBottles >= numExchange) {
            // Maximum number of times we can consume numExchange
            // number of bottles using numBottles.
            int K = numBottles / numExchange;

            consumedBottles += numExchange * K;
            numBottles -= numExchange * K;

            numBottles += K;
        }

        return consumedBottles + numBottles;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    // solve
    Solution solution;
    auto result = solution.solve(n,m);
    // output
    cout << result << ""\n"";
    // for(auto it:result) cout<<it<<' ';
    return 0;
}",math,easy
58,"Given an integer num, return a string of its base 7 representation.

solution main function
```cpp
class Solution {
public:
    string solve(int num) {
        
    }
};
```

Example 1:
Input: num = 100
Output: ""202""

Example 2:
Input: num = -7
Output: ""-10""

Constraints:

-@data <= num <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 10000000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
string str;
char sign; 
    string solve(int num) {
        if(num < 0) {num *= -1; sign='n';}
        if(num == 0){ return to_string(0);}
        while(num > 0)
        {
        str.push_back(  '0' + (num%7) );
        num = num/7; 
        }
        if(sign=='n') str.push_back('-');
        std::reverse(str.begin(), str.end());
        return str ;  
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    // solve
    Solution solution;
    auto result = solution.solve(n);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",math,easy
59,"You are given a positive integer array nums.

    The element sum is the sum of all the elements in nums.
    The digit sum is the sum of all the digits (not necessarily distinct) that appear in nums.

Return the absolute difference between the element sum and digit sum of nums.

Note that the absolute difference between two integers x and y is defined as |x - y|.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [1,15,6,3]
Output: 9

Example 2:
Input: nums = [1,2,3,4]
Output: 0

Constraints:

1 <= nums.length <= @data
1 <= nums[i] <= 2000

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums) {
        int elementSum = 0;
        int digitSum = 0;
        for(int i=0;i<nums.size();i++){

            elementSum += nums[i];

            int n=nums[i];
            while(n>0){
                int lastDigit = n%10;
                digitSum += lastDigit;
                n=n/10;
            }
        }
     int  absoluteDifference = abs (elementSum - digitSum);    
     return absoluteDifference;   
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","sort,greedy",easy
60,"# Problem Statement
Anya lives in the Flower City. By order of the city mayor, she has to build a fence for herself.

The fence consists of $n$ planks, each with a height of $a_i$ meters. According to the order, the heights of the planks must **not increase**. In other words, it is true that $a_i \ge a_j$ for all $i &lt; j$.

Anya became curious whether her fence is symmetrical with respect to the diagonal. In other words, will she get the same fence if she lays all the planks horizontally in the same order.

Help Anya and determine whether her fence is symmetrical.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- output ""YES"" if the fence is symmetrical, otherwise output ""NO"".

# Example 1:  
- Input:  
n = 5
a = [5, 4, 3, 2, 1]
- Output:  
YES

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq 10^9$
- $a$ is non-increasing
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(int &n, vector<int> &a)
    {
        for (int i = 0, j = n; i < n; i++)
        {
            while (j > 0 && a[j - 1] <= i)
            {
                j--;
            }
            if (a[i] != j)
            {
                return ""NO"";
            }
        }
        return ""YES"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",sort,medium
61,"Given a binary string s, return the number of non-empty substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.

Substrings that occur multiple times are counted the number of times they occur.

solution main function

```cpp
class Solution {
public:
    int solve(string s) {
        
    }
};
```

Example 1:
Input: s = ""00110011""
Output: 6

Example 2:
Input: s = ""10101""
Output: 4

Constraints:

1 <= s.length <= @data
s[i] is either '0' or '1'.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(string s) {
        int curr = 1, prev = 0, ans = 0;
        for (int i = 1; i < s.length(); i++)
            if (s[i] == s[i-1]) curr++;
            else ans += min(curr, prev), prev = curr, curr = 1;
        return ans + min(curr, prev);
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string s; cin>>s;
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    cout<<result;
    return 0;
}","two_pointers,string",medium
62,"You are given two integers n and x. You have to construct an array of positive integers nums of size n where for every 0 <= i < n - 1, nums[i + 1] is greater than nums[i], and the result of the bitwise AND operation between all elements of nums is x.

Return the minimum possible value of nums[n - 1].

solution main function

```cpp
class Solution {
public:
    long long solve(int n, int x) {
        
    }
};
```

Example 1:
Input: n = 3, x = 4
Output: 6

Example 2:
Input: n = 2, x = 7
Output: 15

Constraints:

1 <= n, x <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 100000, 100000000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    long long solve(int n, int x) {
        long long result = x, mask;
        --n;  // Reducing n by 1 to exclude x from the iteration

        // Step 1: Iterate over each bit position with mask starting at 1 and
        // shifting left
        for (mask = 1; n > 0; mask <<= 1) {
            // Step 2: If the corresponding bit in x is 0
            if ((mask & x) == 0) {
                // Set the bit in result based on the least significant bit of n
                result |= (n & 1) * mask;
                // Shift n to the right by 1 to process the next bit
                n >>= 1;
            }
        }

        return result;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,x; cin>>n>>x;
    // solve
    Solution solution;
    auto result = solution.solve(n,x);
    
    // output
    cout << result << ""\n"";

    return 0;
}",math,hard
63,"You are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1].

You should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... } subjected to the following rule:

    The first element in s[k] starts with the selection of the element nums[k] of index = k.
    The next element in s[k] should be nums[nums[k]], and then nums[nums[nums[k]]], and so on.
    We stop adding right before a duplicate element occurs in s[k].

Return the longest length of a set s[k].

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [5,4,0,3,1,6,2]
Output: 4

Example 2:
Input: nums = [0,1,2]
Output: 1

Constraints:

1 <= nums.length <= @data
0 <= nums[i] < nums.length
All the values of nums are unique.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums) {
        int ans = 0;
        for (int x : nums) {
            if (x == -1) continue;
            int cnt = 0;
            while (nums[x] != -1) {
                cnt += 1;
                int prev = x;
                x = nums[x];
                nums[prev] = -1; // same with visited[prev] = True
            }
            ans = max(ans, cnt);
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    cout << result << ""\n"";

    return 0;
}",search,easy
64,"Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.

Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order.

solution main function

```cpp
class Solution {
public:
    vector<int> solve(vector<int>& arr1, vector<int>& arr2) {
        
    }
};
```

Example 1:
Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
Output: [2,2,2,1,4,3,3,9,6,7,19]

Example 2:
Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]
Output: [22,28,8,6,17,44]

Constraints:

1 <= arr1.length, arr2.length <= @data
0 <= arr1[i], arr2[i] <= @data
All the elements of arr2 are distinct.
Each arr2[i] is in arr1.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> solve(vector<int>& arr1, vector<int>& arr2) {
        int maxElement = *max_element(arr1.begin(), arr1.end());
        vector<int> count(maxElement + 1);

        // Count occurrences of each element
        for (int element : arr1) {
            count[element]++;
        }

        vector<int> result;
        // Add elements as per relative order
        for (int element : arr2) {
            while (count[element] > 0) {
                result.push_back(element);
                count[element]--;
            }
        }
        // Add remaining elements in ascending order
        for (int num = 0; num <= maxElement; num++) {
            while (count[num] > 0) {
                result.push_back(num);
                count[num]--;
            }
        }
        return result;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    vector<int> a,b;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        a.push_back(x);
    }
    for(int i=1;i<=m;i++)
    {
        int x; cin>>x;
        b.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(a,b);
    // output
    // cout << result << ""\n"";
    for(auto it:result) cout<<it<<' ';
    return 0;
}",sort,easy
65,"Given a weighted undirected connected graph with n vertices numbered from 0 to n - 1, and an array edges where edges[i] = [a_i, b_i, weight_i] represents a bidirectional and weighted edge between nodes a_i and b_i. A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles and with the minimum possible total edge weight.

Find all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST). An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge. On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.

Note that you can return the indices of the edges in any order.

solution main function
```cpp
class Solution
{
    public:
    vector<vector<int>> solve(int n, vector<vector<int>>& edges)
}
```

Example 1:
Inputn = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]
Output: [[0,1],[2,3,4,5]]

Example 2:
Inputn = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]
Output: [[],[0,1,2,3]]

Constraints:
2 <= n <= @data
1 <= edges.length <= min(4*n, n * (n - 1) / 2)
edges[i].length == 3
0 <= from_i < to_i < n
1 <= weight_i <= 1000
All pairs (a_i, b_i) are distinct
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 100, 1000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:

    int p[1010];


    int find(int a) {
        if (a != p[a]) p[a] = find(p[a]);
        return p[a];
    }

    int work1(int n, vector<vector<int>>& edges, int k) {
        for (int i = 0; i < n; i ++ ) p[i] = i;
        int cost = 0, cnt = 0;
        for (auto& e:edges) {
            if (e[3] == k) continue; 
            int f1 = find(e[1]), f2 = find(e[2]);
            if (f1 != f2) {
                cost += e[0];
                cnt ++;
                if (cnt == n - 1) break;
                p[f1] = f2;
            }
        }
        if (cnt == n - 1) return cost;
        else return INT_MAX;
    }

    int work2(int n, vector<vector<int>>& edges, int k) {
        for (int i = 0; i < n; i ++ ) p[i] = i;
        int cost = 0, cnt = 0;

        for (auto& e : edges) { 
            if (e[3] == k) {
                cost += e[0];
                cnt ++;
                p[e[1]] = e[2];
                break;
            }
        }

        for (auto& e: edges) {
            int f1 = find(e[1]), f2 = find(e[2]);
            if (f1 != f2) {
                cost += e[0];
                cnt ++;
                if (cnt == n - 1) break;
                p[f1] = f2;
            }
        }
        if (cnt == n - 1) return cost;
        else return INT_MAX;
    }

    vector<vector<int>> solve(int n, vector<vector<int>>& edges) {

        int m = edges.size();
        for (int i = 0; i < m; i ++ ) {
            auto& e = edges[i];
            swap(e[0], e[2]);
            e.push_back(i);
        }
        sort(edges.begin(), edges.end());

        int min_cost = work1(n, edges, -1); 
        // cout << min_cost << endl;
        vector<vector<int>> ans(2);
        for (int i = 0; i < m; i ++ ) {
            if (work1(n, edges, i) > min_cost) ans[0].push_back(i); 
            else if (work2(n, edges, i) == min_cost) ans[1].push_back(i); 
        } 
        return ans;

    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m;
    cin>>n>>m;
    vector<vector<int> > edge;
    for(int i=1;i<=m;i++)
    {
        int x,y,z; cin>>x>>y>>z;
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        temp.push_back(z);
        edge.push_back(temp);
    }
    // solve
    Solution solution;
            auto result = solution.solve(n,edge);
    
    // output
    for(auto it:result)
    {
        sort(it.begin(),it.end());
        for(auto x:it)
            cout<<x<<' ';
        cout<<endl;
    }
    return 0;
}","graph,tree,data_structures",hard
66,"You are given an array nums consisting of positive integers.

Starting with score = 0, apply the following algorithm:

    Choose the smallest integer of the array that is not marked. If there is a tie, choose the one with the smallest index.
    Add the value of the chosen integer to score.
    Mark the chosen element and its two adjacent elements if they exist.
    Repeat until all the array elements are marked.

Return the score you get after applying the above algorithm

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [2,1,3,4,5,2]
Output: 7

Example 2:
Input: nums = [2,3,5,1,3,2]
Output: 5

Constraints:

1 <= nums.length <= @data
1 <= nums[i] <= 10^6

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    long long solve(vector<int>& nums) {
        long long ans = 0;
        for (int i = 0; i < nums.size(); i += 2) {
            int currentStart = i;
            while (i + 1 < nums.size() && nums[i + 1] < nums[i]) {
                i++;
            }
            for (int currentIndex = i; currentIndex >= currentStart;
                 currentIndex -= 2) {
                ans += nums[currentIndex];
            }
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> num;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num);
    
    // output
    cout<<result;
    return 0;
}",sort,medium
67,"# Problem Statement
Vika and her friends went shopping in a mall, which can be represented as a rectangular grid of rooms with sides of length $n$ and $m$. Each room has coordinates $(a, b)$, where $1 \le a \le n, 1 \le b \le m$. Thus we call a hall with coordinates $(c, d)$ a neighbouring for it if $|a - c| + |b - d| = 1$.

Tired of empty fashion talks, Vika decided to sneak away unnoticed. But since she hasn't had a chance to visit one of the shops yet, she doesn't want to leave the mall. After a while, her friends noticed Vika's disappearance and started looking for her.

Currently, Vika is in a room with coordinates $(x, y)$, and her $k$ friends are in rooms with coordinates $(x_1, y_1)$, $(x_2, y_2)$, ... $, (x_k, y_k)$, respectively. The coordinates can coincide. Note that all the girls **must** move to the neighbouring rooms.

Every minute, first Vika moves to one of the adjacent to the side rooms of her choice, and then each friend (**seeing Vika's choice**) also chooses one of the adjacent rooms to move to.

If **at the end of the minute** (that is, after all the girls have moved on to the neighbouring rooms) at least one friend is in the same room as Vika, she is caught and all the other friends are called.

Tell us, can Vika run away from her annoying friends forever, or will she have to continue listening to empty fashion talks after some time?

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, int &m, int &k, int &x, int &y, vector<pair<int, int>> &a) {   
        // write your code here
    }
};
```
where:  
- `n` and `m` are the size of the mall, `k` is the number of friends
- `x` and `y` are Vika's initial position
- `a` is the initial position of the friends
- return ""YES"" if Vika can run away from her friends forever, otherwise return ""NO""

# Example 1:  
- Input:  
n = 2, m = 2, k = 2
x = 1, y = 1
a = [(1, 1), (1, 2)]
- Output:  
YES

# Constraints:  
- $1 \leq n, m, k \leq @data$  
- $1 \leq x, x_i \leq n$
- $1 \leq y, y_i \leq m$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[100, 10000, 1000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(int n, int m, int k, int x, int y, vector<pair<int, int>> &a)
    {
        bool caught = false;
        for (int i = 0; i < k; i++)
        {
            int X = a[i].first, Y = a[i].second;
            if ((x + y + X + Y) % 2 == 0)
                caught = true;
        }
        return caught ? ""NO"" : ""YES"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, m, k;
    cin >> n >> m >> k;
    int x, y;
    cin >> x >> y;
    vector<pair<int, int>> a(k);
    for (auto &[X, Y] : a)
        cin >> X >> Y;

    // solve
    Solution solution;
    auto result = solution.solve(n, m, k, x, y, a);

    // output
    cout << result << ""\n"";

    return 0;
}","graph,math",medium
68,"Given a permutation of length n, find the MTH permutation after it

solution main function
```cpp
class Solution
{
    public:
    vector<int> solve(int n, int m, vector<int> &num)
}
```

Pass in parameters:
2 integers n,m and an array num

Return parameters:
An array represents the answer.

Example 1:
Input: n=5,m=3,num=[1, 2, 3, 4, 5]
Output: ans=[1, 2, 4, 5, 3]

Constraints:
0<n@data, m100
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[20, 100, 10000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution
{
public:
    vector<int> solve(int n, int m, vector<int> &num)
    {
    	for(int i=1;i<=m;++i)	next_permutation(num.begin(),num.end());
        return num;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    vector<int> num;
    for (int i = 1; i <=n; i++)
    {
        int x; cin >> x;
        num.push_back(x);
    }

    // solve
    Solution solution;
            auto result = solution.solve(n,m,num);
    
    // output
    for(auto it :num) cout<<it<<' ';

    return 0;
}",STL,medium
69,"# Problem Statement
Matryoshka is a wooden toy in the form of a painted doll, inside which you can put a similar doll of a smaller size.

A set of nesting dolls contains one or more nesting dolls, their sizes are consecutive positive integers. Thus, a set of nesting dolls is described by two numbers: $s$  the size of a smallest nesting doll in a set and $m$  the number of dolls in a set. In other words, the set contains sizes of $s, s + 1, \dots, s + m - 1$ for some integer $s$ and $m$ ($s,m &gt; 0$).

You had one or more sets of nesting dolls. Recently, you found that someone mixed all your sets in one and recorded a sequence of doll sizes  integers $a_1, a_2, \dots, a_n$.

You do not remember how many sets you had, so you want to find the **minimum** number of sets that you could initially have.

For example, if a given sequence is $a=[2, 2, 3, 4, 3, 1]$. Initially, there could be $2$ sets:

-   the first set consisting of $4$ nesting dolls with sizes $[1, 2, 3, 4]$;
-   a second set consisting of $2$ nesting dolls with sizes $[2, 3]$.

According to a given sequence of sizes of nesting dolls $a_1, a_2, \dots, a_n$, determine the minimum number of nesting dolls that can make this sequence.

Each set is completely used, so all its nesting dolls are used. Each element of a given sequence must correspond to exactly one doll from some set.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the minimum possible number of matryoshkas sets. 

# Example 1:  
- Input:  
n = 6
a = [2, 2, 3, 4, 3, 1]
- Output:  
2

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        sort(a.begin(), a.end());
        int ans = 0, L = 0, R = 0, last = 0, last_count = 0;
        while (L < n)
        {
            while (R < n && a[L] == a[R])
                R++;
            if (a[L] != last + 1)
                ans += R - L;
            else
                ans += R - L - min(last_count, R - L);
            last = a[L];
            last_count = R - L;
            L = R;
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","sort,two_pointers",hard
70,"# Problem Statement
The square still has a rectangular shape of $n \times m$ meters. However, the picture is about to get more complicated now. Let $a_{i,j}$ be the $j$\-th square in the $i$\-th row of the pavement.

You are given the picture of the squares:

-   if $a_{i,j} = $ ""\*"", then the $j$\-th square in the $i$\-th row should be **black**;
-   if $a_{i,j} = $ ""."", then the $j$\-th square in the $i$\-th row should be **white**.

The black squares are paved already. You have to pave the white squares. There are two options for pavement tiles:

-   $1 \times 1$ tiles each tile costs $x$ burles and covers exactly $1$ square;
-   $1 \times 2$ tiles each tile costs $y$ burles and covers exactly $2$ adjacent squares of the **same row**. **Note that you are not allowed to rotate these tiles or cut them into $1 \times 1$ tiles.**

**You should cover all the white squares, no two tiles should overlap and no black squares should be covered by tiles.**

What is the smallest total price of the tiles needed to cover all the white squares?

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &m, int &x, int &y, vector<vector<char>> &a) {
        // write your code here
    }
};
```
where:  
- return: the smallest total price of the tiles needed to cover all the white squares in burles.

# Example 1:  
- Input: 
n = 1, m = 1, x = 10, y = 1
a = "".""
- Output:  
10

# Constraints:  
- $1 \leq n * m \leq @data$
- $1 \leq x, y \leq 10^3$
- $a[i][j] \in \{'.', '*'\}$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, int &m, int &x, int &y, vector<vector<char>> &a)
    {
        int ans = 0;
        y = min(y, 2 * x);
        for (int i = 0; i < n; ++i)
        {
            for (int l = 0, r; l < m;)
            {
                if (a[i][l] == '*')
                    ++l;
                else
                {
                    for (r = l; r < m && a[i][r] == '.'; ++r)
                        ;
                    ans += (r - l) / 2 * y + (r - l) % 2 * x;
                    l = r;
                }
            }
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n,m,x,y;
    cin >> n >> m >> x >> y;
    vector<vector<char>> a(n, vector<char>(m));
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            cin >> a[i][j];

    // solve
    Solution solution;
    auto result = solution.solve(n, m, x, y, a);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,dp,two_pointers",medium
71,"You are given an m x n binary matrix grid.

A row or column is considered palindromic if its values read the same forward and backward.

You can flip any number of cells in grid from 0 to 1, or from 1 to 0.

Return the minimum number of cells that need to be flipped to make either all rows palindromic or all columns palindromic.

solution main function
```cpp
class Solution {
public:
    int solve(vector<vector<int>>& grid) {
        
    }
};
```

Example 1:
Input: grid = [[1,0,0],[0,0,0],[0,0,1]]
Output: 2

Example 2:
Input: grid = [[0,1],[0,1],[0,0]]
Output: 1

Constraints:


m == grid.length
n == grid[i].length
1 <= m * n <= @data
0 <= grid[i][j] <= 1


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<vector<int>>& grid){
        int m=grid.size();
        int n=grid[0].size();
        
        int k=0;
        for(int i=0;i<m;i++){
            int c=0;
            int l=0,r=grid[i].size()-1;

            while(l<r){
                if(grid[i][l]!=grid[i][r]) c++;
                l++;
                r--;
            }
            k+=c;
        }

        int c=0;
        for (int i=0;i<n;i++) {
            int l=0,r=m-1;
            while(l<r){
                if(grid[l][i]!=grid[r][i]) c++;
                l++;
                r--;
            }
        }

        return min(k,c);
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    vector<vector<int> > s;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=m;j++)
        {
            int x; cin>>x;
            temp.push_back(x);
        }
        s.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","two_pointers,other",medium
72,"You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:

    0 represents an empty cell,
    1 represents an obstacle that may be removed.

You can move up, down, left, or right from and to an empty cell.

Return the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).

solution main function

```cpp
class Solution {
public:
    int solve(vector<vector<int>>& grid) {
        
    }
};
```

Example 1:
Input: grid = [[0,1,1],[1,1,0],[1,1,0]]
Output: 2

Example 2:
Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]
Output: 0

Constraints:


m == grid.length
n == grid[i].length
1 <= m, n <= @data
2 <= m * n <= @data
grid[i][j] is either 0 or 1.
grid[0][0] == grid[m - 1][n - 1] == 0


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[256000, 128000, 64000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<int>> distance(m, vector<int>(n, INT_MAX));
        deque<pair<int, int>> dq;

        distance[0][0] = 0;
        dq.push_front({0, 0});
        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!dq.empty()) {
            auto [x, y] = dq.front();
            dq.pop_front();
            for (auto [dx, dy] : directions) {
                int nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                    int newDist = distance[x][y] + grid[nx][ny];
                    if (newDist < distance[nx][ny]) {
                        distance[nx][ny] = newDist;
                        if (grid[nx][ny] == 0) {
                            dq.push_front({nx, ny});
                        } else {
                            dq.push_back({nx, ny});
                        }
                    }
                }
            }
        }
        return distance[m-1][n-1];
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m;
    cin>>n>>m;
    vector<vector<int> > s;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=m;j++)
        {
            int x; cin>>x;
            temp.push_back(x);
        }
        s.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    // output
    cout << result << ""\n"";
    // for(auto it:result) cout<<it<<' ';
    return 0;
}","graph,search",medium
73,"Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.

solution main function

```cpp
class Solution {
public:
    vector<int> solve(vector<int>& nums1, vector<int>& nums2) {
        
    }
};
```

Example 1:
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]

Example 2:
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]

Constraints:

1 <= nums1.length, nums2.length <= @data
0 <= nums1[i], nums2[i] <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> solve(vector<int>& nums1, vector<int>& nums2) {
   vector<int> result;
        int n = nums1.size();
        int m = nums2.size();
        
        // Sorting both arrays
        sort(nums1.begin(), nums1.end());
        sort(nums2.begin(), nums2.end());
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {  
                if (nums1[i] == nums2[j]) {
                    if (find(result.begin(), result.end(), nums1[i]) == result.end()) {
                        result.push_back(nums1[i]);
                    }
                    break; 
                }
            }
        }
        
        return result;
    }

};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    vector<int> a,b;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        a.push_back(x);
    }
    for(int i=1;i<=m;i++)
    {
        int x; cin>>x;
        b.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(a,b);
    // output
    // cout << result << ""\n"";
    for(auto it:result) cout<<it<<' ';
    return 0;
}","binary,sort,two_pointers",medium
74,"Given an array of integers arr and two integers k and threshold, return the number of sub-arrays of size k and average greater than or equal to threshold.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& arr, int k, int threshold) {
        
    }
};
```

Example 1:
Input: arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4
Output: 3

Example 2:
Input: arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5
Output: 6

Constraints:

1 <= arr.length <= @data
1 <= arr[i] <= 10^4
1 <= k <= arr.length
0 <= threshold <= 10^4

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& arr, int k, int threshold) 
    {
        int n = arr.size() , count=0 ,prefixsum =0 ;
        int l=0, r=0;
        while(r<n)
        {
            prefixsum+=arr[r];
            if(r-l+1==k)
            {
                if(prefixsum/k >= threshold)
                {
                   count++;
                }
                prefixsum-=arr[l];
                l++;
            }
            r++;
        }
        return count;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,k,sum; cin>>n>>k>>sum;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s,k,sum);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",other,medium
75,"# Problem Statement
There are $n$ coins on the table forming a circle, and each coin is either facing up or facing down. Alice and Bob take turns to play the following game, and Alice goes first.

In each operation, the player chooses a facing-up coin, removes the coin, and flips the two coins that are adjacent to it. If (before the operation) there are only two coins left, then one will be removed and the other won't be flipped (as it would be flipped twice). If (before the operation) there is only one coin left, no coins will be flipped. If (before the operation) there are no facing-up coins, the player loses.

Decide who will win the game if they both play optimally. It can be proved that the game will end in a finite number of operations, and one of them will win.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, string &s) {
        // write your code here
    }
};
```
where:  
- `n`: the number of coins, `s`: the orientation of the coins, where `'U'` means facing up and `'D'` means facing down
- return: if Alice wins, return ""YES"", otherwise return ""NO""

# Example 1:  
- Input:  
n = 5
s = ""UUDUD""
- Output:  
YES

# Constraints:  
- $1 \leq n \leq @data$
- s[i] = 'U' or 'D'
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[100, 10000, 1000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(int &n, string &s)
    {
        int cnt = 0;
        for (auto x : s)
            if (x == 'U')
                cnt++;
        return (cnt % 2) ? ""YES"" : ""NO"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    string s;
    cin >> s;
    // solve
    Solution solution;
    auto result = solution.solve(n, s);

    // output
    cout << result << ""\n"";

    return 0;
}",greedy,medium
76,"You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height.

You are given a collection of rods that can be welded together. For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6.

Return the largest possible height of your billboard installation. If you cannot support the billboard, return 0.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& rods) {
        
    }
};
```

Example 1:
Input: rods = [1,2,3,6]
Output: 6

Example 2:
Input: rods = [1,2,3,4,5,6]
Output: 10

Constraints:


1 <= rods.length <= @data
1 <= rods[i] <= 1000
sum(rods[i]) <= 100*@data


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[30, 100, 1000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
  int solve(vector<int>& rods) {
    int sum = 0;
    for (int rod : rods) {
      sum += rod;
    }
    int dp[sum + 1];
    dp[0] = 0;
    for (int i = 1; i <= sum; i++) {
      dp[i] = -1;
    }
    for (int rod : rods) {
      int dpCopy[sum + 1];
      copy(dp, dp + (sum + 1), dpCopy);
      for (int i = 0; i <= sum - rod; i++) {
        if (dpCopy[i] < 0) continue;
        dp[i + rod] = max(dp[i + rod], dpCopy[i]);
        dp[abs(i - rod)] = max(dp[abs(i - rod)], dpCopy[i] + min(i, rod));
      }
    }
    return dp[0];
  }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    cout << result << ""\n"";

    return 0;
}",dp,hard
77,"# Problem Statement
Mushroom Filippov cooked himself a meal and while having his lunch, he decided to watch a video on TubeTube. He can not spend more than $t$ seconds for lunch, so he asks you for help with the selection of video.

The TubeTube feed is a list of $n$ videos, indexed from $1$ to $n$. The $i$\-th video lasts $a_i$ seconds and has an entertainment value $b_i$. Initially, the feed is opened on the first video, and Mushroom can skip to the next video in $1$ second (if the next video exists). Mushroom can skip videos any number of times (including zero).

Help Mushroom choose **one** video that he can open and watch in $t$ seconds. If there are several of them, he wants to choose the most entertaining one. Print the index of any appropriate video, or $-1$ if there is no such.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &t, vector<int> &a, vector<int> &b) {   
        // write your code here
    }
};
```
where:  
- `n` is the number of videos
- `t` is the lunch time
- `a` is the duration of the videos
- `b` is the entertainment value of the videos

# Example 1:  
- Input:  
n = 5 
t = 9
a = [1, 5, 7, 6, 6]
b = [3, 4, 7, 1, 9]
- Output:  
3

# Constraints:  
- $1 \leq n \leq @data$  
- $1 \leq a[i], b[i], t \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, int &t, vector<int> &a, vector<int> &b)
    {

        int x = -2;
        for (int i = 0; i < n; i++)
        {
            if (a[i] + i <= t)
            {
                if (x == -2 || b[x] < b[i])
                    x = i;
            }
        }
        return x + 1;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, t;
    cin >> n >> t;
    vector<int> a(n), b(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];
    for (int i = 0; i < n; i++)
        cin >> b[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, t, a, b);

    // output
    cout << result << ""\n"";

    return 0;
}",greedy,easy
78,"You are given a 0-indexed integer array nums and a positive integer k.

You can apply the following operation on the array any number of times:

    Choose any element of the array and flip a bit in its binary representation. Flipping a bit means changing a 0 to 1 or vice versa.

Return the minimum number of operations required to make the bitwise XOR of all elements of the final array equal to k.

Note that you can flip leading zero bits in the binary representation of elements. For example, for the number (101)2 you can flip the fourth bit and obtain (1101)2.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& nums, int k) {
        
    }
};
```

Example 1:
Input: nums = [2,1,3,4], k = 1
Output: 2

Example 2:
Input: nums = [2,0,2,0], k = 0
Output: 0

Constraints:

1 <= nums.length <= @data
0 <= nums[i] <= 10^6
0 <= k <= 10^6

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums, int k) {
        int finalXor = 0;
        for (int n : nums) {
            finalXor = finalXor ^ n;
        }
        
        return __builtin_popcount(finalXor ^ k);
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,k; cin>>n>>k;
    vector<int> num;
    for(int i=1;i<=n;i++)
    {
        int x;cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num,k);
    // output
    cout << result << ""\n"";
    // for(auto it:result) printf(""%d "",it);
    return 0;
}",bit_manipulation,medium
79,"# Problem Statement
During your journey through computer universes, you stumbled upon a very interesting world. It is a path with $n$ consecutive cells, each of which can either be empty, contain thorns, or a coin. In one move, you can move one or two cells along the path, provided that the destination cell does not contain thorns (and belongs to the path). If you move to the cell with a coin, you pick it up.

You want to collect as many coins as possible. Find the maximum number of coins you can collect in the discovered world if you start in the leftmost cell of the path.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, string &s) {
        // write your code here
    }
};
```
where:  
- `s` is a string of length n, containing characters '.' (empty cell), '@' (thorns), and '*' (coin).
- return:the maximum number of coins you can collect. 

# Example 1:  
- Input: 
a = 10
s = "".@@*@.**@@"" 
- Output:  
3

# Constraints:  
- $1 \leq n \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, string &s)
    {
        int p = s.find(""**"");
        if (p == -1)
            p = n;
        int ans = 0;
        for (int i = 0; i < p; i++)
            if (s[i] == '@')
                ans++;
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    string s;
    cin >> s;

    // solve
    Solution solution;
    auto result = solution.solve(n, s);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,dp",medium
80,"Given an integer array arr of distinct integers and an integer k.

A game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], the larger integer wins and remains at position 0, and the smaller integer moves to the end of the array. The game ends when an integer wins k consecutive rounds.

Return the integer which will win the game.

It is guaranteed that there will be a winner of the game.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& arr, int k) {
        
    }
};
```

Example 1:
Input: arr = [2,1,3,5,4,6,7], k = 2
Output: 5

Example 2:
Input: arr = [3,2,1], k = 10
Output: 3

Constraints:

2 <= arr.length <= @data
1 <= arr[i] <= 10^6
arr contains distinct integers.
1 <= k <= 10^9

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& arr, int k) {
        int maxElement = arr[0];
        for (int i = 1; i < arr.size(); i++) {
            maxElement = max(maxElement, arr[i]);
        }
        
        int curr = arr[0];
        int winstreak = 0;
        
        for (int i = 1; i < arr.size(); i++) {
            int opponent = arr[i];
            
            if (curr > opponent) {
                winstreak++;
            } else {
                curr = opponent;
                winstreak = 1;
            }
            
            if (winstreak == k || curr == maxElement) {
                return curr;
            }
        }
        
        return -1;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,k; cin>>n>>k;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s,k);
    
    // output
    cout << result << ""\n"";

    return 0;
}",greedy,hard
81,"Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:

    Find the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.
    Find the next largest value in nums strictly smaller than largest. Let its value be nextLargest.
    Reduce nums[i] to nextLargest.

Return the number of operations to make all elements in nums equal.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [5,1,3]
Output: 3

Example 2:
Input: nums = [1,1,1]
Output: 0

Constraints:

1 <= nums.length <= @data
1 <= nums[i] <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums) {
        sort(nums.begin(), nums.end(), greater<int>());

        int operations = 0;
        for (int i = 1; i < nums.size(); ++i) {
            if (nums[i] != nums[i - 1]) {
                operations += i;
            }
        }

        return operations;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    // output
    cout << result << ""\n"";
    // for(auto it:result) cout<<it<<' ';
    return 0;
}",sort,medium
82,"# Problem Statement
You are given a string $s$, consisting of digits from $0$ to $9$. In one operation, you can pick any digit in this string, except for $0$ or the leftmost digit, decrease it by $1$, and then swap it with the digit left to the picked.

For example, in one operation from the string $1023$, you can get $1103$ or $1022$.

Find the lexicographically maximum string you can obtain after any number of operations.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(string &s) {
        // write your code here
    }
};
```
where:  
- return: the lexicographically maximum string you can obtain after any number of operations.

# Example 1:  
- Input:  
""19""
- Output:  
""81""

# Constraints:  
- $1 \leq s.length \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(string &s)
    {
        int n = s.size();
        for (int i = 0; i < n; i++)
        {
            int k = i;
            for (int j = i; j < n && j < i + 10; j++)
            {
                if (s[j] - j > s[k] - k)
                {
                    k = j;
                }
            }
            while (k > i)
            {
                s[k]--;
                swap(s[k - 1], s[k]);
                k--;
            }
        }
        return s;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    string s;
    cin >> s;

    // solve
    Solution solution;
    auto result = solution.solve(s);

    // output
    cout << result << ""\n"";

    return 0;
}","string,greedy,math",hard
83,"# Problem Statement
Recall that the sequence $b$ is a a subsequence of the sequence $a$ if $b$ can be derived from $a$ by removing zero or more elements without changing the order of the remaining elements. For example, if $a=[1, 2, 1, 3, 1, 2, 1]$, then possible subsequences are: $[1, 1, 1, 1]$, $[3]$ and $[1, 2, 1, 3, 1, 2, 1]$, but not $[3, 2, 3]$ and $[1, 1, 1, 1, 2]$.

You are given a sequence $a$ consisting of $n$ positive and negative elements (there is no zeros in the sequence).

Your task is to choose **maximum by size** (length) alternating subsequence of the given sequence (i.e. the sign of each next element is the opposite from the sign of the current element, like positive-negative-positive and so on or negative-positive-negative and so on). Among all such subsequences, you have to choose one which has the **maximum sum** of elements.

In other words, if the maximum length of alternating subsequence is $k$ then your task is to find the **maximum sum** of elements of some alternating subsequence of length $k$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the maximum sum of the maximum by size alternating subsequence, please use `long long` type for the return value

# Example 1:  
- Input:  
n = 5
a = [1, 2, 3, -1, -2]
- Output:  
2

# Constraints:  
- $1 \leq n \leq @data$
- $-10^9 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(int &n, vector<int> &a)
    {
        pair<int, long long> neg, pos;
        for (int i = 0; i < n; ++i)
        {
            if (a[i] < 0)
                neg = max(neg, make_pair(pos.first + 1, pos.second + a[i]));
            else
                pos = max(pos, make_pair(neg.first + 1, neg.second + a[i]));
        }
        return max(neg, pos).second;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","dp,greedy,two_pointers",hard
84,"You are given an integer array nums of size n where n is a multiple of 3 and a positive integer k.

In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.

Rick stated that magnetic force between two different balls at positions x and y is |x - y|.

Given the integer array position and the integer m. Return the required force.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& position, int m) {
        
    }
};
```

Example 1:
Input: position = [1,2,3,4,7], m = 3
Output: 3

Example 2:
Input: position = [5,4,3,2,1,1000000000], m = 2
Output: 999999999

Constraints:

n == position.length
2 <= n <= @data
1 <= position[i] <= 10^9
All integers in position are distinct.
2 <= m <= position.length

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[128000, 64000, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    // Check if we can place 'm' balls at 'position'
    // with each ball having at least 'x' gap.
    bool canPlaceBalls(int x, vector<int> &position, int m) {
        // Place the first ball at the first position.
        int prevBallPos = position[0];
        int ballsPlaced = 1;

        // Iterate on each 'position' and place a ball there if we can place it.
        for (int i = 1; i < position.size() && ballsPlaced < m; ++i) {
            int currPos = position[i];
            // Check if we can place the ball at the current position.
            if (currPos - prevBallPos >= x) {
                ballsPlaced += 1;
                prevBallPos = currPos;
            }
        }
        // If all 'm' balls are placed, return 'true'.
        return ballsPlaced == m;
    }

    int solve(vector<int> &position, int m) {
        int answer = 0;
        int n = position.size();
        sort(position.begin(), position.end());

        // Initial search space.
        int low = 1;
        int high = ceil(position[n - 1] / (m - 1.0));
        while (low <= high) {
            int mid = low + (high - low) / 2;
            // If we can place all balls having a gap at least 'mid',
            if (canPlaceBalls(mid, position, m)) {
                // then 'mid' can be our answer,
                answer = mid;
                // and discard the left half search space.
                low = mid + 1;
            } else {
                // Discard the right half search space.
                high = mid - 1;
            }
        }
        return answer;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    vector<int> num;
    for(int i=1;i<=n;i++)
    {
        int x;scanf(""%d"",&x);
        num.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num,m);
    // output
    cout << result << ""\n"";
    // for(auto it:result) cout<<it<<' ';
    return 0;
}","sort,binary",medium
85,"Your music player contains n different songs. You want to listen to goal songs (not necessarily different) during your trip. To avoid boredom, you will create a playlist so that:

    Every song is played at least once.
    A song can only be played again only if k other songs have been played.

Given n, goal, and k, return the number of possible playlists that you can create. Since the answer can be very large, return it modulo 10^9 + 7.

solution main function

```cpp
class Solution {
public:
    int solve(int n, int goal, int k) {
        
    }
};
```

Example 1:
Input: n = 3, goal = 3, k = 1
Output: 6

Example 2:
Input: n = 2, goal = 3, k = 0
Output: 6

Constraints:

0 <= k < n <= goal <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
private:
    static const long long MOD = 1e9 + 7;
    vector<long long> factorial;
    vector<long long> invFactorial;

    // Function to calculate power under modulo MOD
    long long power(long long base, int exponent) {
        long long result = 1;
        // Loop until exponent is not zero
        while (exponent > 0) {
            // If exponent is odd, multiply result with base
            if (exponent & 1) {
                result = (result * base) % MOD;
            }
            // Divide the exponent by 2 and square the base
            exponent >>= 1;
            base = (base * base) % MOD;
        }
        return result;
    }

    // Function to pre-calculate factorials and inverse factorials
    void precalculateFactorials(int n) {
        factorial.resize(n + 1);
        invFactorial.resize(n + 1);
        factorial[0] = invFactorial[0] = 1;
        // Calculate factorials and inverse factorials for each number up to 'n'
        for (int i = 1; i <= n; i++) {
            factorial[i] = (factorial[i - 1] * i) % MOD;
            // Inverse factorial calculated using Fermat's Little Theorem
            invFactorial[i] = power(factorial[i], MOD - 2);
        }
    }

public:
    int solve(int n, int goal, int k) {
        // Pre-calculate factorials and inverse factorials
        precalculateFactorials(n);
        // Initialize variables for calculation
        int sign = 1;
        long long answer = 0;
        // Loop from 'n' down to 'k'
        for (int i = n; i >= k; i--) {
            // Calculate temporary result for this iteration
            long long temp = power(i - k, goal - k);
            temp = (temp * invFactorial[n - i]) % MOD;
            temp = (temp * invFactorial[i - k]) % MOD;
            // Add or subtract temporary result to/from answer
            answer = (answer + sign * temp + MOD) % MOD;
            // Flip sign for next iteration
            sign *= -1;
        }
        // Final result is n! * answer, all under modulo
        return (factorial[n] * answer) % MOD;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,goal,k; cin>>n>>goal>>k;
    // solve
    Solution solution;
    auto result = solution.solve(n,goal,k);
    
    // output
    cout << result << ""\n"";

    return 0;
}",math,hard
86,"Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.

solution main function

```cpp
class Solution {
public:
    vector<vector<int>> solve(int n) {
        
    }
};
```

Example 1:
Input: n = 3
Output: [[1,2,3],[8,9,4],[7,6,5]]

Example 2:
Input: n = 1
Output: [[1]]

Constraints:

1 <= n <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[50, 100, 500]",1000.0,"[[128000, 64000, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int floorMod(int x, int y) { return ((x % y) + y) % y; }

    vector<vector<int>> solve(int n) {
        vector<vector<int>> result(n, vector<int>(n));
        int cnt = 1;
        int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        int d = 0;
        int row = 0;
        int col = 0;
        while (cnt <= n * n) {
            result[row][col] = cnt++;
            int r = floorMod(row + dir[d][0], n);
            int c = floorMod(col + dir[d][1], n);
            // change direction if next cell is non zero
            if (result[r][c] != 0) d = (d + 1) % 4;
            row += dir[d][0];
            col += dir[d][1];
        }
        return result;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
    auto result = solution.solve(n);
    // output
    // cout << result << ""\n"";
    // for(auto it:result) cout<<it<<' ';
    for(auto str:result)
    {
        for(auto it:str)
            printf(""%d "",it);
        putchar('\n');
    }
    return 0;
}",math,easy
87,"# Problem Statement
Turtle thinks a string $s$ is a good string if there exists a sequence of strings $t_1, t_2, \ldots, t_k$ ($k$ is an arbitrary integer) such that:

-   $k \ge 2$.
-   $s = t_1 + t_2 + \ldots + t_k$, where $+$ represents the concatenation operation. For example, $\texttt{abc} = \texttt{a} + \texttt{bc}$.
-   For all $1 \le i &lt; j \le k$, the first character of $t_i$ **isn't equal to** the last character of $t_j$.

Turtle is given a string $s$ consisting of lowercase Latin letters. Please tell him whether the string $s$ is a good string!

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, string &s) {
        // write your code here
    }
};
```
where:  
-  output ""YES"" if the string s is a good string, and ""NO"" otherwise.

# Example 1:  
- Input:  
n = 2
s = ""aa""
- Output:  
NO

# Constraints:  
- $2 \leq n \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(int &n, string &s)
    {
        return (s[0] != s[n - 1]) ? ""YES"" : ""NO"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    string s;
    cin >> s;

    // solve
    Solution solution;
    auto result = solution.solve(n, s);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,string",medium
88,"You are given two strings s1 and s2 of equal length consisting of letters ""x"" and ""y"" only. Your task is to make these two strings equal to each other. You can swap any two characters that belong to different strings, which means: swap s1[i] and s2[j].

Return the minimum number of swaps required to make s1 and s2 equal, or return -1 if it is impossible to do so.

solution main function
```cpp
class Solution {
public:
    int solve(string s1, string s2) {
        
    }
};
```

Example 1:
Input: s1 = ""xx"", s2 = ""yy""
Output: 1

Example 2:
Input: s1 = ""xy"", s2 = ""yx""
Output: 2

Constraints:

1 <= s1.length, s2.length <= @data
s1.length == s2.length
s1, s2 only contain 'x' or 'y'

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(string s1, string s2) {
        int xy = 0, yx = 0;

        // Step 1: Checking the number of places which are indifferent in s1 and s2.
        // There can only be 2 possibilites , s1 having x and s2 having y or vice-versa.
        for (int i = 0; i < s1.size(); ++i) {
            if (s1[i] == 'x' && s2[i] == 'y') xy++;
            if (s1[i] == 'y' && s2[i] == 'x') yx++;
        }

        // Step 2: Checking if the number of the differences is odd , 
        // if yes then swaps won't make the strings identical
        if ((xy + yx) % 2 != 0) return -1;

        // Step 3: Then finally return the number of swaps and we are dividing by 2 because
        // in one swap , we count one from s1 and one from s2
        return xy / 2 + yx / 2 + (xy % 2) * 2;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string a,b; cin>>a>>b;
    // solve
    Solution solution;
    auto result = solution.solve(a,b);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",string,medium
89,"# Problem Statement
You are given a string $s$, consisting of lowercase Latin letters and/or question marks.

A tandem repeat is a string of an even length such that its first half is equal to its second half.

A string $a$ is a substring of a string $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.

Your goal is to replace each question mark with some lowercase Latin letter in such a way that the length of the longest substring that is a tandem repeat is maximum possible.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(string &s) {
        // write your code here
    }
};
```
where:  
- the return value is the length of the longest substring that is a tandem repeat

# Example 1:  
- Input:  
s = ""?????""
- Output:  
4

# Constraints:  
- $1 \leq s.length \leq @data$
- s consists of lowercase Latin letters or question marks
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 5000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(string &s)
    {
        int n = int(s.size());
        int ans = 0;
        for (int len = n / 2; len >= 1; len--)
        {
            int t = 0;
            for (int i = 0; i + len < n; i++)
            {
                if (s[i] == s[i + len] || s[i] == '?' || s[i + len] == '?')
                {
                    t += 1;
                    if (t == len)
                    {
                        ans = max(ans, len);
                        break;
                    }
                }
                else
                    t = 0;
            }
        }
        return ans * 2;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    string s;
    cin >> s;

    // solve
    Solution solution;
    auto result = solution.solve(s);

    // output
    cout << result << ""\n"";

    return 0;
}","dp,two_pointers,string",medium
90,"Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.

Note that after backspacing an empty text, the text will continue empty.

solution main function

```cpp
class Solution {
public:
    bool solve(string s, string t) {
        
    }
};
```

Example 1:
Input: s = ""ab#c"", t = ""ad#c""
Output: true

Example 2:
Input: s = ""ab##"", t = ""c#d#""
Output: true

Constraints:

1 <= s.length, t.length <= @data
s and t only contain lowercase letters and '#' characters.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    bool solve(string S, string T) {
        int i = S.length() - 1, j = T.length() - 1, back;
        while (true) {
            back = 0;
            while (i >= 0 && (back > 0 || S[i] == '#')) {
                back += S[i] == '#' ? 1 : -1;
                i--;
            }
            back = 0;
            while (j >= 0 && (back > 0 || T[j] == '#')) {
                back += T[j] == '#' ? 1 : -1;
                j--;
            }
            if (i >= 0 && j >= 0 && S[i] == T[j]) {
                i--;
                j--;
            } else {
                break;
            }
        }
        return i == -1 && j == -1;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string a,b;
    cin>>a>>b;
    // solve
    Solution solution;
    auto result = solution.solve(a,b);
    
    // output
    cout << result << ""\n"";

    return 0;
}","string,two_pointers",easy
91,"# Problem Statement
You are given a string $s$ of length $n$ consisting of characters $\texttt{A}$ and $\texttt{B}$. You are allowed to do the following operation:

-   Choose an index $1 \le i \le n - 1$ such that $s_i = \texttt{A}$ and $s_{i + 1} = \texttt{B}$. Then, swap $s_i$ and $s_{i+1}$.

You are only allowed to do the operation **at most once** for each index $1 \le i \le n - 1$. However, you can do it in any order you want. Find the maximum number of operations that you can carry out.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, string &s) {
        // write your code here
    }
};
```
where:  
- return: the maximum number of operations that you can carry out

# Example 1:  
- Input:  
n = 2
s = ""AB""
- Output:  
1

# Constraints:  
- $2 \leq n \leq @data$
- $ s[i] \in \{ \texttt{A}, \texttt{B} \}$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, string &s)
    {
        int l = 0, r = n;
        while (l < r && s[l] == 'B')
            l += 1;
        while (l < r && s[r - 1] == 'A')
            r -= 1;
        return max(0, r - l - 1);
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    string s;
    cin >> s;

    // solve
    Solution solution;
    auto result = solution.solve(n, s);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,string,two_pointers",hard
92,"# Problem Statement
Mocha likes arrays, so before her departure, Chamo gave her an array $a$ consisting of $n$ positive integers as a gift.

Mocha doesn't like arrays containing different numbers, so Mocha decides to use magic to change the array. Mocha can perform the following three-step operation some (possibly, zero) times:

1.  Choose indices $l$ and $r$ ($1 \leq l \lt r \leq n$)
2.  Let $x$ be the median$^\dagger$ of the subarray $[a_l, a_{l+1},\ldots, a_r]$
3.  Set all values $a_l, a_{l+1},\ldots, a_r$ to $x$

Suppose $a=[1,2,3,4,5]$ initially:

-   If Mocha chooses $(l,r)=(3,4)$ in the first operation, then $x=3$, the array will be changed into $a=[1,2,3,3,5]$.
-   If Mocha chooses $(l,r)=(1,3)$ in the first operation, then $x=2$, the array will be changed into $a=[2,2,2,4,5]$.

Mocha will perform the operation until the array contains only the same number. Mocha wants to know what is the maximum possible value of this number.

$^\dagger$ The median in an array $b$ of length $m$ is an element that occupies position number $\lfloor \frac{m+1}{2} \rfloor$ after we sort the elements in non-decreasing order. For example, the median of $[3,1,4,1,5]$ is $3$ and the median of $[5,25,20,24]$ is $20$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {   
        // write your code here
    }
};
```
where:  
- the return value is the maximum value of the same number at the end

# Example 1:  
- Input:  
n = 5
a = [1, 2, 3, 4, 5]
- Output:  
4

# Constraints:  
- $2 \leq n \leq @data$
- $1 \leq a[i] \leq 10^9$ 
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[100, 10000, 1000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        int mx = 0;
        for (int i = 0; i < n; i++)
        {
            if (i + 1 < n && a[i + 1] >= a[i])
                mx = max(mx, a[i]);
            if (i + 2 < n && a[i + 2] >= a[i])
                mx = max(mx, a[i]);
            if (i - 1 >= 0 && a[i - 1] >= a[i])
                mx = max(mx, a[i]);
            if (i - 2 >= 0 && a[i - 2] >= a[i])
                mx = max(mx, a[i]);
        }
        return mx;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","binary,greedy",hard
93,"You are given an m * n binary grid grid where 1 represents land and 0 represents water. An island is a maximal 4-directionally (horizontal or vertical) connected group of 1's.
The grid is said to be connected if we have exactly one island, otherwise is said disconnected.
In one day, we are allowed to change any single land cell (1) into a water cell (0).
Return the minimum number of days to disconnect the grid.

solution main function
```cpp
class Solution
{
    public:
    int solve(vector<vector<int>>& grid)
}
```
Example 1:
Inputgrid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]
Output: 2

Example 2:
Inputgrid = [[1,1]]
Output: 2

Constraints:
m == grid.length
n == grid[i].length
1 <= m, n <= @data
grid[i][j] is either 0 or 1
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 30, 50]",1000.0,"[[25600, 2560, 1000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
    int dx[4] = {0, 1, 0, -1};
    int dy[4] = {1, 0, -1, 0};
public:
    void dfs(int x, int y, vector<vector<int>>& grid, int n, int m) {
        grid[x][y] = 2;
        for (int i = 0; i < 4; ++i) {
            int tx = dx[i] + x;
            int ty = dy[i] + y;
            if (tx < 0 || tx >= n || ty < 0 || ty >= m || grid[tx][ty] != 1) {
                continue;
            }
            dfs(tx, ty, grid, n, m);
        }
    }
    int count(vector<vector<int>>& grid, int n, int m) {
        int cnt = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] == 1) {
                    cnt++;
                    dfs(i, j, grid, n, m);
                }
            }
        }
        // 
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] == 2) {
                    grid[i][j] = 1;
                }
            }
        }
        return cnt;
    }
    int solve(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        if (count(grid, n, m) != 1) {
            return 0;
        }
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j]) {
                    grid[i][j] = 0;
                    if (count(grid, n, m) != 1) {
                        return 1;
                    }
                    grid[i][j] = 1;
                }
            }
        }
        return 2;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m;
    cin>>n>>m;
    vector<vector<int> > g;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=m;j++)
        {
            int x; cin>>x;
            temp.push_back(x);
        }
        g.push_back(temp);
    }
    // solve
    Solution solution;
            auto result = solution.solve(g);
    
    // output
    cout<<result;
    return 0;
}",graph,hard
94,"# Problem Statement
You are given a tree$^{\dagger}$. In one zelda-operation you can do follows:
-   Choose two vertices of the tree $u$ and $v$;
-   Compress all the vertices on the path from $u$ to $v$ into one vertex. In other words, all the vertices on path from $u$ to $v$ will be erased from the tree, a new vertex $w$ will be created. Then every vertex $s$ that had an edge to some vertex on the path from $u$ to $v$ will have an edge to the vertex $w$.

Determine the minimum number of zelda-operations required for the tree to have only one vertex.

$^{\dagger}$A tree is a connected acyclic undirected graph.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int n, vector<pair<int, int>> &edges) {   
        // write your code here
    }
};
```
where:  
- `n` is the number of vertices
- `edges` is the array of edges (u, v)
- Return the minimum number of zelda-operations

# Example 1:  
- Input:  
n = 4
edges = [(1, 2), (1, 3), (3, 4)]
- Output:  
1

# Constraints:  
- $2 \leq n \leq @data$  
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 3200, 640]]","class Solution
{
public:
    int solve(int &n, vector<pair<int, int>> &edges)
    {
        vector<int> deg(n);
        for (auto [x, y] : edges)
            deg[x - 1]++, deg[y - 1]++;
        int ans = (std::count(deg.begin(), deg.end(), 1) + 1) / 2;
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<pair<int, int>> edges(n - 1);
    for (int i = 0; i < n - 1; i++)
        cin >> edges[i].first >> edges[i].second;

    // solve
    Solution solution;
    auto result = solution.solve(n, edges);

    // output
    cout << result << ""\n"";

    return 0;
}","tree,greedy",medium
95,"The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. All students stand in a queue. Each student either prefers square or circular sandwiches.

The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step:

    If the student at the front of the queue prefers the sandwich on the top of the stack, they will take it and leave the queue.
    Otherwise, they will leave it and go to the queue's end.

This continues until none of the queue students want to take the top sandwich and are thus unable to eat.

You are given two integer arrays students and sandwiches where sandwiches[i] is the type of the ith sandwich in the stack (i = 0 is the top of the stack) and students[j] is the preference of the jth student in the initial queue (j = 0 is the front of the queue). Return the number of students that are unable to eat.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& students, vector<int>& sandwiches) {
        
    }
};
```


Example 1:
Input: students = [1,1,0,0], sandwiches = [0,1,0,1]
Output: 0 

Example 2:
Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]
Output: 3

Constraints:

1 <= students.length, sandwiches.length <= @data
students.length == sandwiches.length
sandwiches[i] is 0 or 1.
students[i] is 0 or 1.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& students, vector<int>& sandwiches) {
        int circleStudentCount = 0;
        int squareStudentCount = 0;

        // Count the number of students who want each type of sandwich
        for (int student : students) {
            if (student == 0) {
                circleStudentCount++;
            } else {
                squareStudentCount++;
            }
        }

        // Serve sandwiches to students
        for (int sandwich : sandwiches) {
            // No student wants the circle sandwich on top of the stack
            if (sandwich == 0 && circleStudentCount == 0) {
                return squareStudentCount;
            } 
            // No student wants the square sandwich on top of the stack
            if (sandwich == 1 && squareStudentCount == 0) {
                return circleStudentCount;
            }
            // Decrement the count of the served sandwich type
            if (sandwich == 0) {
                circleStudentCount--;
            } else {
                squareStudentCount--;
            }
        }
        // Every student received a sandwich
        return 0;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    vector<int> a,b;
    int n; cin>>n;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        a.push_back(x);
    }
     for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        b.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(a,b);
    
    // output
    cout<<result;
    return 0;
}",data_structures,easy
96,"You are given an array of strings names, and an array heights that consists of distinct positive integers. Both arrays are of length n.

For each index i, names[i] and heights[i] denote the name and height of the ith person.

Return names sorted in descending order by the people's heights.

solution main function
```cpp
class Solution {
public:
    vector<string> solve(vector<string>& names, vector<int>& heights) {
        
    }
};
```

Example 1:
Input: names = [""Mary"",""John"",""Emma""], heights = [180,165,170]
Output: [""Mary"",""Emma"",""John""]

Example 2:
Input: names = [""Alice"",""Bob"",""Bob""], heights = [155,185,150]
Output: [""Bob"",""Alice"",""Bob""]

Constraints:


n == names.length == heights.length
1 <= n <= @data
1 <= names[i].length <= 20
1 <= heights[i] <= 10^5
names[i] consists of lower and upper case English letters.
All the values of heights are distinct.


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[6400, 1600, 800]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    std::vector<std::string> solve(std::vector<std::string> &names, std::vector<int> &heights) {
        std::vector<int> indexes(heights.size());

        std::iota(indexes.begin(), indexes.end(), 0);

        std::sort(indexes.begin(), indexes.end(), [&heights](int i, int j) {
            return heights[i] > heights[j];
        });

        std::vector<std::string> res(names.size());
        for (size_t i = 0; i < names.size(); i++)
            res[i] = std::move(names[indexes[i]]);
        
        return res;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<string> s;
    vector<int> h;
    for(int i=1;i<=n;i++)
    {
        string x;cin>>x;
        s.push_back(x);
    }
    for(int i=1;i<=n;i++)
    {
        int x;cin>>x;
        h.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s,h);
    // output
    // cout << result << ""\n"";
    for(auto it:result) cout<<it<<' ';
    return 0;
}",bit_manipulation,easy
97,"# Problem Statement
Slavic has an array of length $n$ consisting only of zeroes and ones. In one operation, he removes either the first or the last element of the array.

What is the minimum number of operations Slavic has to perform such that the total sum of the array is equal to $s$ after performing all the operations? In case the sum $s$ can't be obtained after any amount of operations, you should output \-1.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &s, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the minimum amount of operations required to have the total sum of the array equal to s, or -1 if obtaining an array with sum s isn't possible.

# Example 1:  
- Input:  
n = 3, s = 1
a = [1, 0, 0]
- Output:  
0

# Constraints:  
- $1 \leq n, s \leq @data$
- $a[i] \in \{0, 1\}$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, int &s, vector<int> &a)
    {
        int ans = n + 1;
        int cur = 0;
        for (int i = 0, j = 0; i < n; i++)
        {
            while (j < n && cur + a[j] <= s)
            {
                cur += a[j];
                j++;
            }
            if (cur == s)
            {
                ans = min(ans, n - (j - i));
            }
            cur -= a[i];
        }
        if (ans > n)
        {
            ans = -1;
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, s;
    cin >> n >> s;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, s, a);

    // output
    cout << result << ""\n"";

    return 0;
}","two_pointers,binary",hard
98,"You have a 1-indexed binary string of length n where all the bits are 0 initially. We will flip all the bits of this binary string (i.e., change them from 0 to 1) one by one. You are given a 1-indexed integer array flips where flips[i] indicates that the bit at index i will be flipped in the ith step.

A binary string is prefix-aligned if, after the ith step, all the bits in the inclusive range [1, i] are ones and all the other bits are zeros.

Return the number of times the binary string is prefix-aligned during the flipping process.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& flips) {
        
    }
};
```

Example 1:
Input: flips = [3,2,4,1,5]
Output: 2

Example 2:
Input: flips = [4,1,2,3]
Output: 1


Constraints:

n == flips.length
1 <= n <= @data
flips is a permutation of the integers in the range [1, n].

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& flips) {
        int n = flips.size();
        int s1 = 0;
        int s2 = 0;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            s1 += i + 1;
            s2 += flips[i];
            if (s1 == s2) {
                ans++;
            }
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",other,medium
99,"Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1). 

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [3,4,5,2]
Output: 12 

Example 2:
Input: nums = [1,5,4,5]
Output: 16

Constraints:

2 <= nums.length <= @data
1 <= nums[i] <= 10^3

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums) {
        int biggest = 0;
        int secondBiggest = 0;
        for (int num : nums) {
            if (num > biggest) {
                secondBiggest = biggest;
                biggest = num;
            } else {
                secondBiggest = max(secondBiggest, num);
            }
        }
        
        return (biggest - 1) * (secondBiggest - 1);
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    vector<int> num;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num);
    
    // output
    cout<<result;
    return 0;
}",sort,easy
100,"Alice and Bob take turns playing a game, with Alice starting first.

Initially, there is a number n on the chalkboard. On each player's turn, that player makes a move consisting of:

    Choosing any x with 0 < x < n and n % x == 0.
    Replacing the number n on the chalkboard with n - x.

Also, if a player cannot make a move, they lose the game.

Return true if and only if Alice wins the game, assuming both players play optimally.

solution main function
```cpp
class Solution {
public:
    bool solve(int n) {
        
    }
};
```

Example 1:
Input: n = 2
Output: true

Example 2:
Input: n = 3
Output: false

Constraints:

1 <= n <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    bool solve(int n) {
        return n%2==0;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
    auto result = solution.solve(n);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    printf(""%d"",result);
    return 0;
}","math,other",easy
101,"# Problem Statement
Kinich wakes up to the start of a new day. He turns on his phone, checks his mailbox, and finds a mysterious present. He decides to unbox the present.

Kinich unboxes an array $a$ with $n$ integers. Initially, Kinich's score is $0$. He will perform the following operation any number of times:

-   Select two indices $i$ and $j$ $(1 \leq i &lt; j \leq n)$ such that neither $i$ nor $j$ has been chosen in any previous operation and $a_i = a_j$. Then, add $1$ to his score.

Output the maximum score Kinich can achieve after performing the aforementioned operation any number of times.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the maximum score achievable. 

# Example 1:  
- Input: 
n = 2
a = [2, 2] 
- Output:  
1

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq n$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        sort(a.begin(), a.end());
        int ans = 0;
        int pre = -1, cnt = 0;
        for (int i = 0; i < n; i++)
        {
            if (pre == -1)
            {
                pre = a[i];
                cnt++;
            }
            else
            {
                if (a[i] == pre)
                {
                    cnt++;
                }
                else
                {
                    ans += cnt / 2;
                    pre = a[i];
                    cnt = 1;
                }
            }
        }
        ans += cnt / 2;
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",implementation,easy
102,"# Problem Statement
Given an array $a$ consisting of $n$ elements, find the maximum possible sum the array can have after performing the following operation **any number of times**:

- Choose $2$ **adjacent** elements and flip both of their signs. In other words choose an index $i$ such that $1 \leq i \leq n - 1$ and assign $a_i = -a_i$ and $a_{i+1} = -a_{i+1}$.

Note that the answer may be large, so use a 64-bit integer type.

The main function of the solution is defined as: 
```cpp
class Solution {
public:
    long long solve(int &n, vector<int> &a) {   
        // write your code here
    }
};
```
Where:  
- `n` is the length of the array.  
- `a` is an array of length \(n\).  
- The function should return a 64-bit integer representing the maximum sum of the array after performing the above operation any number of times.

# Example 1  
- Input:  
n = 3
a = [-1, -1, -1]
- Output:  
1

# Constraints  
- $2 \leq n \leq @data$  
- $-10^9 \leq a_i \leq 10^9$  
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(int &n, vector<int> &a)
    {
        long long sum = 0;
        int neg = 0;
        for (int i = 0; i < n; i++)
        {
            if (a[i] < 0)
            {
                neg++;
                a[i] = -a[i];
            }
            sum += a[i];
        }
        if (neg % 2 == 1)
        {
            int mn = *min_element(a.begin(), a.end());
            sum -= 2 * mn;
        }
        return sum;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];
    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","dp,greedy,sort",medium
103,"# Problem Statement
You are given two strings $a$ and $b$ of equal length, consisting of only characters 0 and/or 1; both strings start with character 0 and end with character 1.

You can perform the following operation any number of times (possibly zero):

-   choose one of the strings and two **equal** characters in it; then turn all characters between them into those characters.

Formally, you choose one of these two strings (let the chosen string be $s$), then pick two integers $l$ and $r$ such that $1 \le l < r \le |s|$ and $s_l = s_r$, then replace every character $s_i$ such that $l < i < r$ with $s_l$.

For example, if the chosen string is 010101, you can transform it into one of the following strings by applying one operation:
-   010001 if you choose $l = 3$ and $r = 5$;
-   010111 if you choose $l = 4$ and $r = 6$;

You have to determine if it's possible to make the given strings equal by applying this operation any number of times.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(string &a, string &b) {   
        // write your code here
    }
};
```
where:  
- return value: ""YES"" or ""NO""

# Example 1:  
- Input:  
a = ""01010001""
b = ""01110101""
- Output:  
YES

# Constraints:  
- $1 \leq a.length \leq @data$
- a.length == b.length 
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[100, 10000, 1000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(string &a, string &b)
    {
        int n = a.size();
        for (int i = 0; i < n - 1; i++)
            if (a[i] == '0' && b[i] == '0' && a[i + 1] == '1' && b[i + 1] == '1')
                return ""YES"";
        return ""NO"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    string a, b;
    cin >> a >> b;

    // solve
    Solution solution;
    auto result = solution.solve(a, b);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,dp",hard
104,"You are given a binary matrix matrix of size m x n, and you are allowed to rearrange the columns of the matrix in any order.

Return the area of the largest submatrix within matrix where every element of the submatrix is 1 after reordering the columns optimally.

solution main function
```cpp
class Solution {
public:
    int solve(vector<vector<int>>& matrix) {
        
    }
};
```

Example 1:
Input: matrix = [[0,0,1],[1,1,1],[1,0,1]]
Output: 4

Example 2:
Input: matrix = [[1,0,1,0,1]]
Output: 3

Constraints:

m == matrix.length
n == matrix[i].length
1 <= m * n <= @data
matrix[i][j] is either 0 or 1.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution
{
public:
    int solve(vector<vector<int>>& matrix)
    {
        int m = matrix.size(), n = matrix[0].size();
        int ans = 0;
        for(int j = 0; j < n; j++)
            for(int i = 1; i < m; i++)
                if(matrix[i][j] == 1)
                    matrix[i][j] += matrix[i-1][j];
        for(int i = 0; i < m; i++)
        {
            sort(matrix[i].begin(), matrix[i].end());
            reverse(matrix[i].begin(), matrix[i].end());
            for(int j = 0; j < n; j++)
                ans = max(ans, matrix[i][j]*(j+1));
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    vector<vector<int> > s;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1,x;j<=m;j++)
        {
            cin>>x;
            temp.push_back(x);
        }
        s.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    cout<<result;
    return 0;
}","sort,greedy",medium
105,"You are given a 0-indexed integer array nums of size n, and a 0-indexed integer array pattern of size m consisting of integers -1, 0, and 1.

A subarray nums[i..j] of size m + 1 is said to match the pattern if the following conditions hold for each element pattern[k]:

    nums[i + k + 1] > nums[i + k] if pattern[k] == 1.
    nums[i + k + 1] == nums[i + k] if pattern[k] == 0.
    nums[i + k + 1] < nums[i + k] if pattern[k] == -1.

Return the count of subarrays in nums that match the pattern.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& nums, vector<int>& pattern) {
        
    }
};
```

Example 1:
Input: nums = [1,2,3,4,5,6], pattern = [1,1]
Output: 4

Example 2:
Input: nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]
Output: 2


Constraints:

2 <= n == nums.length <= @data
1 <= nums[i] <= 10^9
1 <= m == pattern.length < n
-1 <= pattern[i] <= 1

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 500, 1000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums, vector<int>& pattern) {
        int n = nums.size();
        int m = pattern.size(); 
        int count = 0;

        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                if (j - i + 1 == m + 1) {
                    int l = i;
                    int flag = 0; 
                    for (int k = 0; k < m; k++, l++) {
                        if (pattern[k] == 1 && nums[l + 1] > nums[l]) {
                            continue;
                        } else if (pattern[k] == 0 && nums[l + 1] == nums[l]) {
                            continue;
                        } else if (pattern[k] == -1 && nums[l + 1] < nums[l]) {
                            continue;
                        } else {
                            flag = 1;
                            break;
                        }
                    }

                    if (flag == 0) {
                        count++;
                    }
                }
            }
        }

        return count;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n;
    vector<int> a,b;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        a.push_back(x);
    }
    cin>>m;
    for(int i=1;i<=m;i++)
    {
        int x; cin>>x;
        b.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(a,b);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",other,medium
106,"There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.
The rules of the game are as follows:
    Start at the 1st friend.
    Count the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.
    The last friend you counted leaves the circle and loses the game.
    If there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.
    Else, the last friend in the circle wins the game.
Given the number of friends, n, and an integer k, return the winner of the game.

solution main function
```cpp
class Solution {
public:
    int solve(int n, int k) {

    }
};
```

Example 1:
Input: n = 5, k = 2
Output: 3

Example 2:
Input: n = 6, k = 5
Output: 1

Constraints:
1 <= k <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 1000000]",1000.0,"[[12800, 1280, 128]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(int n, int k) {
        int ans = 0;
        for (int i = 1; i <= n; ++i) {
            ans = (ans + k) % i;
        }
        return ans + 1;
    }
};","#include <bits/stdc++.h>
#include <iterator>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,k; cin>>n>>k;
    // solve
    Solution solution;
            auto result = solution.solve(n,k);
    
    // output
    cout<<result;
    return 0;
}",math,medium
107,"# Problem Statement
You are given an array $a$ of $n$ integers. Find the number of pairs $(i, j)$ ($1 \le i &lt; j \le n$) where the sum of $a_i + a_j$ is greater than or equal to $l$ and less than or equal to $r$ (that is, $l \le a_i + a_j \le r$).

For example, if $n = 3$, $a = [5, 1, 2]$, $l = 4$ and $r = 7$, then two pairs are suitable:

-   $i=1$ and $j=2$ ($4 \le 5 + 1 \le 7$);
-   $i=1$ and $j=3$ ($4 \le 5 + 2 \le 7$).

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, int &l, int &r, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the number of suitable pairs, please return the result as long long type

# Example 1:  
- Input:  
n = 3, l = 4, r = 7
a = [5, 1, 2]
- Output:  
2

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i], l, r \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(int &n, int &l, int &r, vector<int> &a)
    {
        sort(a.begin(), a.end());
        long long ans = 0;
        for (int i = 0, L = n, R = n; i < n; i++)
        {
            while (L && a[L - 1] + a[i] >= l)
                L--;
            while (R && a[R - 1] + a[i] > r)
                R--;
            ans += min(i, R) - min(i, L);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, l, r;
    cin >> n >> l >> r;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, l, r, a);

    // output
    cout << result << ""\n"";

    return 0;
}","two_pointers,math,binary,data_structures",easy
108,"You are given an integer n, the number of teams in a tournament that has strange rules:

    If the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round.
    If the current number of teams is odd, one team randomly advances in the tournament, and the rest gets paired. A total of (n - 1) / 2 matches are played, and (n - 1) / 2 + 1 teams advance to the next round.

Return the number of matches played in the tournament until a winner is decided.

solution main function

```cpp
class Solution {
public:
    int solve(int n) {
        
    }
};
```

Example 1:
Input: n = 7
Output: 6

Example 2:
Input: n = 14
Output: 13

Constraints:

1 <= n <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(int n) {
        return n - 1;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    cin>>n;
    // solve
    Solution solution;
    auto result = solution.solve(n);
    
    // output
    cout<<result;
    return 0;
}",math,easy
109,"# Problem Statement
An array $[b_1, b_2, \ldots, b_m]$ is a palindrome, if $b_i = b_{m+1-i}$ for each $i$ from $1$ to $m$. Empty array is also a palindrome.

An array is called **kalindrome**, if the following condition holds:

-   It's possible to select some integer $x$ and delete some of the elements of the array equal to $x$, so that the remaining array (after gluing together the remaining parts) is a palindrome.
    

Note that you don't have to delete all elements equal to $x$, and you don't have to delete at least one element equal to $x$.

For example :

-   $[1, 2, 1]$ is kalindrome because you can simply not delete a single element.
-   $[3, 1, 2, 3, 1]$ is kalindrome because you can choose $x = 3$ and delete both elements equal to $3$, obtaining array $[1, 2, 1]$, which is a palindrome.
-   $[1, 2, 3]$ is not kalindrome.

You are given an array $[a_1, a_2, \ldots, a_n]$. Determine if $a$ is kalindrome or not.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- print YES if a is kalindrome and NO otherwise

# Example 1:  
- Input:  
n = 2
a = [1, 2]
- Output:  
YES

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq n$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(int &n, vector<int> &a)
    {
        int i, flag, p;
        flag = 0;
        for (i = 0; i < n / 2; i++)
        {
            if (a[i] != a[n - i - 1])
            {
                p = i;
                flag = 1;
                break;
            }
        }
        auto check = [&](int x, int n)
        {
            int i, j;
            i = 0;
            j = n - i - 1;
            while (i < j)
            {
                if (a[i] == x)
                {
                    i++;
                    continue;
                }
                if (a[j] == x)
                {
                    j--;
                    continue;
                }
                if (a[i] == a[j])
                {
                    i++;
                    j--;
                    continue;
                }
                return 0;
            }
            return 1;
        };
        if (!flag)
        {
            return ""YES"";
        }
        else
        {
            if (check(a[i], n) | check(a[n - i - 1], n))
                return ""YES"";
            else
                return ""NO"";
        }
    }
};
","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,two_pointers",medium
110,"There are n people standing in a queue, and they numbered from 0 to n - 1 in left to right order. You are given an array heights of distinct integers where heights[i] represents the height of the ith person.

A person can see another person to their right in the queue if everybody in between is shorter than both of them. More formally, the ith person can see the jth person if i < j and min(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1]).

Return an array answer of length n where answer[i] is the number of people the ith person can see to their right in the queue.

solution main function
```cpp
class Solution {
public:
    vector<int> solve(vector<int>& heights) {
        
    }
};
```

Example 1:
Input: heights = [10,6,8,5,11,9]
Output: [3,1,2,1,1,0]

Example 2:
Input: heights = [5,1,2,3,10]
Output: [4,1,1,1,0]

Constraints:


n == heights.length
1 <= n <= @data
1 <= heights[i] <= @data
All the values of heights are unique.


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> solve(vector<int>& A) {
        int n = A.size();
        vector<int> res(n), stack;
        for (int i = 0; i < n; ++i) {
            while (!stack.empty() && A[stack.back()] <= A[i])
                res[stack.back()]++, stack.pop_back();
            if (!stack.empty())
                res[stack.back()]++;
            stack.push_back(i);
        }
        return res;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    for(auto it:result) cout<<it<<' ';
    // cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",data_structures,hard
111,"# Problem Statement
Initially, array $a$ contains just the number $1$. You can perform several operations in order to change the array. In an operation, you can select some subsequence$^{\dagger}$ of $a$ and add into $a$ an element equal to the sum of all elements of the subsequence.

You are given a final array $c$. Check if $c$ can be obtained from the initial array $a$ by performing some number (possibly 0) of operations on the initial array.

$^{\dagger}$ A sequence $b$ is a subsequence of a sequence $a$ if $b$ can be obtained from $a$ by the deletion of several (possibly zero, but not all) elements. In other words, select $k$ ($1 \leq k \leq |a|$) distinct indices $i_1, i_2, \dots, i_k$ and insert anywhere into $a$ a new element with the value equal to $a_{i_1} + a_{i_2} + \dots + a_{i_k}$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, vector<int> &c) {
        // write your code here
    }
};
```
where:  
- return: output YES if such a sequence of operations exists, and NO otherwise. 

# Example 1:  
- Input:  
n = 1
c = [1]
- Output:  
YES

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq c[i] \leq 10^5$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(int &n, vector<int> &c)
    {
        sort(c.begin(), c.end());
        long long s = 0;
        for (int i = 0; i < n; i++)
        {
            if (s + (i == 0) < c[i])
                return ""NO"";
            s += c[i];
        }
        return ""YES"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","sort,two_pointers",medium
112,"You are given an integer array nums. The adjacent integers in nums will perform the float division.

    For example, for nums = [2,3,4], we will evaluate the expression ""2/3/4"".

However, you can add any number of parenthesis at any position to change the priority of operations. You want to add these parentheses such the value of the expression after the evaluation is maximum.

Return the corresponding expression that has the maximum value in string format.

Note: your expression should not contain redundant parenthesis.

solution main function

```cpp
class Solution {
public:
    string solve(vector<int>& nums) {
    }
};
```

Example 1:
Input: nums = [1000,100,10,2]
Output: ""1000/(100/10/2)""

Example 2:
Input: timePoints = [""00:00"",""23:59"",""00:00""]
Output: 0

Constraints:

1 <= nums.length <= @data
2 <= nums[i] <= 1000

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[20, 100, 100000]",1000.0,"[[64000, 6400, 800]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    string solve(vector<int>& nums) {
        string str = to_string(nums[0]);
        if(nums.size() == 1)
            return str;
        if(nums.size() == 2) {
            str += ""/"" + to_string(nums[1]);
            return str;
        }
        str += ""/("" + to_string(nums[1]);
        for(int i=2; i<nums.size(); i++)
            str += ""/"" + to_string(nums[i]);
        str += "")"";
        return str;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector< int > a;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        a.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(a);
    
    // output
    cout << result << ""\n"";

    return 0;
}","math,sort,string",medium
113,"The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.
    For example, ""ACGAATTCCG"" is a DNA sequence.
When studying DNA, it is useful to identify repeated sequences within the DNA.
Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.

solution main function
```cpp
class Solution {
public:
    vector<string> solve(string s) {

    }
};
```

Example 1:
Input: s = ""AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT""
Output: [""AAAAACCCCC"",""CCCCCAAAAA""]

Example 2:
Input: s = ""AAAAAAAAAAAAA""
Output: [""AAAAAAAAAA""]

Constraints:
1 <= s.length <= @data
s[i] is either 'A', 'C', 'G', or 'T'.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[25600, 12800, 7000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
    const int L = 10;
    unordered_map<char, int> bin = {{'A', 0}, {'C', 1}, {'G', 2}, {'T', 3}};
public:
    vector<string> solve(string s) {
        vector<string> ans;
        int n = s.length();
        if (n <= L) {
            return ans;
        }
        int x = 0;
        for (int i = 0; i < L - 1; ++i) {
            x = (x << 2) | bin[s[i]];
        }
        unordered_map<int, int> cnt;
        for (int i = 0; i <= n - L; ++i) {
            x = ((x << 2) | bin[s[i + L - 1]]) & ((1 << (L * 2)) - 1);
            if (++cnt[x] == 2) {
                ans.push_back(s.substr(i, L));
            }
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string str; cin>>str;
    // solve
    Solution solution;
            auto result = solution.solve(str);
    
    // output
    for(auto it:result) cout<<it;
    return 0;
}","string,bit_manipulation",medium
114,"You are given a 0-indexed integer array nums. In one operation, select any non-negative integer x and an index i, then update nums[i] to be equal to nums[i] AND (nums[i] XOR x).

Note that AND is the bitwise AND operation and XOR is the bitwise XOR operation.

Return the maximum possible bitwise XOR of all elements of nums after applying the operation any number of times.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [3,2,4,6]
Output: 7

Example 2:
Input: nums = [1,2,3,9,2]
Output: 11

Constraints:


1 <= nums.length <= @data
0 <= nums[i] <= 10^8


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums) {
        int res=0;
        int n=nums.size();
        for(int i=0;i<n;i++)
        {
            res|=nums[i];
        }
        return res;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","math,other",medium
115,"You are given a string s and two integers x and y. You can perform two types of operations any number of times.

    Remove substring ""ab"" and gain x points.
        For example, when removing ""ab"" from ""cabxbae"" it becomes ""cxbae"".
    Remove substring ""ba"" and gain y points.
        For example, when removing ""ba"" from ""cabxbae"" it becomes ""cabxe"".

Return the maximum points you can gain after applying the above operations on s.

solution main function

```cpp
class Solution {
public:
    int solve(string s, int x, int y) {
        
    }
};
```

Example 1:
Input: s = ""cdbcbbaaabab"", x = 4, y = 5
Output: 19

Example 2:
Input: s = ""aabbaaxybbaabb"", x = 5, y = 4
Output: 20

Constraints:

1 <= s.length <= @data
1 <= x, y <= 10^4
s consists of lowercase English letters.


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(string s, int x, int y) {
        int aCount = 0;
        int bCount = 0;
        int lesser = min(x, y);
        int result = 0;

        for (char c : s) {
            if (c > 'b') {
                result += min(aCount, bCount) * lesser;
                aCount = 0;
                bCount = 0;
            } else if (c == 'a') {
                if (x < y && bCount > 0) {
                    bCount--;
                    result += y;
                } else {
                    aCount++;
                }
            } else {
                if (x > y && aCount > 0) {
                    aCount--;
                    result += x;
                } else {
                    bCount++;
                }
            }
        }

        result += min(aCount, bCount) * lesser;
        return result;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int x,y; string s;
    cin>>x>>y>>s;
    // solve
    Solution solution;
    auto result = solution.solve(s,x,y);
    
    // output
    cout<<result;
    return 0;
}","string,greedy",hard
116,"# Problem Statement
Given a binary string $s$ of length $n$, consisting of characters 0 and 1. Let's build a **square** table of size $n \times n$, consisting of 0 and 1 characters as follows.

In the first row of the table write the original string $s$. In the second row of the table write cyclic shift of the string $s$ by one to the right. In the third row of the table, write the cyclic shift of line $s$ by two to the right. And so on. Thus, the row with number $k$ will contain a cyclic shift of string $s$ by $k$ to the right. The rows **are numbered from $0$ to $n - 1$ top-to-bottom**.

In the resulting table we need to find the rectangle consisting only of ones that has the largest area.

We call a rectangle the set of all cells $(i, j)$ in the table, such that $x_1 \le i \le x_2$ and $y_1 \le j \le y_2$ for some integers $0 \le x_1 \le x_2 < n$ and $0 \le y_1 \le y_2 < n$.

Recall that the cyclic shift of string $s$ by $k$ to the right is the string $s_{n-k+1} \ldots s_n s_1 s_2 \ldots s_{n-k}$. For example, the cyclic shift of the string ""01011"" by $0$ to the right is the string itself ""01011"", its cyclic shift by $3$ to the right is the string ""01101"".

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(string &s) {   
        // write your code here
    }
};
```
where:  
- return value is a 64-bit integer representing the area of the largest rectangle

# Example 1:  
- Input:  
s = ""101"" 
- Output:  
2

# Constraints:  
- $1 \leq s.length \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 3200, 640]]","class Solution
{
public:
    long long solve(string &s)
    {
        int n = s.size();
        if (count(s.begin(), s.end(), '0') == 0)
            return 1LL * n * n;
        s = s + s;
        long long ans = 0;
        for (int i = 0, j; i < n; i++)
        {
            if (s[i] == '1')
            {
                j = i;
                while (s[j] == '1')
                    j++;
                int d = j - i + 1;
                ans = max(ans, 1LL * (d / 2) * (d - d / 2));
                i = j;
            }
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    string s;
    cin >> s;
    // solve
    Solution solution;
    auto result = solution.solve(s);

    // output
    cout << result << ""\n"";

    return 0;
}","two_pointers,math,string",hard
117,"You are given two m x n binary matrices grid1 and grid2 containing only 0's (representing water) and 1's (representing land). An island is a group of 1's connected 4-directionally (horizontal or vertical). Any cells outside of the grid are considered water cells.
An island in grid2 is considered a sub-island if there is an island in grid1 that contains all the cells that make up this island in grid2.
Return the number of islands in grid2 that are considered sub-islands.

solution main function
```cpp
class Solution
{
    public:
    int solve(vector<vector<int>>& grid1, vector<vector<int>>& grid2)
}
```

Example 1:
Inputgrid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
Output: 3

Example 2:
Inputgrid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]
Output: 2

Constraints:
m == grid1.length == grid2.length
n == grid1[i].length == grid2[i].length
1 <= m, n <= @data
grid1[i][j] and grid2[i][j] are either 0 or 1.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 100, 500]",1000.0,"[[6400, 5000, 3000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {
        int m = grid1.size(), n = grid1[0].size();
        int count = 0;

        // Helper function for DFS
        auto dfs = [&](int x, int y, auto& dfs) -> bool {
            // If out of bounds or water in grid2, stop
            if (x < 0 || y < 0 || x >= m || y >= n ) {
                return true;
            }
            if( grid2[x][y] == 0) return true;
            // Mark the cell as visited in grid2
            grid2[x][y] = 0;

            // Check if the current cell is part of a sub-island
            bool isSubIsland = grid1[x][y] == 1;

            // Explore all 4 directions
            isSubIsland &= dfs(x + 1, y, dfs);
            isSubIsland &= dfs(x - 1, y, dfs);
            isSubIsland &= dfs(x, y + 1, dfs);
            isSubIsland &= dfs(x, y - 1, dfs);

            return isSubIsland;
        };

        // Iterate through all cells in grid2
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                // If it's an unvisited land cell in grid2, perform DFS
                if (grid2[i][j] == 1) {
                    if (dfs(i, j, dfs)) {
                        ++count;
                    }
                }
            }
        }

        return count;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m;
    cin>>n>>m;
    vector<vector<int> > g1,g2;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=m;j++)
        {
            int x; cin>>x; 
            temp.push_back(x);
        }
        g1.push_back(temp);
    }
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=m;j++)
        {
            int x; cin>>x; 
            temp.push_back(x);
        }
        g2.push_back(temp);
    }
    // solve
    Solution solution;
            auto result = solution.solve(g1,g2);
    
    // output
    cout<<result;
    return 0;
}","graph,search",medium
118,"You are given a 0-indexed integer array nums.

The effective value of three indices i, j, and k is defined as ((nums[i] | nums[j]) & nums[k]).

The xor-beauty of the array is the XORing of the effective values of all the possible triplets of indices (i, j, k) where 0 <= i, j, k < n.

Return the xor-beauty of nums.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [1,4]
Output: 5

Example 2:
Input: nums = [15,45,20,2,34,35,5,44,32,30]
Output: 34


Constraints:

1 <= nums.length <= @data
1 <= nums[i] <= 10^9

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums) {
        int ans = 0;
        for(int num: nums) ans ^= num;
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",other,medium
119,"You are given an integer array arr. You can choose a set of integers and remove all the occurrences of these integers in the array.
Return the minimum size of the set so that at least half of the integers of the array are removed.

solution main function
```cpp
class Solution
{
    public:
    int solve(vector<int>& arr)
}
```

Example 1:
Inputarr = [3,3,3,3,5,5,5,2,2,7]
Output: 2

Example 2:
Inputarr = [7,7,7,7,7,7]
Output: 1

Constraints:
1 <= arr.length <= @data
arr.length is even.
1 <= arr[i] <= 10^5
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 1000, 10000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& arr) {
        sort(arr.begin(),arr.end());
        vector<int> arr_freq;
        arr_freq.push_back(1);
        int cir_freq = 0;
        for(int i=0;i<arr.size()-1;i++){
            if(arr[i]!=arr[i+1]){
                arr_freq.push_back(1);
                cir_freq++;
            }
            else{
                arr_freq[cir_freq] += 1;
            }
        }
        sort(arr_freq.begin(),arr_freq.end());
        int res = 0;
        int res_size = arr.size();
        for(int i=arr_freq.size()-1;i>=0;i--){
            if(res_size>arr.size()/2){
                res++;
                res_size -= arr_freq[i];
            }
            else{
                break;
            }
        }
        return res;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    cin>>n;
    vector<int> arr;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        arr.push_back(x);
    }
    // solve
    Solution solution;
            auto result = solution.solve(arr);
    
    // output
    cout<<result;

    return 0;
}","greedy,sort,data_structures",medium
120,"# Problem Statement
You are given an array $d_1, d_2, \dots, d_n$ consisting of $n$ integer numbers.

Your task is to split this array into three parts (some of which may be empty) in such a way that each element of the array belongs to exactly one of the three parts, and each of the parts forms a consecutive contiguous subsegment (possibly, empty) of the original array.

Let the sum of elements of the first part be $sum_1$, the sum of elements of the second part be $sum_2$ and the sum of elements of the third part be $sum_3$. Among all possible ways to split the array you have to choose a way such that $sum_1 = sum_3$ and $sum_1$ is maximum possible.

More formally, if the first part of the array contains $a$ elements, the second part of the array contains $b$ elements and the third part contains $c$ elements, then:

$$
sum_1 = \sum\limits_{1 \le i \le a}d_i,
$$
$$
sum_2 = \sum\limits_{a + 1 \le i \le a + b}d_i,
$$
$$
sum_3 = \sum\limits_{a + b + 1 \le i \le a + b + c}d_i.
$$

The sum of an empty array is $0$.

Your task is to find a way to split the array such that $sum_1 = sum_3$ and $sum_1$ is maximum possible.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, vector<int> &d) {
        // write your code here
    }
};
```
where:  
- return:  the maximum possible value of sum1, considering that the condition sum1=sum3 must be met.

# Example 1:  
- Input:  
n = 5
d = [1, 3, 1, 1, 4]
- Output:  
5

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq d[i] \leq 10^6$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(int &n, vector<int> &d)
    {
        int x = 0, y = n - 1;
        long long sumx = 0, sumy = 0;
        long long ans = 0;
        while (x <= y)
        {
            if (sumx < sumy)
                sumx += d[x++];
            else
                sumy += d[y--];
            if (sumx == sumy && sumx > ans)
                ans = sumx;
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","binary,data_structures,two_pointers",medium
121,"Alice and Bob have an undirected graph of n nodes and three types of edges:
    Type 1: Can be traversed by Alice only.
    Type 2: Can be traversed by Bob only.
    Type 3: Can be traversed by both Alice and Bob.
Given an array edges where edges[i] = [typei, ui, vi] represents a bidirectional edge of type typei between nodes ui and vi, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.
Return the maximum number of edges you can remove, or return -1 if Alice and Bob cannot fully traverse the graph.

solution main function
```cpp
class Solution
{
    public:
    int solve(int n, vector<vector<int>>& edges)
}
```
Example 1:
Inputn = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]
Output: 2

Example 2:
Inputn = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]
Output: 0

Constraints:
1 <= n <= @data
1 <= edges.length <= min(105, 3 * n * (n - 1) / 2)
edges[i].length == 3
1 <= typei <= 3
1 <= ui < vi <= n
All tuples (typei, ui, vi) are distinct.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 100, 1000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
int getRoot(vector<int>& par,int x){
        int root = x;
        while(par[root]!=root){
            root = par[root];
        }
        while(par[x]!=root){
            int tmp = par[x];
            par[x] = root;
            x = tmp;
        }
        return root;
    }
    bool merge(vector<int>& par,int x,int y){
        int _x = getRoot(par,x);
        int _y = getRoot(par,y);
        if(_x!=_y){
            par[_x]=_y;
            return true;
        }
        return false;
    }
    int solve(int n, vector<vector<int>>& edges) {
        vector<int>par1 = vector<int>(n+1,0);
        vector<int>par2;
        int ans = 0;
        int cnt1 = n,cnt2;
        for(int i =1;i<=n;i++){
            par1[i] = i;
        }
        for(int i = 0;i<edges.size();i++){
            if(edges[i][0]==3){
                if(!merge(par1,edges[i][1],edges[i][2]))
                    ans++;
                else
                    cnt1--;
            }
        }
        par2 = par1;
        cnt2 = cnt1;
        for(int i = 0;i<edges.size();i++){
            if(edges[i][0]==1){
                if(!merge(par1,edges[i][1],edges[i][2]))
                    ans++;
                else
                    cnt1--;
            }else if(edges[i][0]==2){
                if(!merge(par2,edges[i][1],edges[i][2]))
                    ans++;
                else
                    cnt2--;
            }
        }
        if(cnt1!=1||cnt2!=1)
            return -1;
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m;
    cin>>n>>m;
    vector<vector<int> > e;
    for(int i=1;i<=m;i++)
    {
        int x,y,z; cin>>x>>y>>z;
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        temp.push_back(z);
        e.push_back(temp);
    }
    // solve
    Solution solution;
            auto result = solution.solve(n,e);
    
    // output
    cout<<result;
    return 0;
}","graph,data_structures",medium
122,"You are given an integer array nums and an integer k. You want to find a subsequence of nums of length k that has the largest sum.

Return any such subsequence as an integer array of length k.

A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.

solution main function
```cpp
class Solution {
public:
    vector<int> solve(vector<int>& nums, int k) {
        
    }
};
```

Example 1:
Input: nums = [2,1,3,3], k = 2
Output: [3,3]

Example 2:
Input: nums = [-1,-2,3,4], k = 3
Output: [-1,3,4]

Constraints:

1 <= nums.length <= @data
-10^5 <= nums[i] <= 10^5
1 <= k <= nums.length

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 500, 1000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> solve(vector<int>& nums, int k) {
		// Declare variables
        int n = nums.size(), i = 0, t = k;
		// Answer Array
        vector<int> ans;
		
		// Put first k elements
        while(t>0){
            ans.push_back(nums[i]);
            i++;
            t--;
        }
		
		//Loop Through Remaining Array
        for(int j=i;j<n;j++)
        {
			// Calcualate minimum from ans array 
            int mini = min_element(ans.begin(), ans.end()) - ans.begin();
			// Comapre it with the current element
            if(ans[mini] < nums[j]){
                ans.erase(ans.begin()+mini);
                ans.push_back(nums[j]);
            }
            
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,k;cin>>n>>k;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s,k);
    
    // output
    sort(result.begin(),result.end());
    for(auto it:result) cout<<it<<' ';
    // cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","sort,data_structures,other",easy
123,"You are given an array books where books[i] = [thicknessi, heighti] indicates the thickness and height of the ith book. You are also given an integer shelfWidth.

We want to place these books in order onto bookcase shelves that have a total width shelfWidth.

We choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to shelfWidth, then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.

Note that at each step of the above process, the order of the books we place is the same order as the given sequence of books.

    For example, if we have an ordered list of 5 books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.

Return the minimum possible height that the total bookshelf can be after placing shelves in this manner.

solution main function

```cpp
class Solution {
public:
    int solve(vector<vector<int>>& books, int shelfWidth) {
        
    }
};
```

Example 1:
Input: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelfWidth = 4
Output: 6

Example 2:
Input: books = [[1,3],[2,4],[3,2]], shelfWidth = 6
Output: 4

Constraints:

1 <= books.length <= @data
1 <= thicknessi <= shelfWidth <= 100
1 <= heighti <= 1000

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(std::vector<std::vector<int>> const& books,
                         int const& shelfWidth) {
        std::vector<int> table(books.size() + 1, INT_MAX);
        table[0] = 0; // base case

        for (int i{1}; i <= (int)books.size(); ++i) {
            int total_width{}, mx_height{};

            for (int j{i}; j >= 1; j--) {
                total_width += books[j - 1][0];

                if (total_width > shelfWidth)
                    break;

                mx_height = std::max(mx_height, books[j - 1][1]);
                table[i] = std::min(table[i], mx_height + table[j - 1]);
            }
        }
        return table[books.size()];
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,wid;
    vector<vector<int> > num;
    cin>>n>>wid;
    for(int i=1;i<=n;i++)
    {
        int x,y; cin>>x>>y;
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        num.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num,wid);
    
    // output
    cout<<result;
    return 0;
}",dp,medium
124,"You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique. You are also given an integer k.
For every i and j where 0 <= i < j < arr.length, we consider the fraction arr[i] / arr[j].
Return the kth smallest fraction considered. Return your answer as an array of integers of size 2, where answer[0] == arr[i] and answer[1] == arr[j].

solution main function
```cpp
class Solution {
public:
    vector<int> solve(vector<int>& arr, int k) {

    }
};
```

Example 1:
Input: arr = [1,2,3,5], k = 3
Output: [2,5]

Example 2:
Input: arr = [1,7], k = 1
Output: [1,7]

Constraints:
2 <= arr.length <= @data
1 <= arr[i] <= 2*10^6
arr[0] == 1
arr[i] is a prime number for i > 0.
All the numbers of arr are unique and sorted in strictly increasing order.
1 <= k <= arr.length * (arr.length - 1) / 2
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 1000, 50000]",1000.0,"[[12800, 1280, 128]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> solve(vector<int>& arr, int k) {
        int n = arr.size();
        double left = 0.0, right = 1.0;
        while (true) {
            double mid = (left + right) / 2;
            int i = -1, count = 0;
            int x = 0, y = 1;
            for (int j = 1; j < n; ++j) {
                while ((double)arr[i + 1] / arr[j] < mid) {
                    ++i;
                    if (arr[i] * y > arr[j] * x) {
                        x = arr[i];
                        y = arr[j];
                    }
                }
                count += i + 1;
            }
            if (count == k) {
                return {x, y};
            }
            if (count < k) {
                left = mid;
            }
            else {
                right = mid;
            }
        }
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,k;cin>>n>>k;
    vector<int> num;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
            auto result = solution.solve(num,k);
    
    // output
    for(auto it:result) cout<<it;
    return 0;
}",two_pointers,hard
125,"There exists an infinitely large two-dimensional grid of uncolored unit cells. You are given a positive integer n, indicating that you must do the following routine for n minutes:
    At the first minute, color any arbitrary unit cell blue.
    Every minute thereafter, color blue every uncolored cell that touches a blue cell
Return the number of colored cells at the end of n minutes.

solution main function
```cpp
class Solution {
public:
    long long solve(int n) {

    }
};
```

Example 1:
Input: n = 1
Output: 1

Example 2:
Input: n = 2
Output: 5

Constraints:
1 <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 1000000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    long long solve(int n) {
        return static_cast<long long>(n) * n + static_cast<long long>(n - 1) * (n - 1);
    }
};","#include <bits/stdc++.h>
#include <iterator>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
            auto result = solution.solve(n);
    
    // output
    cout<<result;
    return 0;
}",math,medium
126,"# Problem Statement:
You are given a checkerboard of size $2*n \times 2*n$, i.e. it has $2*n$ rows and $2*n$ columns. The rows of this checkerboard are numbered from $-n$ to $n$ from bottom to top. The columns of this checkerboard are numbered from $-n$ to $n$ from left to right. The notation $(r, c)$ denotes the cell located in the $r$\-th row and the $c$\-th column.

There is a king piece at position $(0, 0)$ and it wants to get to position $(a, b)$ as soon as possible. In this problem our king is lame. Each second, the king makes exactly one of the following five moves.

-   Skip move. King's position remains unchanged.
-   Go up. If the current position of the king is $(r, c)$ he goes to position $(r + 1, c)$.
-   Go down. Position changes from $(r, c)$ to $(r - 1, c)$.
-   Go right. Position changes from $(r, c)$ to $(r, c + 1)$.
-   Go left. Position changes from $(r, c)$ to $(r, c - 1)$.

King is **not allowed** to make moves that put him outside of the board. The important consequence of the king being lame is that he is **not allowed** to make the same move during two consecutive seconds. For example, if the king goes right, the next second he can only skip, go up, down, or left.

What is the minimum number of seconds the lame king needs to reach position $(a, b)$?

The main function of the solution is defined as: 
```cpp
class Solution {
    int solve(int &n, int &a, int &b) {
        // write your code here
    }
};
```
Where:  
- `n` is an integer representing the size of the chessboard.  
- `a` and `b` are integers representing the target position coordinates.  
- The function should return an integer representing the minimum time (in seconds) required for the king to reach the target position.

# Example 1
- Input:  
n = 100  
a = -4  
b = 1  
- Output:  
7

# Constraints:
- $0 < n \leq @data$  
- $-n \leq a \leq n$  
- $-n \leq b \leq n$  
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, int &a, int &b)
    {
        a = abs(a), b = abs(b);
        return min(a, b) * 2 + max(0, 2 * abs(b - a) - 1);
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    int a;
    cin >> a;
    int b;
    cin >> b;
    // solve
    Solution solution;
    auto result = solution.solve(n, a, b);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,math",hard
127,"In class, there are always some classmates who talk to people before and after, which is a headache for the head teacher in primary school. However, the head teacher Xiaoxue found some interesting phenomenon, when the students' seats are determined, only a limited number of $D$to the students will talk to each other in class.
In the classroom, the students sit in the $M$row $N$column, and the students sitting in the $j$column of the $i$row are in the position of $(i,j)$. In order to facilitate students to enter and exit, the classroom is set up a horizontal channel of $K$and a vertical channel of $L$.
So, the clever snow came up with a way that might reduce the problem of students talking to each other in class: she planned to rearrange the tables and chairs and change the position of the passage between the students' desks and chairs, because if a passage separated $2 students who could talk to each other, then they would not talk to each other.
Please help to write a program for Xiaoxue to give the best channel division scheme. Under this scheme, the number of students who talk to each other in class is the lowest.

solution main function
```cpp
class Solution
{
    public:
    pair<vector<int>,vector<int> > solve(int M,int N,int K,int L,int D, vector<vector<int> > &seats)
}
```

Pass in parameters:
5 integers, $M,N,K,L,D$, meaning as shown on the surface.
seats A row of four integers $X_i,Y_i,P_i,Q_i$indicates that two students sitting at $(X_i,Y_i)$and $(P_i,Q_i)$will talk to each other (make sure they are next to each other or next to each other).
The input data ensures the uniqueness of the optimal solution.

Return parameters:
Two vector arrays
The first array contains $K $$a_1 integers, a_2, \ ldots, a_K $, said the first $line a_1 $and $a_1 + 1 $line, between the first $a_2 $, between line and $a_2 + 1 $... A channel is opened between the $a_K$and $a_K+1$lines, where $a_i< a_{i+1}$.
The second array containing $L $$b_1 integers, b_2, \ ldots, b_L $, said the first $b_1 $and $b_1 + 1 $row between, the first $b_2 $and $b_2 + 1 $row between,... A channel is opened between columns $b_L$and $b_L+1$, where $b_i< b_{i+1}$.

Example 1:
Input : M = 4, N = 5, K = 1, L = 2, D = 3 ,seats = [ [4, 2, 4, 3],  [2, 3, 3, 3],  [2, 5, 2, 4] ]
output : [ [ 2],[2, 4] ]  
```  
---

Constraints:
2N,M@data
2D3*@data
0KM,0LN
Time limit: @time_limit ms  
Memory limit: @memory_limit KB","[10, 100, 1000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
    struct A {
        int n, p; 
    };

    static bool cmp(A x, A y) {
        return x.n > y.n;
    }

    static bool cmp1(A x, A y) {
        return x.p < y.p;
    }
public:
    pair<vector<int>, vector<int>> solve(int M, int N, int K, int L, int D, vector<vector<int>>& seats) {
        vector<A> row(M + 1), col(N + 1);
        vector<int> row_divisions, col_divisions;

        for (const auto& edge : seats) {
            int x1 = edge[0], y1 = edge[1], x2 = edge[2], y2 = edge[3];
            if (x1 == x2) {
                int idx = min(y1, y2);
                col[idx].p = idx;
                col[idx].n++;
            } else {
                int idx = min(x1, x2);
                row[idx].p = idx;
                row[idx].n++;
            }
        }

        sort(row.begin() + 1, row.begin() + M + 1, cmp);
        sort(col.begin() + 1, col.begin() + N + 1, cmp);

        sort(row.begin() + 1, row.begin() + K + 1, cmp1); 
        sort(col.begin() + 1, col.begin() + L + 1, cmp1);

        for (int i = 1; i <= K; i++) row_divisions.push_back(row[i].p);
        for (int i = 1; i <= L; i++) col_divisions.push_back(col[i].p);

        return {row_divisions, col_divisions};
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int m,n,k,l,d;
    cin>>m>>n>>k>>l>>d;
    vector<vector<int> > seats;
    for(int i=1;i<=d;i++)
    {
        vector<int> temp;
        for(int j=1,x;j<=4;j++)
        {
            cin>>x;
            temp.push_back(x);
        }
        seats.push_back(temp);
    }
    // solve
    Solution solution;
            pair<vector<int>,vector<int> > result = solution.solve(m,n,k,l,d,seats);
    
    // output
    for(int i=0;i<result.first.size();i++)
    {
        printf(""%d"",result.first[i]);
        if(i==result.first.size()-1) cout<<endl;
        else cout<<' ';
    }
    for(int i=0;i<result.second.size();i++)
    {
        printf(""%d"",result.second[i]);
        if(i==result.second.size()-1);
        else cout<<' ';
    }
    return 0;
}","sort,greedy",hard
128,"n passengers board an airplane with exactly n seats. The first passenger has lost the ticket and picks a seat randomly. But after that, the rest of the passengers will:

    Take their own seat if it is still available, and
    Pick other seats randomly when they find their seat occupied

Return the probability that the nth person gets his own seat.

solution main function
```cpp
class Solution {
public:
    double solve(int n) {
        
    }
};
```

Example 1:
Input: n = 1
Output: 1.00000

Example 2:
Input: n = 2
Output: 0.50000


Constraints:

1 <= n <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 1000000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    double solve(int n) 
    {
        return n == 1 ? 1.0 : 0.5;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
    auto result = solution.solve(n);
    
    // output
    printf(""%.3lf"",result);
    // for(auto it:result) cout<<it<<' ';
    // cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",math,medium
129,"# Problem Statement
Nene invented a new game based on an increasing sequence of integers $a_1, a_2, \ldots, a_k$.

In this game, initially $n$ players are lined up in a row. In each of the rounds of this game, the following happens:

-   Nene finds the $a_1$\-th, $a_2$\-th, $\ldots$, $a_k$\-th players in a row. They are kicked out of the game simultaneously. If the $i$\-th player in a row should be kicked out, but there are fewer than $i$ players in a row, they are skipped.

Once no one is kicked out of the game in some round, all the players that are still in the game are declared as winners.

For example, consider the game with $a=[3, 5]$ and $n=5$ players. Let the players be named player A, player B, $\ldots$, player E in the order they are lined up initially. Then,

-   Before the first round, players are lined up as ABCDE. Nene finds the $3$\-rd and the $5$\-th players in a row. These are players C and E. They are kicked out in the first round.
-   Now players are lined up as ABD. Nene finds the $3$\-rd and the $5$\-th players in a row. The $3$\-rd player is player D and there is no $5$\-th player in a row. Thus, only player D is kicked out in the second round.
-   In the third round, no one is kicked out of the game, so the game ends after this round.
-   Players A and B are declared as the winners.

Nene has not yet decided how many people would join the game initially. Nene gave you $q$ integers $n_1, n_2, \ldots, n_q$ and you should answer the following question for each $1 \le i \le q$ **independently**:

-   How many people would be declared as winners if there are $n_i$ players in the game initially?

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    vector<int> solve(int &k, int &q, vector<int> &a, vector<int> &n) {  
        // write your code here
    }
};
```
where:  
- `k` represents the length of `a`, `q` represents the length of `n`
- `a` represents the increasing sequence of integers, `n` represents the number of players
- return the array of the number of winners for each `n`length is `q`

# Example 1:  
- Input:  
k = 2, q = 1
a = [3, 5]
n = [5]
- Output:  
[2]

# Constraints:  
- $1 \leq k, q \leq @data$
- $1 \leq a[i], b[i] \leq 10^6$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[100, 10000, 100000]",1000.0,"[[6400, 1280, 640]]","class Solution
{
public:
    vector<int> solve(int &k, int &q, vector<int> &a, vector<int> &n)
    {
        int p = a[0];
        vector<int> ans(q);
        for (int i = 0; i < q; i++)
            ans[i] = min(p - 1, n[i]);
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int k, q;
    cin >> k >> q;
    vector<int> a(k), n(q);
    for (int i = 0; i < k; i++)
        cin >> a[i];
    for (int i = 0; i < q; i++)
        cin >> n[i];
    // solve
    Solution solution;
    auto result = solution.solve(k, q, a, n);

    // output
    for (auto &x : result)
        cout << x << "" "";
    cout << ""\n"";
    return 0;
}","greedy,data_structures,binary",hard
130,"You are given an array start where start = [startX, startY] represents your initial position (startX, startY) in a 2D space. You are also given the array target where target = [targetX, targetY] represents your target position (targetX, targetY).

The cost of going from a position (x1, y1) to any other position in the space (x2, y2) is |x2 - x1| + |y2 - y1|.

There are also some special roads. You are given a 2D array specialRoads where specialRoads[i] = [x1i, y1i, x2i, y2i, costi] indicates that the ith special road goes in one direction from (x1i, y1i) to (x2i, y2i) with a cost equal to costi. You can use each special road any number of times.

Return the minimum cost required to go from (startX, startY) to (targetX, targetY).

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {
        
    }
};
```

Example 1:
Input: start = [1,1], target = [4,5], specialRoads = [[1,2,3,3,2],[3,4,4,5,1]]
Output: 5

Example 2:
Input: start = [3,2], target = [5,7], specialRoads = [[5,7,3,2,1],[3,2,3,4,4],[3,3,5,5,5],[3,4,5,6,6]]
Output: 7

Constraints:


start.length == target.length == 2
1 <= startX <= targetX <= 10^5
1 <= startY <= targetY <= 10^5
1 <= specialRoads.length <= @data
specialRoads[i].length == 5
startX <= x1i, x2i <= targetX
startY <= y1i, y2i <= targetY
1 <= costi <= 10^5


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[20, 50, 100]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
// Define a min-heap priority queue to store pairs of distance and index
template<class T> using min_pq = priority_queue<T, vector<T>, greater<T>>;

class Solution {
public:
    
    int solve(vector<int>& start, vector<int>& target, vector<vector<int>>& specialRoads) {
        
        const int INF = 1e9+10;
        int n = specialRoads.size();

        // Initialize the distance of each special road to infinity
        vector<int> d(n, INF);

        // Create a priority queue and push the distance from start to each special road
        min_pq<pair<int, int>> pq;
        for (int i = 0; i < n; i++) {
            d[i] = abs(start[0] - specialRoads[i][0]) + abs(start[1] - specialRoads[i][1]) + specialRoads[i][4];
            pq.push({d[i], i});
        }
        
        // Initialize the answer with the manhattan distance between start and target
        int ans = abs(start[0] - target[0]) + abs(start[1] - target[1]);

        // Continue to search for the shortest path until the priority queue is empty
        while (pq.size()) {
            // Pop the pair with smallest distance
            auto [d_c, c] = pq.top(); pq.pop();

            // If the distance stored in d is not equal to the current distance d_c, skip this node
            if (d_c != d[c]) continue;

            // Update the answer by finding the distance from the current special road to the target
            ans = min(ans, d_c + abs(target[0] - specialRoads[c][2]) + abs(target[1] - specialRoads[c][3]));

            // For each special road that can be reached from the current special road, update its distance
            for (int nxt = 0; nxt < n; nxt++) {
                int w = abs(specialRoads[c][2] - specialRoads[nxt][0]) + abs(specialRoads[c][3] - specialRoads[nxt][1]) + specialRoads[nxt][4];
                if (d_c + w < d[nxt]) {
                    d[nxt] = d_c + w;
                    pq.push({d[nxt], nxt});
                }
            }
        }

        // Return the minimum cost of reaching the target
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int x,y,x2,y2,n;
    cin>>x>>y>>x2>>y2>>n;
    vector<vector<int> > edge;
    vector<int> start; start.push_back(x); start.push_back(y);
    vector<int> targe; targe.push_back(x2); targe.push_back(y2);
    for(int i=1,x,y,z;i<=n;i++)
    {
        vector<int> temp;
        scanf(""%d"",&x);
        scanf(""%d"",&y);
        scanf(""%d"",&z);
        temp.push_back(x);
        temp.push_back(y);
        temp.push_back(z);
        scanf(""%d"",&x);
        scanf(""%d"",&y);
        temp.push_back(x);
        temp.push_back(y);
        edge.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(start,targe,edge);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    printf(""%d"",result);
    return 0;
}","graph,search",medium
131,"# Problem Statement
Let's call a number a binary decimal if it is a positive integer and all digits in its decimal notation are either $0$ or $1$. For example, $1\,010\,111$ is a binary decimal, while $10\,201$ and $787\,788$ are not.

Given a number $n$, you are asked whether or not it is possible to represent $n$ as a product of some (not necessarily distinct) binary decimals.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n) {
        // write your code here
    }
};
```
where:  
- output YES if n can be represented as a product of binary decimals, and NO otherwise.

# Example 1:  
- Input:  
n = 121
- Output: 
YES 


# Constraints:  
- $1 \leq n \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10000, 100000, 1000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(int &n)
    {
        vector<int> a = {10, 11, 100, 101, 110, 111, 1001, 1011, 1101, 1111, 10001, 10011, 10111, 10101, 11101, 11011, 11111, 11001};
        sort(a.rbegin(), a.rend());
        for (auto i : a)
        {
            while (n % i == 0)
            {
                n /= i;
            }
        }
        return n == 1 ? ""YES"" : ""NO"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;

    // solve
    Solution solution;
    auto result = solution.solve(n);

    // output
    cout << result << ""\n"";

    return 0;
}","dp,math",hard
132,"# Problem Statement
A club plans to hold a party and will invite some of its $n$ members. The $n$ members are identified by the numbers $1, 2, \dots, n$. If member $i$ is not invited, the party will gain an unhappiness value of $a_i$.

There are $m$ pairs of friends among the $n$ members. As per tradition, if both people from a friend pair are invited, they will share a cake at the party. The total number of cakes eaten will be equal to the number of pairs of friends such that both members have been invited.

However, the club's oven can only cook two cakes at a time. So, the club demands that the total number of cakes eaten is an even number.

What is the minimum possible total unhappiness value of the party, respecting the constraint that the total number of cakes eaten is even?

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &m, vector<int> &a, vector<pair<int, int>> &p) {
        // write your code here
    }
};
```
where:  
-  `p` represents that p.first and p.second are friends.
- return the minimum unhappiness value.

# Example 1:  
- Input:  
n = 3, m = 1
a = [2, 1, 3]
p = [(1, 3)]
- Output:  
2

# Constraints:  
- $1 \leq n \leq @data$
- $0 \leq m \leq \frac{n(n-1)}{2}$
- $0 \leq a[i] \leq 10^4$
- $1 \leq p[i].first, p[i].second \leq n$
- $p[i].first \neq p[i].second$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 1960, 640]]","class Solution
{
public:
    int solve(int &n, int &m, vector<int> &a, vector<pair<int, int>> &p)
    {
        int ans = 1E9;
        if (m % 2 == 0)
            return 0;
        vector<int> deg(n);
        for (int i = 0; i < m; i++)
        {
            p[i].first--;
            p[i].second--;
            deg[p[i].first]++;
            deg[p[i].second]++;
            ans = min(ans, a[p[i].first] + a[p[i].second]);
        }
        for (int i = 0; i < n; i++)
        {
            if (deg[i] % 2)
                ans = min(ans, a[i]);
        }
        return ans;
    }
};
","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, m;
    cin >> n >> m;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];
    vector<pair<int, int>> p(m);
    for (int i = 0; i < m; i++)
        cin >> p[i].first >> p[i].second;

    // solve
    Solution solution;
    auto result = solution.solve(n, m, a, p);

    // output
    cout << result << ""\n"";

    return 0;
}",graph,hard
133,"# Problem Statement
One day, Vogons wanted to build a new hyperspace highway through a distant system with $n$ planets. The $i$\-th planet is on the orbit $a_i$, there could be multiple planets on the same orbit. It's a pity that all the planets are on the way and need to be destructed.

Vogons have two machines to do that.

-   The first machine in one operation can destroy any planet at cost of $1$ Triganic Pu.
-   The second machine in one operation can destroy all planets on a single orbit in this system at the cost of $c$ Triganic Pus.

Vogons can use each machine as many times as they want.

Vogons are very greedy, so they want to destroy all planets with minimum amount of money spent. Can you help them to know the minimum cost of this project?

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &c, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the minimum cost of destroying all planets.

# Example 1:  
- Input:  
n = 10, c = 1
a = [2, 1, 4, 5, 2, 4, 5, 5, 1, 2]
- Output:  
4

# Constraints:  
- $1 \leq n\leq @data$
- $1 \leq c\leq 10$
- $1 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, int &c, vector<int> &a)
    {
        sort(a.begin(), a.end());
        int ans = 0;
        for (int i = 0; i < a.size(); i++)
        {
            int cnt = 1;
            while (i + 1 < a.size() && a[i] == a[i + 1])
            {
                i++;
                cnt++;
            }
            ans += min(cnt, c);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, c;
    cin >> n >> c;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, c, a);

    // output
    cout << result << ""\n"";

    return 0;
}","sort,greedy",medium
134,"You are given an even integer n. You initially have a permutation perm of size n where perm[i] == i (0-indexed).
In one operation, you will create a new array arr, and for each i:
    If i % 2 == 0, then arr[i] = perm[i / 2].
    If i % 2 == 1, then arr[i] = perm[n / 2 + (i - 1) / 2].
You will then assign arr to perm.
Return the minimum non-zero number of operations you need to perform on perm to return the permutation to its initial value.

solution main function
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

Example 1:
Input: n = 2
Output: 1

Example 2:
Input: n = 4
Output: 2

Constraints:
2 <= n <= @data
n is even.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 1000000]",1000.0,"[[12800, 1280, 128]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(int n) {
        int halfLen = n >> 1;
        int ret = 0;
        int num1Id = 1;
        do{
            if(num1Id < halfLen)
                num1Id <<= 1;
            else    
                num1Id = (num1Id << 1) - n + 1;
            ++ret;
        }while(num1Id != 1);
        return ret;        
    }
};","#include <bits/stdc++.h>
#include <iterator>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
            auto result = solution.solve(n);
    
    // output
    cout<<result;
    return 0;
}",math,hard
135,"# Problem Statement
There is a grid, consisting of $2$ rows and $n$ columns. The rows are numbered from $1$ to $2$ from top to bottom. The columns are numbered from $1$ to $n$ from left to right. Each cell of the grid contains an arrow pointing either to the left or to the right. No arrow points outside the grid.

There is a robot that starts in a cell $(1, 1)$. Every second, the following two actions happen one after another:

1.  Firstly, the robot moves left, right, down or up (**it can't try to go outside the grid, and can't skip a move**);
2.  then it moves along the arrow that is placed in the current cell (the cell it ends up after its move).

Your task is to determine whether the robot can reach the cell $(2, n)$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, string &s1, string &s2) {   
        // write your code here
    }
};
```
where:  
- `s1` is a string of length $n$, representing the directions of the arrows in the first row
- `s2` is a string of length $n$, representing the directions of the arrows in the second row
- return ""YES"" or ""NO""

# Example 1:  
- Input:  
n = 4
s1 ="">><<""
s2 ="">>><""
- Output:  
YES

# Constraints:  
- $1 \leq n \leq @data$
- n is even
- No arrow points outside the grid
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 1280, 64]]","class Solution
{
public:
    string solve(int &n, string &s1, string &s2)
    {
        bool flag = 0;
        for (int i = 0; i < n - 1; i++)
        {
            if (i % 2 == 0 && s2[i] == '<' && s1[i + 1] == '<')
                flag = 1;
            if (i % 2 == 1 && s2[i + 1] == '<' && s1[i] == '<')
                flag = 1;
        }
        return flag ? ""NO"" : ""YES"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    string s1, s2;
    cin >> s1 >> s2;
    // solve
    Solution solution;
    auto result = solution.solve(n, s1, s2);

    // output
    cout << result << ""\n"";

    return 0;
}","dp,graph,search",hard
136,"Given a m x n matrix mat and an integer k, return a matrix answer where each answer[i][j] is the sum of all elements mat[r][c] for:

    i - k <= r <= i + k,
    j - k <= c <= j + k, and
    (r, c) is a valid position in the matrix.


solution main function
```cpp
class Solution {
public:
    vector<vector<int>> solve(vector<vector<int>>& mat, int k) {
        
    }
};
```

Example 1:
Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1
Output: [[12,21,16],[27,45,33],[24,39,28]]

Example 2:
Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2
Output: [[45,45,45],[45,45,45],[45,45,45]]

Constraints:

m == mat.length
n == mat[i].length
1 <= m, n, k <= @data
1 <= mat[i][j] <= 100

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[50, 100, 500]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<vector<int>> solve(vector<vector<int>>& mat, int k) {

    const int h = mat.size(), w = mat[0].size();
    
    vector< vector<int> > integralImg = vector< vector<int> >(h, vector< int >(w, 0) );
    vector< vector<int> > outputImg = vector< vector<int> >(h, vector< int >(w, 0) );
    
    
    // building integral image to speed up block sum computation
    for( int y = 0 ; y < h ; y++){
        int pixelSum = 0;
        
        for( int x = 0 ; x < w ;x++){
            pixelSum += mat[y][x];
            integralImg[y][x] = pixelSum;
            
            if( y > 0 ){ 
                integralImg[y][x] += integralImg[y-1][x];
            }
        }
    }
    
    
    // compute block sum by looking-up integral image
    for( int y = 0 ; y < h ; y++){
        
        const int minRow = max(0, y-k), maxRow = min(h-1, y+k);
        
        for( int x = 0 ; x < w ;x++){
            
            const int minCol = max(0, x-k), maxCol = min(w-1, x+k);
            
            outputImg[y][x] = integralImg[maxRow][maxCol];
            
            if( minRow > 0 ){
                outputImg[y][x] -= integralImg[minRow-1][maxCol];
            }
            
            if( minCol > 0 ){
                outputImg[y][x] -= integralImg[maxRow][minCol-1];
            }
            
            if( (minRow > 0) && (minCol > 0) ){
                outputImg[y][x] += integralImg[minRow-1][minCol-1];
            }
        }
    }
        
    return outputImg;        
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m,k; cin>>n>>m>>k;
    vector<vector<int> > s;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=m;j++)
        {
            int x; cin>>x;
            temp.push_back(x);
        }
        s.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s,k);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    // cout<<result;
    for(auto s:result)
    {
        for(auto it:s)
            printf(""%d "",it);
        putchar('\n');
    }
    return 0;
}","dynamic_programming,other",medium
137,"There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:

    In each step, you will choose any 3 piles of coins (not necessarily consecutive).
    Of your choice, Alice will pick the pile with the maximum number of coins.
    You will pick the next pile with the maximum number of coins.
    Your friend Bob will pick the last pile.
    Repeat until there are no more piles of coins.

Given an array of integers piles where piles[i] is the number of coins in the ith pile.

Return the maximum number of coins that you can have.


solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& piles) {
        
    }
};
```

Example 1:
Input: piles = [2,4,1,2,7,8]
Output: 9

Example 2:
Input: piles = [2,4,5]
Output: 4

Constraints:

3 <= piles.length <= @data
piles.length % 3 == 0
1 <= piles[i] <= 10^4


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& piles) {
        int myCoins = 0;

        sort(piles.begin(), piles.end());

        int l = 0, r = piles.size()-1;
        while(l < r){
            l += 1;
            myCoins += piles[r-1];
            r -= 2;
        }

        return myCoins;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector< int > num;
    for(int i=1,x;i<=n;i++)
    {
        cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    int result = solution.solve(num);
    
    // output
    cout << result << ""\n"";

    return 0;
}","math,greedy",hard
138,"# Problem Statement
Sakurako really loves alternating strings. She calls a string $s$ of lowercase Latin letters an alternating string if characters in the even positions are the same, if characters in the odd positions are the same, and the length of the string is **even**.

For example, the strings 'abab' and 'gg' are alternating, while the strings 'aba' and 'ggwp' are not.

As a good friend, you decided to gift such a string, but you couldn't find one. Luckily, you can perform two types of operations on the string:

1.  Choose an index $i$ and delete the $i$\-th character from the string, which will reduce the length of the string by $1$. This type of operation can be performed **no more than $1$ time**;
2.  Choose an index $i$ and replace $s_i$ with any other letter.

Since you are in a hurry, you need to determine the minimum number of operations required to make the string an alternating one.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, string &s) {
        // write your code here
    }
};
```
where:  
- `n`: the length of the string, `s`: a string of lowercase Latin letters
- return: the minimum number of operations required to make the string an alternating one

# Example 1:  
- Input:  
n = 2
s = ""ca""
- Output:  
0

# Constraints:  
- $1 \leq n \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, string &s)
    {
        int minans = 1000000000;
        for (int j = 0; j < 26; j++)
        {
            for (int t = 0; t < 26; t++)
            {
                int cans = 0;
                for (int i = 0; i < n / 2 * 2; i++)
                {
                    if (i % 2 == 0 && s[i] - 'a' != j)
                        cans++;
                    if (i % 2 == 1 && s[i] - 'a' != t)
                        cans++;
                }
                minans = min(minans, cans);
                if (n % 2 == 0)
                    continue;
                for (int i = n - 2; i > -1; i--)
                {
                    if (i % 2 == 0 && s[i] - 'a' != j)
                        cans--;
                    if (i % 2 == 1 && s[i] - 'a' != t)
                        cans--;
                    if (i % 2 == 0 && s[i + 1] - 'a' != j)
                        cans++;
                    if (i % 2 == 1 && s[i + 1] - 'a' != t)
                        cans++;
                    minans = min(minans, cans);
                }
            }
        }
        if (n % 2 == 0)
            return minans;
        else
            return minans + 1;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    string s;
    cin >> s;
    // solve
    Solution solution;
    auto result = solution.solve(n, s);

    // output
    cout << result << ""\n"";

    return 0;
}","dp,greedy,data_structures,string",hard
139,"You are given a string s. The score of a string is defined as the sum of the absolute difference between the ASCII values of adjacent characters.

Return the score of s.

solution main function
```cpp
class Solution {
public:
    int solve(string s) {
        
    }
};
```

Example 1:
Input: s = ""hello""
Output: 13

Example 2:
Input: s = ""zaz""
Output: 50

Constraints:

2 <= s.length <= @data
s consists only of lowercase English letters.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(string s) {
        int score = 0;
        // Iterate over all indices from 0 to the second-to-last index
        // Calculate and accumulate the absolute difference of ASCII values
        // between adjacent characters
        for (int i = 0; i < s.size() - 1; ++i) {
            score += abs(s[i] - s[i + 1]);
        }
        return score;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string s; cin>>s;
    // solve
    Solution solution;
    auto result = solution.solve(s);
    // output
    cout << result << ""\n"";

    return 0;
}",string,easy
140,"# Problem Statement
Stalin Sort is a humorous sorting algorithm designed to eliminate elements which are out of place instead of bothering to sort them properly, lending itself to an $\mathcal{O}(n)$ time complexity.

It goes as follows: starting from the second element in the array, if it is strictly smaller than the previous element (ignoring those which have already been deleted), then delete it. Continue iterating through the array until it is sorted in non-decreasing order. For example, the array $[1, 4, 2, 3, 6, 5, 5, 7, 7]$ becomes $[1, 4, 6, 7, 7]$ after a Stalin Sort.

We define an array as vulnerable if you can sort it in **non-increasing** order by repeatedly applying a Stalin Sort to **any of its subarrays$^{\text{}}$**, as many times as is needed.

Given an array $a$ of $n$ integers, determine the minimum number of integers which must be removed from the array to make it vulnerable.

$^{\text{}}$An array $a$ is a subarray of an array $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {   
        // write your code here
    }
};
```
where:  
- the return value is the minimum number of integers to be removed to make the array vulnerable

# Example 1:  
- Input:  
n = 7
a = [3, 6, 4, 9, 2, 5, 2]
- Output:  
2

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq 10^9$ 
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[100, 1000, 10000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        int ans = n;
        for (int i = 0; i < n; i++)
        {
            int res = 0;
            for (int j = 0; j < n; j++)
            {
                if (j < i || a[j] > a[i])
                    res++;
            }
            ans = min(ans, res);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",greedy,medium
141,"You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code of length of n and a key k.

To decrypt the code, you must replace every number. All the numbers are replaced simultaneously.

    If k > 0, replace the ith number with the sum of the next k numbers.
    If k < 0, replace the ith number with the sum of the previous k numbers.
    If k == 0, replace the ith number with 0.

As code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1].

Given the circular array code and an integer key k, return the decrypted code to defuse the bomb!

solution main function

```cpp
class Solution {
public:
    vector<int> solve(vector<int>& code, int k) {
        
    }
};
```

Example 1:
Input: code = [5,7,1,4], k = 3
Output: [12,10,16,13]

Example 2:
Input: code = [1,2,3,4], k = 0
Output: [0,0,0,0]

Constraints:

n == code.length
1 <= n <= @data
1 <= code[i] <= @data
-(n - 1) <= k <= n - 1

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> solve(vector<int>& code, int k) {
        

        int n= code.size();
        vector<int>ans(n,0);

        if(k==0) return ans;
        
       int start;
       int end;
       int step;

       if(k>0){
        start=1;
        end=k;
        step=1;
       }
       else{
        start=-1;
        end=k;
        step=-1;

       }

       for(int i=0; i<n; i++){

        int sum=0;
        
        for(int j= start; j!= end+step; j+=step){
           // int idx = (i+j+n)%n;
            sum+= code[(i+j+n)%n];
        }
          ans[i]= sum;
       }

        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,k; cin>>n>>k;
    vector<int> a;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        a.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(a,k);
    // output
    // cout << result << ""\n"";
    for(auto it:result)
        cout<<it<<' ';
    return 0;
}",math,easy
142,"Suppose you have n integers labeled 1 through n. A permutation of those n integers perm (1-indexed) is considered a beautiful arrangement if for every i (1 <= i <= n), either of the following is true:
    perm[i] is divisible by i.
    i is divisible by perm[i].
Given an integer n, return the number of the beautiful arrangements that you can construct.

solution main function
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

Example 1:
Input: n = 2
Output: 2

Example 2:
Input: n = 1
Output: 1

Constraints:
1 <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[5, 10, 15]",1000.0,"[[12800, 1280, 128]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
    bool check[16]={};
    int ans=0;
public:
    int solve(int n)
    {
        dfs(1,n);
        return ans;
    }
    void dfs(int pos,int n)
    {
        if(pos==n+1)
        {
            ans++;
            return;
        }
        for(int i=1;i<=n;i++)
        {
            if(!check[i]&&(pos%i==0||i%pos==0))
            {
                check[i]=true;
                dfs(pos+1,n);
                check[i]=false;
            }
        }

    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
            auto result = solution.solve(n);
    
    // output
    cout<<result;
    return 0;
}",dp,easy
143,"# Problem Statement
During her journey with Kosuke, Sakurako and Kosuke found a valley that can be represented as a matrix of size $n \times n$, where at the intersection of the $i$\-th row and the $j$\-th column is a mountain with a height of $a_{i,j}$. If $a_{i,j} < 0$, then there is a lake there.

Kosuke is very afraid of water, so Sakurako needs to help him:

-   With her magic, she can select a square area of mountains and increase the height of each mountain on the main diagonal of that area by exactly one.

More formally, she can choose a submatrix with the upper left corner located at $(i, j)$ and the lower right corner at $(p, q)$, such that $p-i=q-j$. She can then add one to each element at the intersection of the $(i + k)$\-th row and the $(j + k)$\-th column, for all $k$ such that $0 \le k \le p-i$.

Determine the minimum number of times Sakurako must use her magic so that there are no lakes.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, vector<vector<int>> &a) {   
        // write your code here
    }
};
```
where:  
- the return value is the minimum number of times Sakurako must use her magic, and it is of type long long

# Example 1:  
- Input:  
n = 2
a = [[-1, 2], [3, 0]]
- Output:  
1

# Constraints:  
- $1 \leq n \leq @data$
- $-10^5 \leq a[i][j] \leq 10^5$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 100, 1000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(int &n, vector<vector<int>> &a)
    {
        long long ans = 0;
        for (int i = -n + 1; i <= n - 1; i++)
        {
            int mi = 0;
            for (int j = max(0, i); j < n && j - i < n; j++)
                mi = min(mi, a[j - i][j]);
            ans += mi;
        }
        return -ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<vector<int>> a(n, vector<int>(n));
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cin >> a[i][j];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,dp",hard
144,"There is an integer array perm that is a permutation of the first n positive integers, where n is always odd.

It was encoded into another integer array encoded of length n - 1, such that encoded[i] = perm[i] XOR perm[i + 1]. For example, if perm = [1,3,2], then encoded = [2,1].

Given the encoded array, return the original array perm. It is guaranteed that the answer exists and is unique.

solution main function
```cpp
class Solution {
public:
    vector<int> solve(vector<int>& encoded) {
        
    }
};
```

Example 1:
Input: encoded = [3,1]
Output: [1,2,3]

Example 2:
Input: encoded = [6,5,4,6]
Output: [2,4,1,5,3]


Constraints:

3 <= n < @data
n is odd.
encoded.length == n - 1

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> solve(vector<int>& encoded) {
        int x=0;
        for(int i=1;i<=encoded.size()+1;i++){
            x^=i;
        }
        for(int i=1;i<encoded.size();i+=2){
            x^=encoded[i];
        }
        vector<int>ans(encoded.size()+1);
        ans[0]=x;
        for(int i=1;i<=encoded.size();i++){
            ans[i]=ans[i-1]^encoded[i-1];
    }
                    return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    for(auto it:result) cout<<it<<' ';
    // cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",other,medium
145,"You need to maintain an undirected simple graph. You are required to add and delete an edge, as well as query whether two points are connected.

0: Add an edge. It is guaranteed that it does not exist.
1: Delete an edge. It is guaranteed that it exists.
2: Query whether two points are connected.

n represents the total number of nodes (1-n).

edges[i] = [op, a, b], where op represents the operation, and a and b represent the two points involved in the operation.

For each query with op = 2, Y or N indicate whether the two nodes are connected., store the result in a vector<char> array and return it.

solution main function
```cpp
class Solution
{
    public:
    vector<char> solve(int n, vector<vector<int>>& edges)
    {

    }
}
```

Example 1:
Inputn = 200, edges = [[2,123,127],[0,123,127],[2,123,127],[1,127123],[2,123,127]]
Output: ['N','Y','N']

Constraints:

2 <= n <= @data
edges[i].size ==3

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
class Solution
{
    public:
    struct MDF {
        int l, r, u, v;
    };
    vector<int> qu,qv,fa,siz;
    int  m=0, qC = 1, mC=0;
    map<pair<int, int>, int> t;
    vector<MDF> mdf;
    vector<pair<int &, int>> his;
    vector<char> ans;
    int F(int u) {
        return fa[u] == u ? u : F(fa[u]);
    }
    bool Merge(int u, int v) {
        u = F(u), v = F(v);

        if (u == v)
            return false;

        if (siz[u] < siz[v])
            swap(u, v);

        his.push_back({ siz[u], siz[u] });
        his.push_back({ fa[v], fa[v] });
        siz[u] += siz[v], fa[v] = u;
        return true;
    }
    void Undo() {
        for (int i = 0; i < 2; i++) {
            his.back().first = his.back().second;
            his.pop_back();
        }
    }
    void DFS(int l, int r, vector<MDF> mdf) {
        vector<MDF> ml, mr;
        int mid = (l + r )>> 1, mC = 0;

        for (auto [L, R, u, v] : mdf) {
            if (l >= L && r <= R)
                mC += Merge(u, v);
            else {
                if (L <= mid)
                    ml.push_back({ L, R, u, v });

                if (R > mid)
                    mr.push_back({ L, R, u, v });
            }
        }

        if (l == r) {
            ans.push_back(F(qu[l]) == F(qv[l]) ? 'Y' : 'N');

            while (mC--)
                Undo();

            return;
        }

        DFS(l, mid, ml), DFS(mid + 1, r, mr);

        while (mC--)
            Undo();
    }
    vector<char> solve(int n, vector<vector<int>>& edges)
    {
        int m=edges.size();
        int lim = max(n,m);
        qu.resize(lim+10,0);
        qv.resize(lim+10,0);
        fa.resize(lim+10,0);
        siz.resize(lim+10,0);
        for (int i = 1; i <= n; i++)
            fa[i] = i, siz[i] = 1;
        for(auto it:edges)
        {
            int op=it[0], x=it[1], y=it[2];

            if (x > y)
                swap(x, y);

            if (op == 0)
                t[ { x, y }] = qC;
            else if (op == 1) {
                mdf.push_back({ t[{ x, y }], qC - 1, x, y });
                t.erase({ x, y });
            } else {
                qu[qC] = x, qv[qC] = y;
                qC++;
            }
        }
        
        for (auto [x, y] : t) {
            auto [u, v] = x;
            mdf.push_back({ y, qC - 1, u, v });
        }

        if (qC > 1)
            DFS(1, qC - 1, mdf);
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    vector< vector<int> > edge;
    for(int i=1,x,y,z;i<=m;i++)
    {
        scanf(""%d%d%d"",&x,&y,&z);
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        temp.push_back(z);
        edge.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(n,edge);
    
    // output
    for(auto it:result) cout<<it<<' ';

    return 0;
}",graph,medium
146,"You have a grid of size n x 3 and you want to paint each cell of the grid with exactly one of the three colors: Red, Yellow, or Green while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color).

Given n the number of rows of the grid, return the number of ways you can paint this grid. As the answer may grow large, the answer must be computed modulo 10^9 + 7.

solution main function
```cpp
class Solution {
public:
    int solve(int n) {
        
    }
};
```

Example 1:
Input: n = 1
Output: 12

Example 2:
Input: n = 5000
Output: 30228214

Constraints:

n == grid.length
1 <= n <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
	int solve(int n) {
		long long mod=1e9+7;
		long long twoC=6; // number of ways to paint that the last block painted with two colors
		int threeC=6;// number of ways to paint that the last block painted with three colors
		for(int i=2;i<=n;i++)
		{
		//	If the current form is ABA, which means current block is formed only by two colors, then:
		//  ABA  can become BCB BAB CAC next time with two colors
		//  ABA can also become BAC CAB next time with three colors 
		
		//  If the current form is ABC, which means current block is formed by three colors, then:
        //  ABC can become CAB BCA next time with two colors
        //  ABC can also become BCB BAB next time with three colors
			long long oldTwo=twoC;// store old status
			long long oldThree=threeC;
			twoC=(3ll*oldTwo+2ll*oldThree)%mod;
			threeC=(2ll*oldTwo+2ll*oldThree)%mod;
		}
		return (twoC+threeC)%mod; 
	}
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
    auto result = solution.solve(n);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",dynamic_programming,hard
147,"You are given an integer n and an integer start.

Define an array nums where nums[i] = start + 2 * i (0-indexed) and n == nums.length.

Return the bitwise XOR of all elements of nums.

solution main function
```cpp
class Solution {
public:
    int solve(int n, int start) {
        
    }
};
```

Example 1:
Input: n = 5, start = 0
Output: 8

Example 2:
Input: n = 4, start = 3
Output: 8

Constraints:


1 <= n <= @data
0 <= start <= 1000
n == nums.length


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(int n, int start) {
        int num = start;
        for(int i = 1 ; i < n; i++){
            num = num ^ (start + 2 * i);
        }
        return num;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,start;cin>>n>>start;
    // solve
    Solution solution;
    auto result = solution.solve(n,start);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","greedy,sort",easy
148,"Given a zero-based permutation nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.

A zero-based permutation nums is an array of distinct integers from 0 to nums.length - 1 (inclusive)

solution main function
```cpp
class Solution {
public:
    vector<int> solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [0,2,1,5,3,4]
Output: [0,1,2,4,5,3]

Example 2:
Input: nums = [5,0,1,2,3,4]
Output: [4,5,0,1,2,3]

Constraints:

1 <= nums.length <= @data
0 <= nums[i] < nums.length
The elements in nums are distinct.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> solve(vector<int>& nums) {
        vector<int>answer(nums.size());
        for(int i = 0 ;i<nums.size();i++){
            answer[i] = nums[nums[i]];
        }
        return answer;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    for(auto it:result) cout<<it<<' ';
    // printf(""%d"",result);
    return 0;
}",other,easy
149,"Given an integer n, you must transform it into 0 using the following operations any number of times:

    Change the rightmost (0th) bit in the binary representation of n.
    Change the ith bit in the binary representation of n if the (i-1)th bit is set to 1 and the (i-2)th through 0th bits are set to 0.

Return the minimum number of operations to transform n into 0.

solution main function

```cpp
class Solution {
public:
    int solve(int n) {
        
    }
};
```

Example 1:
Input: n = 3
Output: 2

Example 2:
Input: n = 6
Output: 4

Constraints:

0 <= n <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 1000000, 1000000000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(int n) {
        int ans = n;
        ans ^= ans >> 16;
        ans ^= ans >> 8;
        ans ^= ans >> 4;
        ans ^= ans >> 2;
        ans ^= ans >> 1;
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
    auto result = solution.solve(n);
    // output
    cout << result << ""\n"";
    // for(auto it:result) cout<<it<<' ';
    return 0;
}","dp,bit_manipulation",hard
150,"# Problem Statement
You are given a string $s$ of length $n$. Let's define two operations you can apply on the string:

-   remove the first character of the string;
-   remove the second character of the string.

Your task is to find the number of distinct **non-empty** strings that can be generated by applying the given operations on the initial string any number of times (possibly zero), in any order.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, string &s) {
        // write your code here
    }
};
```
where:  
- return:the number of distinct non-empty strings you can get.

# Example 1:  
- Input:  
n = 5
s = ""aaaaa""
- Output:  
5

# Constraints:  
- $1 \leq n \leq @data$
- $s[i]$ is a lowercase English letter
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, string &s)
    {
        int i, j, ans;
        vector<int> vis(26);
        ans = 0;
        for (i = 0; i < n; i++)
        {
            if (vis[s[i] - 'a'])
                continue;
            vis[s[i] - 'a'] = 1;
            ans += n - i;
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    string s;
    cin >> s;

    // solve
    Solution solution;
    auto result = solution.solve(n, s);

    // output
    cout << result << ""\n"";

    return 0;
}","string,dp,data_structures",hard
151,"You are given a 0-indexed integer array nums of length n.

nums contains a valid split at index i if the following are true:

    The sum of the first i + 1 elements is greater than or equal to the sum of the last n - i - 1 elements.
    There is at least one element to the right of i. That is, 0 <= i < n - 1.

Return the number of valid splits in nums.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [10,4,-8,7]
Output: 2

Example 2:
Input: nums = [2,3,1,0]
Output: 2

Constraints:

2 <= nums.length <= @data
-10^5 <= nums[i] <= 10^5

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums) {
        // Keep track of sum of elements on left and right sides
        long long leftSum = 0, rightSum = 0;

        // Initially all elements are on right side
        for (int num : nums) {
            rightSum += num;
        }

        int count = 0;
        // Try each possible split position
        for (int i = 0; i < nums.size() - 1; i++) {
            // Move current element from right to left side
            leftSum += nums[i];
            rightSum -= nums[i];

            // Check if this creates a valid split
            if (leftSum >= rightSum) {
                count++;
            }
        }

        return count;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    cout << result << ""\n"";

    return 0;
}",math,easy
152,"# Problem Statement
You are given a binary array$^{\dagger}$ of length $n$. You are allowed to perform one operation on it **at most once**. In an operation, you can choose any element and flip it: turn a $0$ into a $1$ or vice-versa.

What is the maximum number of inversions$^{\ddagger}$ the array can have after performing **at most one** operation?

$^\dagger$ A binary array is an array that contains only zeroes and ones.

$^\ddagger$ The number of inversions in an array is the number of pairs of indices $i,j$ such that $i<j$ and $a_i > a_j$.

The main function of the solution is defined as: 
```cpp
class Solution {
public:
    long long solve(int &n, vector<int> &a) {   
        // write your code here
    }
};
```
Where:  
- `n` is an integer representing the length of the array.  
- `a` is a binary array of length $n$.  
- The function should return a 64-bit integer, representing the maximum number of inversions in the array after performing at most one operation.

# Example 1:  
- Input:  
n = 4  
a = [1, 0, 1, 0]
- Output:  
3

# Constraints:  
- $1 \leq n \leq @data$ 
- $0 \leq a_i \leq 1$ 
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(int &n, vector<int> &a)
    {
        long long ans = 0;
        int c0 = 0, c1 = 0;
        int x0 = -1, x1 = -1;
        for (int i = 0; i < n; i++)
        {
            if (a[i] == 0)
            {
                c0++;
                ans += c1;
                if (x0 == -1)
                    x0 = i;
            }
            else
            {
                c1++;
                x1 = i;
            }
        }
        long long res = ans;
        if (x0 != -1)
            ans = max(ans, res + c0 - 1 - x0);
        if (x1 != -1)
            ans = max(ans, res + c1 - 1 - (n - 1 - x1));
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];
    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","data_structures,greedy,math",hard
153,"# Problem Statement
Monocarp has been collecting rare magazines for quite a while, and now he has decided to sell them. He distributed the magazines between $n$ boxes, arranged in a row. The $i$\-th box contains $a_i$ magazines. Some of the boxes are covered with lids, others are not.

Suddenly it started to rain, and now Monocarp has to save as many magazines from the rain as possible. To do this, he can move the lids between boxes as follows: if the $i$\-th box was covered with a lid initially, he can either move the lid from the $i$\-th box to the box $(i-1)$ (if it exists), or keep the lid on the $i$\-th box. You may assume that Monocarp can move the lids instantly at the same moment, and no lid can be moved more than once. If a box will be covered with a lid after Monocarp moves the lids, the magazines in it will be safe from the rain; otherwise they will soak.

You have to calculate the maximum number of magazines Monocarp can save from the rain.

The main function of the solution is defined as: 
```cpp
class Solution {
public:
    int solve(int &n, string &s, vector<int> &a) {   
        // write your code here
    }
};
```
Where:  
- `n` is an integer representing the number of boxes.  
- `s` is a string, where $s[i] = 1$ if the $i$-th box is covered with a lid, and $s[i] = 0$ otherwise.
- `a` is an integer array, where $a[i]$ is the number of magazines in the $i$-th box.
- The function should return an integer, representing the maximum number of magazines Monocarp can save from the rain.

# Example 1
- Input:  
n = 4  
s = ""0111""  
a = [5, 4, 5, 1]
- Output:  
14

# Constraints:
- $1 \leq n \leq @data$  
- $1 \leq a[i] \leq 10^4$  
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, string &s, vector<int> &a)
    {
        for (int i = 0, j = -1; i < n; i++)
        {
            if (s[i] == '0')
                j = i;
            else if (j >= 0 && a[i] < a[j])
            {
                swap(s[i], s[j]);
                j = i;
            }
        }
        int ans = 0;
        for (int i = 0; i < n; i++)
            if (s[i] == '1')
                ans += a[i];
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    string s;
    cin >> s;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, s, a);

    // output
    cout << result << ""\n"";

    return 0;
}","dp,greedy",hard
154,"You are given an integer array banned and two integers n and maxSum. You are choosing some number of integers following the below rules:

    The chosen integers have to be in the range [1, n].
    Each integer can be chosen at most once.
    The chosen integers should not be in the array banned.
    The sum of the chosen integers should not exceed maxSum.

Return the maximum number of integers you can choose following the mentioned rules.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& banned, int n, int maxSum) {
        
    }
};
```

Example 1:
Input: banned = [1,6,5], n = 5, maxSum = 6
Output: 2

Example 2:
Input: banned = [1,2,3,4,5,6,7], n = 8, maxSum = 1
Output: 0

Constraints:


1 <= banned.length <= @data
1 <= banned[i], n <= @data
1 <= maxSum <= @data^2


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& banned, int n, int maxSum) {
        sort(banned.begin(), banned.end());
        int sum = 0, res = 0, it = 0, len = banned.size();

        for (int i = 1; i <= n; i++) {
            if (it < len && banned[it] == i) {
                while (it < len && banned[it] == i) {
                    it++; // Skip banned numbers
                }
            } else {
                sum += i;
                if (sum <= maxSum) {
                    res++;
                } else {
                    return res; // Stop as further numbers will exceed maxSum
                }
            }
        }
        return res;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m,mx; cin>>n>>m>>mx;
    vector<int > s;
    for(int i=1,x;i<=m;i++)
    {
        cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s,n,mx);
    
    // output
    cout<<result;
    return 0;
}","sort,greedy",easy
155,"You are given the array nums consisting of n positive integers. You computed the sum of all non-empty continuous subarrays from the array and then sorted them in non-decreasing order, creating a new array of n * (n + 1) / 2 numbers.

Return the sum of the numbers from index left to index right (indexed from 1), inclusive, in the new array. Since the answer can be a huge number return it modulo 10^9 + 7.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& nums, int n, int left, int right) {
        
    }
};
```


Example 1:
Input: nums = [1,2,3,4], n = 4, left = 1, right = 5
Output: 13 

Example 2:
Input: nums = [1,2,3,4], n = 4, left = 3, right = 4
Output: 6

Constraints:

n == nums.length
1 <= nums.length <= @data
1 <= nums[i] <= 100
1 <= left <= right <= n * (n + 1) / 2

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums, int n, int left, int right) {
        long result =
            (sumOfFirstK(nums, n, right) - sumOfFirstK(nums, n, left - 1)) %
            mod;
        // Ensure non-negative result
        return (result + mod) % mod;
    }

private:
    int mod = 1e9 + 7;
    // Helper function to count subarrays with sum <= target and their total
    // sum.
    pair<int, long long> countAndSum(vector<int>& nums, int n, int target) {
        int count = 0;
        long long currentSum = 0, totalSum = 0, windowSum = 0;
        for (int j = 0, i = 0; j < n; ++j) {
            currentSum += nums[j];
            windowSum += nums[j] * (j - i + 1);
            while (currentSum > target) {
                windowSum -= currentSum;
                currentSum -= nums[i++];
            }
            count += j - i + 1;
            totalSum += windowSum;
        }
        return {count, totalSum};
    }

    // Helper function to find the sum of the first k smallest subarray sums.
    long long sumOfFirstK(vector<int>& nums, int n, int k) {
        int minSum = *min_element(nums.begin(), nums.end());
        int maxSum = accumulate(nums.begin(), nums.end(), 0);
        int left = minSum, right = maxSum;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (countAndSum(nums, n, mid).first >= k)
                right = mid - 1;
            else
                left = mid + 1;
        }
        auto [count, sum] = countAndSum(nums, n, left);
        // There can be more subarrays with the same sum of left.
        return sum - left * (count - k);
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,l,r;
    vector<int> num;
    cin>>n>>l>>r;
    for(int i=1,x;i<=n;i++)
    {
        cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num,n,l,r);
    
    // output
    cout<<result;
    return 0;
}","two_pointers,sort,binary",hard
156,"Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones).

A middleIndex is an index where nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1].

If middleIndex == 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum is considered to be 0.

Return the leftmost middleIndex that satisfies the condition, or -1 if there is no such index.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [2,3,-1,8,4]
Output: 3

Example 2:
Input: nums = [1,-1,4]
Output: 2

Constraints:

1 <= nums.length <= @data
-1000 <= nums[i] <= 1000

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums) {
                int len = nums.size();
        if (len == 1)
            return 0;
        if (len == 0)
            return -1;

        int leftsum = 0;
        int totalsum = accumulate(nums.begin(),nums.end(),0);

        for (int i = 0; i< len; i++){
            int rightsum = totalsum - leftsum - nums[i];

            if (rightsum == leftsum)
                return i;

            leftsum += nums[i];
        }
        return -1;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",other,easy
157,"# Problem Statement
In Berland, a bus consists of a row of $n$ seats numbered from $1$ to $n$. Passengers are advised to always board the bus following these rules:

-   If there are no occupied seats in the bus, a passenger can sit in any free seat;
-   Otherwise, a passenger should sit in any free seat that has at least one occupied neighboring seat. In other words, a passenger can sit in a seat with index $i$ ($1 \le i \le n$) only if at least one of the seats with indices $i-1$ or $i+1$ is occupied.

Today, $n$ passengers boarded the bus. The array $a$ chronologically records the seat numbers they occupied. That is, $a_1$ contains the seat number where the first passenger sat, $a_2$  the seat number where the second passenger sat, and so on.

You know the contents of the array $a$. Determine whether all passengers followed the recommendations.

For example, if $n = 5$, and $a$ = \[$5, 4, 2, 1, 3$\], then the recommendations were not followed, as the $3$\-rd passenger sat in seat number $2$, while the neighboring seats with numbers $1$ and $3$ were free.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, vector<int> &a) {   
        // write your code here
    }
};
```
where:  
- If all passengers followed the recommendations, return ""YES"", otherwise return ""NO""

# Example 1:  
- Input:  
n = 5
a = [5, 4, 2, 1, 3]
- Output:  
NO

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq n$ 
- All seat numbers are unique
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[100, 10000, 1000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(int &n, vector<int> &a)
    {
        int l = a[0], r = a[0];
        bool ok = true;
        for (int i = 1; i < n; i++)
        {
            if (a[i] == l - 1)
                l--;
            else if (a[i] == r + 1)
                r++;
            else
            {
                ok = false;
                break;
            }
        }
        return ok ? ""YES"" : ""NO"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",two_pointers,easy
158,"You are given an integer n.

Each number from 1 to n is grouped according to the sum of its digits.

Return the number of groups that have the largest size.

solution main function
```cpp
class Solution {
public:
    int solve(int n) {
        
    }
};
```

Example 1:
Input: n = 13
Output: 4

Example 2:
Input: n = 2
Output: 2

Constraints:

1 <= n <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 500, 1000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(int n) {
        // map<int, int> m;
        int cnt = 0;
        vector<int> v(40, 0);
        for(int i=1;i<=n;i++){
            int x = i;
            int sum = 0;
            while(x){
                
                sum += x%10;
                x/=10;
            }
            v[sum]++;
        }
        
        int maxi = *max_element(v.begin(), v.end());
        
        for(auto i : v){
            if (i == maxi) cnt++;
        }
        return cnt;
        
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;cin>>n;
    // solve
    Solution solution;
    auto result = solution.solve(n);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","string,other",easy
159,"# Problem Statement
Luca is in front of a row of $n$ trees. The $i$\-th tree has $a_i$ fruit and height $h_i$.

He wants to choose a contiguous subarray of the array $[h_l, h_{l+1}, \dots, h_r]$ such that for each $i$ ($l \leq i < r$), **$h_i$ is divisible$^{\dagger}$ by $h_{i+1}$**. He will collect all the fruit from each of the trees in the subarray (that is, he will collect $a_l + a_{l+1} + \dots + a_r$ fruits). However, if he collects more than $k$ fruits in total, he will get caught.

What is the maximum length of a subarray Luca can choose so he doesn't get caught?

$^{\dagger}$ $x$ is divisible by $y$ if the ratio $\frac{x}{y}$ is an integer.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &k, vector<int> &a, vector<int> &h) {   
        // write your code here
    }
};
```
where:  
- `n` is the number of trees, `k` is the maximum number of fruits
- `a` is the array of fruit numbers, `h` is the array of tree heights
- Return the maximum length

# Example 1:  
- Input:  
n = 5, k = 12
a = [3, 2, 4, 1, 8]
h = [4, 4, 2, 4, 1]
- Output:  
3

# Constraints:  
- $1 \leq n \leq @data$  
- $1 \leq a[i], h[i] \leq 10^3$  
- $1 \leq k \leq 10^9$  
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, int &k, vector<int> &a, vector<int> &h)
    {
        int sum = 0;
        for (int i = 1; i < n; i++)
        {
            a[i] += a[i - 1];
        }
        int ans = 0;
        for (int i = 0, j = 0; i < n; i++)
        {
            if (i && h[i - 1] % h[i] != 0)
                j = i;
            while (a[i] - (j == 0 ? 0 : a[j - 1]) > k)
                j++;
            ans = max(ans, i - j + 1);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, k;
    cin >> n >> k;
    vector<int> a(n), h(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];
    for (int i = 0; i < n; i++)
        cin >> h[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, k, a, h);

    // output
    cout << result << ""\n"";

    return 0;
}","two_pointers,binary,math,dp",medium
160,"Given a positive integer $k$, the sum of all the powers of $k$and a finite number of unequal powers of $k$forms an increasing sequence, for example, when $k = 3$, the sequence is:
$1, 3, 4, 9, 10, 12, 13, \ldots$
(the sequence is actually: $3 ^ 0, 1, 3 ^ ^ 3 ^ 0 + 1, 2, 3 ^ ^ 0 + 3 ^ 2 or 3 ^ 1 + 3 ^ 2, 3 ^ 0 + 3 ^ 2 + 3 ^ 1,... $)
Find the value of the $N$item in this sequence, expressed in $10$.

solution main function
```cpp
class Solution
{
    public:
    long long solve(int k, int n)
}
```

Pass in parameters:
2 integers, $k,N$.

Return parameters:
An integer representing the answer.

Example 1:
Input k=3,N=100
Output: 981

Constraints:
k 15,0 <n@data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[200, 300, 1000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution
{
public:
    long long solve(int k, int n)
    {
        long long sum = 0,base = 1;
        for (int i = 0;i <= 10;i++){
            sum += ((n >> i) & 1) * base;
            base *= k;
        }
        return sum;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int k,N; cin >> k >> N;
    // solve
    Solution solution;
            auto result = solution.solve(k,N);
    
    // output
    cout << result << ""\n"";

    return 0;
}",math,hard
161,"There is an undirected graph consisting of n nodes numbered from 0 to n - 1.  You are given a 0-indexed integer array vals of length n where vals[i] denotes the value of the ith node.

You are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.

A star graph is a subgraph of the given graph having a center node containing 0 or more neighbors.  In other words, it is a subset of edges of the given graph such that there exists a common node for all edges.

The image below shows star graphs with 3 and 4 neighbors respectively, centered at the blue node.

The star sum is the sum of the values of all the nodes present in the star graph.

Given an integer k, return the maximum star sum of a star graph containing at most k edges

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& vals, vector<vector<int>>& edges, int k) {
        
    }
};
```

Example 1:
Input: vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2
Output: 16

Example 2:
Input: vals = [-5], edges = [], k = 0
Output: -5

Constraints:

n == vals.length
1 <= n <= @data
-10^4 <= vals[i] <= 10^4
0 <= edges.length <= min(n * (n - 1) / 2, 10^5)
edges[i].length == 2
0 <= ai, bi <= n - 1
ai != bi
0 <= k <= n - 1

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& vals, vector<vector<int>>& edges, int k) {
        vector<int> adj[vals.size() + 1];
        for (int i = 0; i < edges.size(); i++) {
            adj[edges[i][0]].push_back(vals[edges[i][1]]);
            adj[edges[i][1]].push_back(vals[edges[i][0]]);
        }
        int ans = INT_MIN;
        for (int i = 0; i < vals.size(); i++) {
            int temp = vals[i];
            sort(adj[i].begin(), adj[i].end(), greater<int>());
            for (int j = 0; j < k && j < adj[i].size(); j++) {
                if (adj[i][j] < 0) break;
                temp += adj[i][j];
            }
            ans = max(ans, temp);
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m,k; cin>>n>>m;
    vector<vector<int> > edge;
    vector< int > val;
    for(int i=1,x,y,z;i<=m;i++)
    {
        scanf(""%d"",&x);
        scanf(""%d"",&y);
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        edge.push_back(temp);
    }
    cin>>k;
    for(int i=1,x;i<=n;i++)
    {
        scanf(""%d"",&x);
        val.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(val,edge,k);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    printf(""%d"",result);
    return 0;
}","graph,search",medium
162,"# Problem Statement:
The score of a sequence $[s_1, s_2, \ldots, s_d]$ is defined as $\displaystyle \frac{s_1\cdot s_2\cdot \ldots \cdot s_d}{d!}$, where $d!=1\cdot 2\cdot \ldots \cdot d$. In particular, the score of an empty sequence is $1$.

For a sequence $[s_1, s_2, \ldots, s_d]$, let $m$ be the maximum score among all its subsequences. Its cost is defined as the maximum length of a subsequence with a score of $m$.

You are given a **non-decreasing** sequence $[a_1, a_2, \ldots, a_n]$ of integers of length $n$. In other words, the condition $a_1 \leq a_2 \leq \ldots \leq a_n$ is satisfied. For each $k=1, 2, \ldots , n$, find the cost of the sequence $[a_1, a_2, \ldots , a_k]$.

A sequence $x$ is a subsequence of a sequence $y$ if $x$ can be obtained from $y$ by deletion of several (possibly, zero or all) elements.

The main function of the solution is defined as: 
```cpp
class Solution {
public:
    vector<int> solve(int &n, vector<int> &a) {   
        // write your code here
    }
};
```
Where:  
- `n` is an integer representing the size of the array.  
- `a` is a vector of integers, representing the given non-decreasing array.  
- The function should return a vector of integers, where the k-th element represents the cost of the subsequence $[a_1, a_2, \ldots, a_k]$.

# Example 1:
- Input:  
n = 3  
a = [1, 2, 3]
- Output:  
[1, 1, 2]

# Constraints:
- $1 \leq n \leq @data$  
- $1 \leq a_i \leq n$  
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB","[10, 1000, 100000]",1000.0,"[[6400, 1280, 640]]","class Solution
{
public:
    vector<int> solve(int &n, vector<int> &a)
    {
        vector<int> ans;
        for (int i = 0, k = 0; i < n; i++)
        {
            while (k <= i && a[i - k] >= k + 1)
                k += 1;
            ans.push_back(k);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];
    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    for (auto x : result)
        cout << x << "" "";
    cout << ""\n"";

    return 0;
}","two_pointers,binary,math",hard
163,"You want to water n plants in your garden with a watering can. The plants are arranged in a row and are labeled from 0 to n - 1 from left to right where the ith plant is located at x = i. There is a river at x = -1 that you can refill your watering can at.

Each plant needs a specific amount of water. You will water the plants in the following way:

    Water the plants in order from left to right.
    After watering the current plant, if you do not have enough water to completely water the next plant, return to the river to fully refill the watering can.
    You cannot refill the watering can early.

You are initially at the river (i.e., x = -1). It takes one step to move one unit on the x-axis.

Given a 0-indexed integer array plants of n integers, where plants[i] is the amount of water the ith plant needs, and an integer capacity representing the watering can capacity, return the number of steps needed to water all the plants.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& plants, int capacity) {
        
    }
};
```

Example 1:
Input: plants = [2,2,3,3], capacity = 5
Output: 14

Example 2:
Input: plants = [1,1,1,4,2,3], capacity = 4
Output: 30

Constraints:

n == plants.length
1 <= n <= @data
1 <= plants[i] <= 10^6
max(plants[i]) <= capacity <= 10^9

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& p, int capacity) {
        int ans=0,c=capacity;
        for(int i=0;i<p.size();i++){
            if(c>=p[i])
                ans++;  // if you have enough water then water the plant and it will cost 1 step from previous plant.
            else{
                ans+=i; // if you don't have enough water then go back from previous plant and fill the container 
                ans+=i+1; // and come to the current plant.
                c=capacity;
            }
             c=c-p[i]; // water the plant and move to the next one.
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s,m);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",other,medium
164,"# Problem Statement
You are given an array $a$ of $n$ elements $a_1, a_2, \ldots, a_n$.

You can perform the following operation any number (possibly $0$) of times:

-   Choose two integers $i$ and $j$, where $1 \le i, j \le n$, and assign $a_i := a_j$.

Find the minimum number of operations required to make the array $a$ satisfy the condition:

-   For every pairwise distinct triplet of indices $(x, y, z)$ ($1 \le x, y, z \le n$, $x \ne y$, $y \ne z$, $x \ne z$), there exists a non-degenerate triangle with side lengths $a_x$, $a_y$ and $a_z$, i.e. $a_x + a_y &gt; a_z$, $a_y + a_z &gt; a_x$ and $a_z + a_x &gt; a_y$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return:  the minimum number of operations required.

# Example 1:  
- Input:  
n = 7
a = [1, 2, 3, 4, 5, 6, 7]
- Output:  
3


# Constraints:  
- $3 \leq n \leq @data$
- $1 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        sort(a.begin(), a.end());
        int ans = n - 1;
        for (int i = 1; i < n; i++)
        {
            int pos = lower_bound(a.begin(), a.end(), a[i] + a[i - 1]) - a.begin();
            ans = min(ans, i - 1 + n - pos);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","binary,sort,math,two_pointers",hard
165,"# Problem Statement
You are given a binary string$^{\dagger}$. Please find the minimum number of pieces you need to cut it into, so that the resulting pieces can be rearranged into a sorted binary string.

Note that:

-   each character must lie in exactly one of the pieces;
-   the pieces must be contiguous substrings of the original string;
-   you must use all the pieces in the rearrangement.

$^{\dagger}$ A binary string is a string consisting of characters $\texttt{0}$ and $\texttt{1}$. A sorted binary string is a binary string such that all characters $\texttt{0}$ come before all characters $\texttt{1}$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(string &s) {
        // write your code here
    }
};
```
where:  
- return: the minimum number of pieces needed to be able to rearrange the string into a sorted binary string.

# Example 1:  
- Input:  
s = ""11010""
- Output:  
3

# Constraints:  
- $1 \leq s.length \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(string &s)
    {
        int cnt = 1, cnt2 = 0;
        for (int i = 1; i < s.size(); i++)
            if (s[i] == '0' && s[i - 1] == '1')
                cnt++;
            else if (s[i] == '1' && s[i - 1] == '0')
                cnt2++;
        if (cnt2)
            cnt2--;
        return cnt + cnt2;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    string s;
    cin >> s;

    // solve
    Solution solution;
    auto result = solution.solve(s);

    // output
    cout << result << ""\n"";

    return 0;
}","do,sort,string",hard
166,"You are given a string s consisting of lowercase English letters, and an integer k. Your task is to convert the string into an integer by a special process, and then transform it by summing its digits repeatedly k times. More specifically, perform the following steps:

    Convert s into an integer by replacing each letter with its position in the alphabet (i.e. replace 'a' with 1, 'b' with 2, ..., 'z' with 26).
    Transform the integer by replacing it with the sum of its digits.
    Repeat the transform operation (step 2) k times in total.

For example, if s = ""zbax"" and k = 2, then the resulting integer would be 8 by the following operations:

    Convert: ""zbax""  ""(26)(2)(1)(24)""  ""262124""  262124
    Transform #1: 262124  2 + 6 + 2 + 1 + 2 + 4  17
    Transform #2: 17  1 + 7  8

Return the resulting integer after performing the operations described above.

solution main function

```cpp
class Solution {
public:
    int solve(string s, int k) {
        
    }
};
```

Example 1:
Input: s = ""iiii"", k = 1
Output: 36

Example 2:
Input: s = ""leetcode"", k = 2
Output: 6

Constraints:

1 <= s.length <= @data
1 <= k <= 10
s consists of lowercase English letters.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(string s, int k) {
        // Convert the string to a number by summing digit values
        int currentNumber = 0;
        for (char ch : s) {
            int position = ch - 'a' + 1;
            while (position > 0) {
                currentNumber += position % 10;
                position /= 10;
            }
        }

        // Apply digit sum transformations k-1 times
        for (int i = 1; i < k; ++i) {
            int digitSum = 0;
            while (currentNumber > 0) {
                digitSum += currentNumber % 10;
                currentNumber /= 10;
            }
            currentNumber = digitSum;

            // Break early if the current number becomes less than 10
            if (currentNumber < 10) {
                break;
            }
        }

        return currentNumber;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int k; string s;
    cin>>k>>s;
    // solve
    Solution solution;
    auto result = solution.solve(s,k);
    
    // output
    cout<<result;
    return 0;
}",string,easy
167,"You are given a directed graph with n nodes labeled from 0 to n - 1, where each node has exactly one outgoing edge.

The graph is represented by a given 0-indexed integer array edges of length n, where edges[i] indicates that there is a directed edge from node i to node edges[i].

The edge score of a node i is defined as the sum of the labels of all the nodes that have an edge pointing to i.

Return the node with the highest edge score. If multiple nodes have the same edge score, return the node with the smallest index.
solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& edges) {
        
    }
};
```

Example 1:
Input: edges = [1,0,0,0,0,7,7,5]
Output: 7

Example 2:
Input: edges = [2,0,0,2]
Output: 0

Constraints:


n == edges.length
2 <= n <= @data
0 <= edges[i] < n
edges[i] != i

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& edges) {
        ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);     using ll=long long;
        vector<ll> score(edges.size(),0);
        ll maxi=0;
        int val=INT_MAX;
        for (int i=0;i<edges.size();i++){
            score[edges[i]]+=i;
        }
        for (int i=0;i<edges.size();i++){
            if (score[i]>maxi){
                val=i;
                maxi=score[i];
            }
        }
        // for (auto i:score){
        //     cout<<i<<"" "";
        // }
        return val;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector< int > edge;
    for(int i=1,x,y,z;i<=n;i++)
    {
        scanf(""%d"",&x);
        edge.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(edge);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    printf(""%d"",result);
    return 0;
}",graph,medium
168,"You are given a string s consisting only of uppercase English letters.

You can apply some operations to this string where, in one operation, you can remove any occurrence of one of the substrings ""AB"" or ""CD"" from s.

Return the minimum possible length of the resulting string that you can obtain.

Note that the string concatenates after removing the substring and could produce new ""AB"" or ""CD"" substrings.

solution main function

```cpp
class Solution {
public:
    int solve(string s) {
        
    }
};
```

Example 1:
Input: s = ""ABFCACDB""
Output: 2

Example 2:
Input: s = ""ACBBD""
Output: 5

Constraints:

1 <= s.length <= @data
s consists only of uppercase English letters.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(string s) {
        int writePtr = 0;
        vector<char> charArray(s.begin(), s.end());

        // Iterate over each character in the string
        for (int readPtr = 0; readPtr < s.length(); readPtr++) {
            // Write the current character to the current write position
            charArray[writePtr] = charArray[readPtr];

            // Check if we have a valid pattern to remove
            if (writePtr > 0 &&
                (charArray[writePtr - 1] == 'A' ||
                 charArray[writePtr - 1] == 'C') &&
                charArray[writePtr] == charArray[writePtr - 1] + 1) {
                writePtr--;
            } else {
                writePtr++;  // No match, so move the write pointer forward
            }
        }

        // The writePtr now represents the length of the remaining string
        return writePtr;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string s; cin>>s;
    // solve
    Solution solution;
    auto result = solution.solve(s);
    // output
    cout << result << ""\n"";
    // for(auto it:result) cout<<it<<' ';
    return 0;
}",string,easy
169,"You are given two strings start and target, both of length n. Each string consists only of the characters 'L', 'R', and '_' where:

    The characters 'L' and 'R' represent pieces, where a piece 'L' can move to the left only if there is a blank space directly to its left, and a piece 'R' can move to the right only if there is a blank space directly to its right.
    The character '_' represents a blank space that can be occupied by any of the 'L' or 'R' pieces.

Return true if it is possible to obtain the string target by moving the pieces of the string start any number of times. Otherwise, return false.

solution main function

```cpp
class Solution {
public:
    bool solve(string start, string target) {
        
    }
};
```

Example 1:
Input: start = ""_L__R__R_"", target = ""L______RR""
Output: true

Example 2:
Input: start = ""R_L_"", target = ""__LR""
Output: false

Constraints:

n == start.length == target.length
1 <= n <= @data
start and target consist of the characters 'L', 'R', and '_'.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 150]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    bool solve(string start, string target) {
        int startLength = start.size();
        // Pointer for start string and target string
        int startIndex = 0, targetIndex = 0;

        while (startIndex < startLength || targetIndex < startLength) {
            // Skip underscores in start
            while (startIndex < startLength && start[startIndex] == '_') {
                startIndex++;
            }
            // Skip underscores in target
            while (targetIndex < startLength && target[targetIndex] == '_') {
                targetIndex++;
            }
            // If one string is exhausted, both should be exhausted
            if (startIndex == startLength || targetIndex == startLength) {
                return startIndex == startLength && targetIndex == startLength;
            }

            // Check if the pieces match and follow movement rules
            if (start[startIndex] != target[targetIndex] ||
                (start[startIndex] == 'L' && startIndex < targetIndex) ||
                (start[startIndex] == 'R' && startIndex > targetIndex))
                return false;

            startIndex++;
            targetIndex++;
        }

        // If all conditions are satisfied, return true
        return true;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string a,b;
    cin>>a>>b;
    // solve
    Solution solution;
    int result = solution.solve(a,b);
    
    // output
    cout << result << ""\n"";

    return 0;
}","two_pointers,string",medium
170,"A 0-indexed array derived with length n is derived by computing the bitwise XOR () of adjacent values in a binary array original of length n.

Specifically, for each index i in the range [0, n - 1]:

    If i = n - 1, then derived[i] = original[i]  original[0].
    Otherwise, derived[i] = original[i]  original[i + 1].

Given an array derived, your task is to determine whether there exists a valid binary array original that could have formed derived.

Return true if such an array exists or false otherwise.

    A binary array is an array containing only 0's and 1's


solution main function
```cpp
class Solution {
public:
    bool solve(vector<int>& derived) {
        
    }
};
```

Example 1:
Input: derived = [1,1,0]
Output: true

Example 2:
Input: derived = [1,1]
Output: true

Constraints:

n == derived.length
2 <= n <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    bool solve(vector<int>& derived) {
        int sum = accumulate(derived.begin(), derived.end(), 0);
        return sum % 2 == 0;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector< int > num;
    for(int i=1,x;i<=n;i++)
    {
        cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    int result = solution.solve(num);
    
    // output
    cout << result << ""\n"";

    return 0;
}",bit_manipulation,medium
171,"There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line.

You are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i].

Each person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line (which happens instantaneously) in order to buy more tickets. If a person does not have any tickets left to buy, the person will leave the line.

Return the time taken for the person initially at position k (0-indexed) to finish buying tickets.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& tickets, int k) {
        
    }
};
```

Example 1:
Input: tickets = [2,3,2], k = 2
Output: 6

Example 2:
Input: tickets = [5,1,1,1], k = 0
Output: 8

Constraints:

n == tickets.length
1 <= n <= @data
1 <= tickets[i] <= 100
0 <= k < n

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 10000, 100000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& tickets, int k) {
        int time = 0;
        
        for (int i = 0; i < tickets.size(); i++) {
            // If the current person is before or at the desired person 'k'
            if (i <= k) {
                // Buy the minimum of tickets available at person 'k' and the current person
                time += min(tickets[k], tickets[i]);
            } else {
                // If the current person is after 'k', buy the minimum of 
                // (tickets available at person 'k' - 1) and the current person
                time += min(tickets[k] - 1, tickets[i]);
            }
        }
        
        return time;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,k;
    vector<int> num;
    cin>>n>>k;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num,k);
    
    // output
    cout<<result;
    return 0;
}",data_structures,easy
172,"You are given a string s consisting only of characters 'a' and 'b'.

You can delete any number of characters in s to make s balanced. s is balanced if there is no pair of indices (i,j) such that i < j and s[i] = 'b' and s[j]= 'a'.

Return the minimum number of deletions needed to make s balanced.

solution main function

```cpp
class Solution {
public:
    int solve(string s) {
        
    }
};
```

Example 1:
Input: s = ""aababbab""
Output: 2

Example 2:
Input: s = ""bbaaaaabb""
Output: 2

Constraints:

1 <= s.length <= @data
s[i] is 'a' or 'b'.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(string s) {
        int n = s.length();
        int min_deletions = 0;
        int b_count = 0;

        // min_deletions variable represents dp[i]
        for (int i = 0; i < n; i++) {
            if (s[i] == 'b') {
                b_count++;
            } else {
                // Two cases: remove 'a' or keep 'a'
                min_deletions = min(min_deletions + 1, b_count);
            }
        }

        return min_deletions;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string s; cin>>s;
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    cout<<result;
    return 0;
}","two_pointers,string",medium
173,"You are given a string s.

You can perform the following process on s any number of times:

    Choose an index i in the string such that there is at least one character to the left of index i that is equal to s[i], and at least one character to the right that is also equal to s[i].
    Delete the closest character to the left of index i that is equal to s[i].
    Delete the closest character to the right of index i that is equal to s[i].

Return the minimum length of the final string s that you can achieve.

solution main function

```cpp
class Solution {
public:
    int solve(string s) {
        
    }
};
```

Example 1:
Input: s = ""abaacbcbb""
Output: 5

Example 2:
Input: s = ""aa""
Output: 2

Constraints:

1 <= s.length <= @data
s consists only of lowercase English letters

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(string s) {
        // Step 1: Initialize a frequency array to count occurrences of each
        // character
        vector<int> charFrequency(26, 0);
        int totalLength = 0;

        // Step 2: Count the frequency of each character in the string
        for (char currentChar : s) {
            charFrequency[currentChar - 'a']++;
        }

        // Step 3: Calculate the total length after deletions count
        for (int frequency : charFrequency) {
            if (frequency == 0) continue;  // Skip characters that don't appear
            if (frequency % 2 == 0) {
                totalLength += 2;  // If frequency is even, add 2
            } else {
                totalLength += 1;  // If frequency is odd, add 1
            }
        }

        // Step 4: Return the minimum length after deletions count
        return totalLength;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string str; cin>>str;
    // solve
    Solution solution;
    auto result = solution.solve(str);
    // output
    cout << result << ""\n"";
    // for(auto it:result) cout<<it<<' ';
    return 0;
}",string,hard
174,"# Problem Statement
You are given a string $s$ of length $n &gt; 1$, consisting of digits from $0$ to $9$. You must insert exactly $n - 2$ symbols $+$ (addition) or $\times$ (multiplication) into this string to form a valid arithmetic expression.

In this problem, the symbols cannot be placed before the first or after the last character of the string $s$, and two symbols cannot be written consecutively. Also, note that the order of the digits in the string cannot be changed. Let's consider $s = 987009$:

-   From this string, the following arithmetic expressions can be obtained: $9 \times 8 + 70 \times 0 + 9 = 81$, $98 \times 7 \times 0 + 0 \times 9 = 0$, $9 + 8 + 7 + 0 + 09 = 9 + 8 + 7 + 0 + 9 = 33$. Note that the number $09$ is considered valid and is simply transformed into $9$.
-   From this string, the following arithmetic expressions cannot be obtained: $+9 \times 8 \times 70 + 09$ (symbols should only be placed between digits), $98 \times 70 + 0 + 9$ (since there are $6$ digits, there must be exactly $4$ symbols).

The result of the arithmetic expression is calculated according to the rules of mathematics first all multiplication operations are performed, then addition. You need to find the minimum result that can be obtained by inserting exactly $n - 2$ addition or multiplication symbols into the given string $s$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, string &s) {
        // write your code here
    }
};
```
where:  
- output the minimum result of the arithmetic expression that can be obtained by inserting exactly n2 addition or multiplication symbols into the given string.

# Example 1:  
- Input:  
n = 2
s = ""10""
- Output:
10  


# Constraints:  
- $2 \leq n \leq @data$
- $s[i] \in [0, 9]$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, string &s)
    {
        int cnt[2] = {};
        int sum = 0;
        for (auto c : s)
        {
            sum += c - '0';
            if (c <= '1')
            {
                cnt[c - '0']++;
            }
        }
        sum -= s[0] - '0';
        if (s[0] <= '1')
        {
            cnt[s[0] - '0']--;
        }
        int ans = 1E9;
        for (int i = 0; i <= n - 2; i++)
        {
            sum -= s[i + 1] - '0';
            if (s[i + 1] <= '1')
            {
                cnt[s[i + 1] - '0']--;
            }

            int v = std::stoi(s.substr(i, 2));
            sum += v;
            if (v <= 1)
            {
                cnt[v]++;
            }

            int res;
            if (cnt[0] > 0)
            {
                res = 0;
            }
            else
            {
                res = std::max(1, sum - cnt[1]);
            }
            ans = std::min(ans, res);

            sum -= v;
            if (v <= 1)
            {
                cnt[v]--;
            }

            sum += s[i] - '0';
            if (s[i] <= '1')
            {
                cnt[s[i] - '0']++;
            }
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    string s;
    cin >> s;

    // solve
    Solution solution;
    auto result = solution.solve(n, s);

    // output
    cout << result << ""\n"";

    return 0;
}",dp,hard
175,"You are given two identical eggs and you have access to a building with n floors labeled from 1 to n.
You know that there exists a floor f where 0 <= f <= n such that any egg dropped at a floor higher than f will break, and any egg dropped at or below floor f will not break.
In each move, you may take an unbroken egg and drop it from any floor x (where 1 <= x <= n). If the egg breaks, you can no longer use it. However, if the egg does not break, you may reuse it in future moves.
Return the minimum number of moves that you need to determine with certainty what the value of f is.

solution main function
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

Example 1:
Input: n = 2
Output: 2

Example 2:
Input: n = 100
Output: 14

Constraints:
1 <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 1000000]",1000.0,"[[12800, 1280, 128]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(int n) {
        int tmp = sqrt(2*n);
        if(tmp * (tmp + 1) >= 2 * n){return tmp;}
        return tmp + 1;
    }
};","#include <bits/stdc++.h>
#include <iterator>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
            auto result = solution.solve(n);
    
    // output
    cout<<result;
    return 0;
}","dp,math",medium
176,"You are given an integer array values where values[i] represents the value of the ith sightseeing spot. Two sightseeing spots i and j have a distance j - i between them.

The score of a pair (i < j) of sightseeing spots is values[i] + values[j] + i - j: the sum of the values of the sightseeing spots, minus the distance between them.

Return the maximum score of a pair of sightseeing spots.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& values) {
        
    }
};
```

Example 1:
Input: values = [8,1,5,2,6]
Output: 11

Example 2:
Input: values = [1,2]
Output: 2

Constraints:

2 <= values.length <= @data
1 <= values[i] <= 1000

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& values) {
        int n = values.size();

        // The left score is initially just the value of the first element.
        int maxLeftScore = values[0];

        int maxScore = 0;

        for (int i = 1; i < n; i++) {
            int currentRightScore = values[i] - i;
            // Update the maximum score by combining the best left score so far
            // with the current right score.
            maxScore = max(maxScore, maxLeftScore + currentRightScore);

            int currentLeftScore = values[i] + i;
            // Update the maximum left score up to the current index.
            maxLeftScore = max(maxLeftScore, currentLeftScore);
        }

        return maxScore;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector< int > a;
    for(int i=1,x;i<=n;i++)
    {
        cin>>x;
        a.push_back(x);
    }
    // solve
    Solution solution;
    int result = solution.solve(a);
    
    // output
    cout << result << ""\n"";

    return 0;
}",greedy,easy
177,"Given a connected undirected graph \( G \) with \( n \) nodes and \( m \) edges, where all nodes are numbered from 1 to \( n \).

Find the sum of the edge weights of the minimum spanning tree of \( G \).

The edges are represented as \( edges[i] = [a, b, c] \), indicating that there is an edge between nodes \( a \) and \( b \) with a weight of \( c \).

solution main function
```cpp
class Solution
{
    public:
    long long solve(int n, vector<vector<int>>& edges)
    {

    }
}
```

Example 1:
Inputn = 7, edges = [[1,2,9],[1,5,2],[1,6,3],[2,3,5],[2,6,7],[3,4,6],[3,7,3],[4,5,6],[4,7,2],[5,6,3],[5,7,6],[6,7,1]]
Output: 16

Constraints:

2 <= n <= @data
edges[i].size ==3

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

class Solution
{
    public:
    int n=0, m=0, fa1=0, fa2=0, k=0;
    struct node {
        int u, v, w;
        bool operator <(const node &a) const {
            return w < a.w;
        }
    };
    int find(int x) {
        if (x == fa[x])
            return x;

        return fa[x] = find(fa[x]);
    }
    vector<node> edge;
    vector<int> fa;
    long long ans=0;
    long long solve(int N, vector<vector<int>>& edges)
    {
        n=N; m=edges.size();
        // edge.resize(m+1,{0,0,0});
        fa.resize(n+10,0);
        for(int i=1;i<=n;i++)
            fa[i]=i;
        for (int i = 1; i <= m; i++)
            edge.push_back({edges[i-1][0],edges[i-1][1],edges[i-1][2]});

        sort(edge.begin(), edge.end());

        for (int i = 0; i < m; i++) {
            fa1 = find(edge[i].u);
            fa2 = find(edge[i].v);

            if (fa1 == fa2)
                continue;

            fa[fa1] = fa2;
            ans += edge[i].w;
            k++;

            if (k == n - 1)
                break;
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    vector< vector<int> > edge;
    for(int i=1,x,y,z;i<=m;i++)
    {
        scanf(""%d%d%d"",&x,&y,&z);
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        temp.push_back(z);
        edge.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(n,edge);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    printf(""%lld"",result);
    return 0;
}",graph,medium
178,"You are given two integers numBottles and numExchange.

numBottles represents the number of full water bottles that you initially have. In one operation, you can perform one of the following operations:

    Drink any number of full water bottles turning them into empty bottles.
    Exchange numExchange empty bottles with one full water bottle. Then, increase numExchange by one.

Note that you cannot exchange multiple batches of empty bottles for the same value of numExchange. For example, if numBottles == 3 and numExchange == 1, you cannot exchange 3 empty water bottles for 3 full bottles.

Return the maximum number of water bottles you can drink.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: numBottles = 13, numExchange = 6
Output: 15

Example 2:
Input: numBottles = 10, numExchange = 3
Output: 13

Constraints:

1 <= numBottles <= @data 
1 <= numExchange <= @data 

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[20, 50, 100]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(int numBottles, int numExchange) {
        int b = numBottles, e= numExchange;
        return b + (((-2*e) + 3 + sqrt(4*e*e + 8*b - 12*e + 1)) / 2);
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,d; cin>>n>>d;
    // solve
    Solution solution;
    auto result = solution.solve(n,d);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","math,other",Medium
179,"# Problem Statement
You are given a string $s$ such that each its character is either 1, 2, or 3. You have to choose the shortest contiguous substring of $s$ such that it contains each of these three characters at least once.

A contiguous substring of string $s$ is a string that can be obtained from $s$ by removing some (possibly zero) characters from the beginning of $s$ and some (possibly zero) characters from the end of $s$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(string &s) {
        // write your code here
    }
};
```
where:  
- return: the length of the shortest contiguous substring of s containing all three types of characters at least once. If there is no such substring, print 0 instead.

# Example 1:  
- Input:  
s = ""123""
- Output:  
3

# Constraints:  
- $1 \leq s.length \leq @data$
- $s[i] \in \{1, 2, 3\}$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(string &s)
    {
        const int n = s.length();
        int ans = n + 1;
        int cnt[3] = {};
        for (int i = 0, j = 0; i < n; ++i)
        {
            while ((!cnt[0] || !cnt[1] || !cnt[2]) && j <= n)
            {
                if (j < n)
                    ++cnt[s[j] - '1'];
                ++j;
            }
            if (j > n)
                break;
            ans = min(ans, j - i);
            --cnt[s[i] - '1'];
        }
        if (ans > n)
        {
            return 0;
        }
        else
        {
            return ans;
        }
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    string s;
    cin >> s;
    // solve
    Solution solution;
    auto result = solution.solve(s);

    // output
    cout << result << ""\n"";

    return 0;
}","binary,dp,two_pointers",easy
180,"Given an array of positive integers arr, return the sum of all possible odd-length subarrays of arr.

A subarray is a contiguous subsequence of the array.

solution main function

```cpp
class Solution {
public:
    string solve(vector<string>& words) {
        
    }
};
```

Example 1:
Input: words = [""abc"",""car"",""ada"",""racecar"",""cool""]
Output: ""ada""

Example 2:
Input: words = [""notapalindrome"",""racecar""]
Output: ""racecar""

Constraints:

1 <= words.length <= @data
1 <= words[i].length <= @data
words[i] consists only of lowercase English letters.

Time limit: @time_limit ms
Memory limit: @memory_limit KB


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[50, 100, 1000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    bool isPalindrome(string& s) {
        int start = 0;
        int end = s.size() - 1;
        
        while (start <= end) {
            // Return false if the characters are not the same.
            if (s[start] != s[end]) {
                return false;
            }
            
            start++;
            end--;
        }
        
        return true;
    }
    
    string solve(vector<string>& words) {
        for (string s : words) {
            if (isPalindrome(s)) {
                return s;
            }
        }
        
        return """";
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    vector<string> s;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        string t; cin>>t;
        s.push_back(t);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    cout<<result;
    return 0;
}",string,easy
181,"Given two integers, num and t. A number x is achievable if it can become equal to num after applying the following operation at most t times:

    Increase or decrease x by 1, and simultaneously increase or decrease num by 1.

Return the maximum possible value of x.

solution main function
```cpp
class Solution {
public:
    int solve(int num, int t) {
        
    }
};
```

Example 1:
Input: num = 4, t = 1
Output: 6

Example 2:
Input: num = 3, t = 2
Output: 7

Constraints:

1 <= num, t <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(int num, int t) {
        return num+t*2;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int x,y; cin>>x>>y;
    // solve
    Solution solution;
    auto result = solution.solve(x,y);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    printf(""%d"",result);
    return 0;
}","math,other",easy
182,"Given an integer array arr, remove a subarray (can be empty) from arr such that the remaining elements in arr are non-decreasing.

Return the length of the shortest subarray to remove.

A subarray is a contiguous subsequence of the array.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& arr) {
        
    }
};
```

Example 1:
Input: arr = [1,2,3,10,4,2,3,5]
Output: 3

Example 2:
Input: arr = [5,4,3,2,1]
Output: 4

Constraints:

1 <= arr.length <= @data
0 <= arr[i] <= 10^9

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& arr) {
        int right = arr.size() - 1;
        while (right > 0 && arr[right] >= arr[right - 1]) {
            right--;
        }

        int ans = right;
        int left = 0;
        while (left < right && (left == 0 || arr[left - 1] <= arr[left])) {
            // find next valid number after arr[left]
            while (right < arr.size() && arr[left] > arr[right]) {
                right++;
            }
            // save length of removed subarray
            ans = min(ans, right - left - 1);
            left++;
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> num;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num);
    
    // output
    cout << result << ""\n"";

    return 0;
}","two_pointers,binary",medium
183,"You are given four integers row, cols, rCenter, and cCenter. There is a rows x cols matrix and you are on the cell with the coordinates (rCenter, cCenter).

Return the coordinates of all cells in the matrix, sorted by their distance from (rCenter, cCenter) from the smallest distance to the largest distance. You may return the answer in any order that satisfies this condition.

The distance between two cells (r1, c1) and (r2, c2) is |r1 - r2| + |c1 - c2|.

solution main function
```cpp
class Solution {
public:
    vector<vector<int>> solve(int rows, int cols, int rCenter, int cCenter) {
        
    }
};;
```

Example 1:
Input: rows = 1, cols = 2, rCenter = 0, cCenter = 0
Output: [[0,0],[0,1]]

Example 2:
Input: rows = 2, cols = 2, rCenter = 0, cCenter = 1
Output: [[0,1],[0,0],[1,1],[1,0]]

Constraints:


1 <= rows, cols <= @data
0 <= rCenter < rows
0 <= cCenter < cols


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[20, 50, 100]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<vector<int>> solve(int rows, int cols, int rCenter, int cCenter) 
    {
        vector<vector<int>> res;
        vector<pair<int,pair<int,int>>> v;
        for(int i=0;i<rows;i++)
        {
            for(int j=0;j<cols;j++)
            {
                v.push_back({abs(i-rCenter)+abs(j-cCenter),{i,j}});
            }
        }
        sort(v.begin(),v.end());
        for (int i=0;i<v.size();i++)
           res.push_back({v[i].second.first, v[i].second.second});
    
       return res; 
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int a,c,b,d; cin>>a>>b>>c>>d;
    // solve
    Solution solution;
    auto result = solution.solve(a,b,c,d);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    // printf(""%d"",result);
    for(auto s:result)
    {
        for(auto it:s)
            printf(""%d "",it);
        putchar('\n');
    }
    return 0;
}","math,sort,other",easy
184,"# Problem Statement
The heroic outlaw Robin Hood is famous for taking from the rich and giving to the poor.

Robin encounters $n$ people starting from the $1$\-st and ending with the $n$\-th. The $i$\-th person has $a_i$ gold. If $a_i \ge k$, Robin will take all $a_i$ gold, and if $a_i=0$, Robin will give $1$ gold if he has any. Robin starts with $0$ gold.

Find out how many people Robin gives gold to.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &k, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return:the number of people that will get gold from Robin Hood. 

# Example 1:  
- Input:  
n = 2, k = 2, a = [2, 0]
- Output:  
1

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq k \leq 1000$
- $0 \leq a[i] \leq 10^4$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, int &k, vector<int> &a)
    {
        int cnt = 0, sum = 0;
        for (int i = 0; i < n; i++)
        {
            int x = a[i];
            if (x >= k)
                sum += x;
            else if (x == 0 && sum)
                cnt++, sum--;
        }
        return cnt;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, x;
    cin >> n >> x;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, x, a);

    // output
    cout << result << ""\n"";

    return 0;
}",math,easy
185,"You are given three positive integers n, x, and y.

In a city, there exist houses numbered 1 to n connected by n streets. There is a street connecting the house numbered i with the house numbered i + 1 for all 1 <= i <= n - 1 . An additional street connects the house numbered x with the house numbered y.

For each k, such that 1 <= k <= n, you need to find the number of pairs of houses (house1, house2) such that the minimum number of streets that need to be traveled to reach house2 from house1 is k.

Return a 1-indexed array result of length n where result[k] represents the total number of pairs of houses such that the minimum streets required to reach one house from the other is k.

Note that x and y can be equal.

solution main function
```cpp
class Solution {
public:
    vector<int> solve(int n, int x, int y) {
        
    }
};
```

Example 1:
Input: n = 3, x = 1, y = 3
Output: [6,0,0]

Example 2:
Input: n = 5, x = 2, y = 4
Output: [10,8,2,0,0]

Constraints:

2 <= n <= @data
1 <= x, y <= n

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[50, 100, 500]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> solve(int n, int x, int y) {
        // to make sure that x<=y in every case
        if(x>y)
            return solve(n, y, x);
        
        vector<int> res(n, 0);
        
        for(int i=1;i<=n;i++){
            for(int j=1;j<i;j++){
                int idx = i-j;          
                idx = min(idx, abs(j-x) + 1 + abs(i-y));
                if(idx>=1)
                    res[idx-1]+=2;  // add 2 as we can go from j->i and i->j
            }
        }
        return res;
        
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int x,y,n; cin>>n>>x>>y;
    // solve
    Solution solution;
    auto result = solution.solve(n,x,y);
    
    // output
    for(auto it:result) cout<<it<<' ';
    // printf(""%d"",result);
    return 0;
}","graph,search",medium
186,"# Problem Statement
Turtle and Piggy are playing a game on a sequence. They are given a sequence $a_1, a_2, \ldots, a_n$, and Turtle goes first. Turtle and Piggy alternate in turns (so, Turtle does the first turn, Piggy does the second, Turtle does the third, etc.).

The game goes as follows:

-   Let the current length of the sequence be $m$. If $m = 1$, the game ends.
-   If the game does not end and it's Turtle's turn, then Turtle must choose an integer $i$ such that $1 \le i \le m - 1$, set $a_i$ to $\max(a_i, a_{i + 1})$, and remove $a_{i + 1}$.
-   If the game does not end and it's Piggy's turn, then Piggy must choose an integer $i$ such that $1 \le i \le m - 1$, set $a_i$ to $\min(a_i, a_{i + 1})$, and remove $a_{i + 1}$.

Turtle wants to **maximize** the value of $a_1$ in the end, while Piggy wants to **minimize** the value of $a_1$ in the end. Find the value of $a_1$ in the end if both players play optimally.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the value of a1 in the end if both players play optimally.

# Example 1:  
- Input:  
n = 2, a = [1, 2] 
- Output:  
2

# Constraints:  
- $2 \leq n \leq @data$
- $1 \leq a[i] \leq 10^5$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        sort(a.begin(), a.end());
        return a[n / 2];
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",game,medium
187,"There is an undirected connected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.

You are given the integer n and the array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.

Return an array answer of length n where answer[i] is the sum of the distances between the ith node in the tree and all other nodes.

solution main function
```cpp
class Solution {
public:
    vector<int> solve(int n, vector<vector<int>>& edges) {
        
    }
};
```

Example 1:
Input: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]
Output: [8,12,6,10,10,10]

Example 2:
Input: n = 1, edges = []
Output: [0]

Constraints:

1 <= n <= @data
edges.length == n - 1
edges[i].length == 2
0 <= ai, bi < n
ai != bi

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
    int res=0;
   int dfs(int cur,int par, vector<vector<int>>& adj,vector<int>& cnt,int lvl){
    int sum=0;
    res+=lvl;
        for(auto child:adj[cur]){
            if(child!=par){
                sum+=dfs(child,cur,adj,cnt,lvl+1);
            }
        }
        cnt[cur]=sum+1;
        return sum+1;
    }
public:
    vector<int> solve(int n, vector<vector<int>>& edges) {
        vector<vector<int>> adj(n);
        for(int i=0; i<n-1; i++){
            int u=edges[i][0];
            int v=edges[i][1];
            adj[u].push_back(v);
            adj[v].push_back(u);
        }
        vector<int> cnt(n,0);
        int total=dfs(0,-1,adj,cnt,0);
        vector<int> par(n,0);
        par[0]=res;
        queue<int> q;
        q.push(0);
        
        while(!q.empty()){
            int cur=q.front();
            q.pop();
            for(auto child:adj[cur]){
                if(par[child]==0){
                    par[child]=par[cur]-cnt[child]+(total-cnt[child]);
                    q.push(child);
                }
            }
        }
        return par;

    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    cin>>n;
    vector<vector<int>> e;
    for(int i=1;i<n;i++)
    {
        int x,y; cin>>x>>y;
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        e.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(n,e);
    
    // output
    for(auto it:result) cout<<it<<' ';
    // printf(""%d"",result);
    return 0;
}","graph,dynamic_programming,search",hard
188,"# Problem Statement
Alice and Bob are playing a game. There is a list of $n$ booleans, each of which is either true or false, given as a binary string $^{\text{}}$ of length $n$ (where $\texttt{1}$ represents true, and $\texttt{0}$ represents false). Initially, there are no operators between the booleans.

Alice and Bob will take alternate turns placing and or or between the booleans, with Alice going first. Thus, the game will consist of $n-1$ turns since there are $n$ booleans. Alice aims for the final statement to evaluate to true, while Bob aims for it to evaluate to false. Given the list of boolean values, determine whether Alice will win if both players play optimally.

To evaluate the final expression, repeatedly perform the following steps until the statement consists of a single true or false:

-   If the statement contains an and operator, choose any one and replace the subexpression surrounding it with its evaluation.
-   Otherwise, the statement contains an or operator. Choose any one and replace the subexpression surrounding the or with its evaluation.

For example, the expression trueorfalseandfalse is evaluated as trueor(falseandfalse) $=$ trueorfalse $=$ true. It can be shown that the result of any compound statement is unique.

$^{\text{}}$A binary string is a string that only consists of characters $\texttt{0}$ and $\texttt{1}$

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, string &s) {
        // write your code here
    }
};
```
where:  
- return ""YES"" (without quotes) if Alice wins, and ""NO"" (without quotes) otherwise.

# Example 1:  
- Input:  
n = 2, s = ""11""
- Output:  
YES

# Constraints:  
- $2 \leq n \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 128]]","class Solution
{
public:
    string solve(int &n, string &s)
    {
        s = '1' + s + '1';
        if (s.find(""11"") != -1)
            return ""YES"";
        else
            return ""NO"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    string s;
    cin >> s;

    // solve
    Solution solution;
    auto result = solution.solve(n, s);

    // output
    cout << result << ""\n"";

    return 0;
}",game,medium
189,"You have n boxes. You are given a binary string boxes of length n, where boxes[i] is '0' if the ith box is empty, and '1' if it contains one ball.

In one operation, you can move one ball from a box to an adjacent box. Box i is adjacent to box j if abs(i - j) == 1. Note that after doing so, there may be more than one ball in some boxes.

Return an array answer of size n, where answer[i] is the minimum number of operations needed to move all the balls to the ith box.

Each answer[i] is calculated considering the initial state of the boxes.

solution main function
```cpp
class Solution {
public:
    vector<int> solve(string boxes) {
    }
};
```

Example 1:
Input: boxes = ""110""
Output: [1,1,3]

Example 2:
Input: boxes = ""001011""
Output: [11,8,5,4,3,4]

Constraints:

n == boxes.length
1 <= n <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> solve(string boxes) {
        int n = boxes.size();
        vector<int> answer(n, 0);

        int ballsToLeft = 0, movesToLeft = 0;
        int ballsToRight = 0, movesToRight = 0;

        // Single pass: calculate moves from both left and right
        for (int i = 0; i < n; i++) {
            // Left pass
            answer[i] += movesToLeft;
            ballsToLeft += boxes[i] - '0';
            movesToLeft += ballsToLeft;

            // Right pass
            int j = n - 1 - i;
            answer[j] += movesToRight;
            ballsToRight += boxes[j] - '0';
            movesToRight += ballsToRight;
        }

        return answer;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string s; cin>>s;
    // solve
    Solution solution;
    auto result = solution.solve(s);
    // output
    // cout << result << ""\n"";
    for(auto it:result) printf(""%d "",it);
    return 0;
}",string,medium
190,"# Problem Statement
You are given a list of $n$ integers $a_1, a_2, \dots, a_n$. You need to pick $8$ elements from the list and use them as coordinates of four points. These four points should be corners of a rectangle which has its sides parallel to the coordinate axes. Your task is to pick coordinates in such a way that the resulting rectangle has the maximum possible area. The rectangle can be degenerate, i.e. its area can be $0$. Each integer can be used as many times as it occurs in the list (or less).

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return : the maximum area of the rectangle, or $-1$ if it is impossible to form a rectangle.

# Example 1:  
- Input:  
n = 8
a = [0, 0, -1, 2, 2, 1, 1, 3]  
- Output:  
-1

# Constraints:  
- $8 \leq n \leq @data$
- $-10^4 \leq a[i] \leq 10^4$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        sort(a.begin(), a.end());
        int min1 = INT_MAX, min2 = INT_MAX, max1 = INT_MIN, max2 = INT_MIN;
        for (int i = 0, pre = 1E9; i < n; i++)
        {
            if (a[i] != pre)
            {
                pre = a[i];
                continue;
            }
            pre = 1E9;
            if (a[i] < min1)
            {
                min2 = min1;
                min1 = a[i];
            }
            else if (a[i] < min2)
            {
                min2 = a[i];
            }
            else if (a[i] > max1)
            {
                max2 = max1;
                max1 = a[i];
            }
            else if (a[i] > max2)
            {
                max2 = a[i];
            }
        }
        if (min1 == INT_MAX || min2 == INT_MAX || max1 == INT_MIN || max2 == INT_MIN)
            return -1;
        return max((max1 - min1) * (max2 - min2), (max2 - min1) * (max1 - min2));
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","sort,greedy",hard
191,"# Problem Statement
You have a horizontal strip of $n$ cells. Each cell is either white or black.

You can choose a **continuous** segment of cells once and paint them all white. After this action, all the black cells in this segment will become white, and the white ones will remain white.

What is the minimum length of the segment that needs to be painted white in order for all $n$ cells to become white?

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, string &s) {
        // write your code here
    }
};
```
where:  
- return: the minimum length of a continuous segment of cells that needs to be painted white in order for the entire strip to become white.

# Example 1:  
- Input:  
n = 6
s = ""WBBWBW""
- Output:  
4

# Constraints:  
- $1 \leq n \leq @data$
- $s[i] \in \{'W', 'B'\}$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, string &s)
    {
        int l = 0, r = n - 1;
        while (s[l] == 'W')
        {
            l++;
        }
        while (s[r] == 'W')
        {
            r--;
        }
        int ans = r - l + 1;
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    string s;cin>>s;

    // solve
    Solution solution;
    auto result = solution.solve(n,s);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,string",easy
192,"A swap is defined as taking two distinct positions in an array and swapping the values in them.

A circular array is defined as an array where we consider the first element and the last element to be adjacent.

Given a binary circular array nums, return the minimum number of swaps required to group all 1's present in the array together at any location.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [0,1,0,1,1,0,0]
Output: 1

Example 2:
Input: nums = [0,1,1,1,0,0,1,1,0]
Output: 2

Constraints:

1 <= nums.length <= @data
nums[i] is either 0 or 1.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums) {
        // Initialize minimum swaps to a large value
        int minimumSwaps = INT_MAX;

        // Calculate the total number of 1s in the array
        int totalOnes = accumulate(nums.begin(), nums.end(), 0);

        // Initialize the count of 1s in the current window
        int onesCount = nums[0];
        int end = 0;

        // Slide the window across the array
        for (int start = 0; start < nums.size(); ++start) {
            // Adjust onesCount by removing the element that is sliding out of
            // the window
            if (start != 0) {
                onesCount -= nums[start - 1];
            }

            // Expand the window to the right until it reaches the desired size
            while (end - start + 1 < totalOnes) {
                end++;
                onesCount += nums[end % nums.size()];
            }

            // Update the minimum number of swaps needed
            minimumSwaps = min(minimumSwaps, totalOnes - onesCount);
        }

        return minimumSwaps;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> num;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num);
    
    // output
    cout<<result;
    return 0;
}",greedy,easy
193,"Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1.

After doing so, return the array.

solution main function
```cpp
class Solution {
public:
    vector<int> solve(vector<int>& arr) {
        
    }
};
```

Example 1:
Input: arr = [17,18,5,4,6,1]
Output: [18,6,6,6,1,-1]

Example 2:
Input: arr = [400]
Output: [-1]

Constraints:

1 <= arr.length <= @data
1 <= arr[i] <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 500, 1000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> solve(vector<int>& arr) {
        
        int n = arr.size();
        int mx = -1;
        int p;

        for(int i = n-1; i>=0; i--){
            p = arr[i];
            arr[i] = mx;

            if(p>mx){
                mx = p;
            }
        }

        return arr;
        
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    for(auto it:result) cout<<it<<' ';
    // cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",other,easy
194,"Given a binary string s and an integer k, return true if every binary code of length k is a substring of s. Otherwise, return false.

solution main function
```cpp
class Solution {
public:
    bool solve(string s, int k) {

    }
};
```

Example 1:
Input: s = ""00110110"", k = 2
Output: true

Example 2:
Input: s = ""0110"", k = 1
Output: true

Constraints:
1 <= s.length <= @data
s[i] is either '0' or '1'.
1 <= k <= 20
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[12800, 4000, 2200]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    bool solve(string s, int k) {
        int n = s.size();
        if(k > n) {
            return false;
        }
        int cur = 0;
        vector<bool> vis(1 << k, false);
        for(int i = 0; i < k; ++i) {
            cur = (cur << 1) + (s[i] == '1');    
        }
        vis[cur] = true;
        for(int i = k; i < n; ++i) {
            cur = (cur << 1) + (s[i] == '1');
            cur &= ~(1 << k);
            vis[cur] = true;
        }
        for(bool v : vis) {
            if(!v) {
                return false;
            }
        }
        return true;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; string str; cin>>str>>n;
    // solve
    Solution solution;
            int result = solution.solve(str,n);
    
    // output
    cout<<result;
    return 0;
}","string,bit_manipulation",medium
195,"# Problem Statement
You are given a sequence $a$ consisting of $n$ positive integers.

You can perform the following operation any number of times.

-   Select an index $i$ ($1 \le i &lt; n$), and subtract $\min(a_i,a_{i+1})$ from both $a_i$ and $a_{i+1}$.

Determine if it is possible to make the sequence **non-decreasing** by using the operation any number of times.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- If it is possible to make the sequence non-decreasing, return ""YES"". Otherwise, return ""NO"".

# Example 1:  
- Input:  
n = 5, a = [1, 2, 3, 4, 5]  
- Output:  
YES

# Constraints:  
- $2 \leq n \leq @data$
- $1 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(int &n, vector<int> &a)
    {
        for (int i = 1; i < n; i++)
        {
            if (a[i - 1] > a[i])
                return ""NO"";
            a[i] -= a[i - 1];
        }
        return ""YES"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",greedy,medium
196,"We define the conversion array conver of an array arr as follows:

    conver[i] = arr[i] + max(arr[0..i]) where max(arr[0..i]) is the maximum value of arr[j] over 0 <= j <= i.

We also define the score of an array arr as the sum of the values of the conversion array of arr.

Given a 0-indexed integer array nums of length n, return an array ans of length n where ans[i] is the score of the prefix nums[0..i].

solution main function
```cpp
class Solution {
public:
    vector<long long> solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [2,3,7,5,10]
Output: [4,10,24,36,56]

Example 2:
Input: nums = [1,1,2,4,8,16]
Output: [2,4,8,16,32,64]

Constraints:

1 <= nums.length <= @data
1 <= nums[i] <= 10^9

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<long long> solve(vector<int>& nums) {
        vector<long long> result(nums.size());
        int max_num = nums[0];
        result[0] = nums[0] * 2;

        for(int i = 1; i < nums.size(); i++)
        {
            max_num = max(max_num, nums[i]);
            result[i] = nums[i] + max_num + result[i-1];
        }

        return result;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    for(auto it:result) cout<<it<<' ';
    // cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",other,medium
197,"# Problem Statement
There are $n$ candies put from left to right on a table. The candies are numbered from left to right. The $i$\-th candy has weight $w_i$. Alice and Bob eat candies.

Alice can eat any number of candies from the left (she can't skip candies, she eats them in a row).

Bob can eat any number of candies from the right (he can't skip candies, he eats them in a row).

Of course, if Alice ate a candy, Bob can't eat it (and vice versa).

They want to be fair. Their goal is to eat the same total weight of candies. What is the most number of candies they can eat in total?

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &w) {
        // write your code here
    }
};
```
where:  
- return: the maximum number of candies Alice and Bob can eat in total while satisfying the condition.

# Example 1:  
- Input:  
n = 3
w = [10,20,10]
- Output:  
2

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq w[i] \leq 10^4$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &w)
    {
        int ans = 0;
        for (int i = 0, j = n - 1, L = 0, R = 0; i <= j;)
        {
            L += w[i++];
            while (R < L and j >= i)
                R += w[j--];
            if (L == R)
                ans = max(ans, i + n - j - 1);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> w(n);
    for (int i = 0; i < n; i++)
        cin >> w[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, w);

    // output
    cout << result << ""\n"";

    return 0;
}","two_pointers,binary,greedy",medium
198,"You are given two arrays rowSum and colSum of non-negative integers where rowSum[i] is the sum of the elements in the ith row and colSum[j] is the sum of the elements of the jth column of a 2D matrix. In other words, you do not know the elements of the matrix, but you do know the sums of each row and column.

Find any matrix of non-negative integers of size rowSum.length x colSum.length that satisfies the rowSum and colSum requirements.

The matrices that satisfy the conditions are stored in the passed ans two-dimensional vector array,The ans array has been initialized to a two-dimensional zero matrix.

solution main function
```cpp
class Solution {
public:
    void solve(vector<int>& rowSum, vector<int>& colSum,vector<vector<int> >& ans) {
        
    }
};
```

Example 1:
Input: rowSum = [3,8], colSum = [4,7]
Output: [[3,0],[1,7]]

Example 2:
Input: rowSum = [5,7,10], colSum = [8,6,8]
Output: [[0,5,0],[6,1,0],[2,0,8]]

Constraints:

1 <= rowSum.length * colSum.length <= @data
0 <= rowSum[i], colSum[i] <= 10^8
sum(rowSum) == sum(colSum)

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    void solve(vector<int>& rowSum, vector<int>& colSum,vector<vector<int> >& ans) {
        int N = rowSum.size();
        int M = colSum.size();

        int i = 0, j = 0;

        while (i < N && j < M) {
            ans[i][j] = min(rowSum[i], colSum[j]);
            
            rowSum[i] -= ans[i][j];
            colSum[j] -= ans[i][j];

            rowSum[i] == 0 ? i++ : j++;
        }
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    vector< int > a,b;
    vector<vector<int> > ans;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=m;j++)
            temp.push_back(0);
        ans.push_back(temp);
    }
    for(int i=1,x;i<=n;i++)
    {
        cin>>x;
        a.push_back(x);
    }
    for(int i=1,x;i<=m;i++)
    {
        cin>>x;
        b.push_back(x);
    }
    vector< int > x,y;
    x=a; y=b;
    // solve
    Solution solution;
    solution.solve(a,b,ans);
    
    // for(auto it:ans)
    // {
    //     for(auto x:it) cout<<x<<' ';
    //     cout<<endl;
    // }
    for(int i=1;i<=n;i++)
    {
        int sum=0;
        for(int j=1;j<=m;j++)
            sum+=ans[i-1][j-1];
        if(sum!=x[i-1])
        {
            cout<<0;
            return 0;
        }
    }
    for(int i=1;i<=m;i++)
    {
        int sum=0;
        for(int j=1;j<=n;j++)
            sum+=ans[j-1][i-1];
        if(sum!=y[i-1])
        {
            cout<<0;
            return 0;
        }
    }
    // output
    cout<<1;
    return 0;
}","math,greedy",easy
199,"You are given a positive integer array grades which represents the grades of students in a university. You would like to enter all these students into a competition in ordered non-empty groups, such that the ordering meets the following conditions:

    The sum of the grades of students in the ith group is less than the sum of the grades of students in the (i + 1)th group, for all groups (except the last).
    The total number of students in the ith group is less than the total number of students in the (i + 1)th group, for all groups (except the last).

Return the maximum number of groups that can be formed.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& grades) {
        
    }
};
```

Example 1:
Input: grades = [10,6,12,7,3,5]
Output: 3

Example 2:
Input: grades = [8,8]
Output: 1


Constraints:

1 <= grades.length <= @data
1 <= grades[i] <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& A) {
        return (int)(sqrt(A.size() * 2 + 0.25) - 0.5);
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> nums;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        nums.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(nums);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","math,search,greedy",medium
200,"# Problem Statement
You are given an array $a_1, a_2, \ldots, a_n$ of positive integers.

You can color some elements of the array red, but there cannot be two adjacent red elements (i.e., for $1 \leq i \leq n-1$, at least one of $a_i$ and $a_{i+1}$ must not be red).

Your score is the maximum value of a red element plus the number of red elements. Find the maximum score you can get.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {   
        // write your code here
    }
};
```
where:  
- the return value is the maximum score you can get

# Example 1:  
- Input:  
n = 3
a = [5, 4, 5]
- Output:  
7

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq 10^9$ 
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[100, 10000, 1000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        int mx1 = 0, mx2 = 0, cnt1 = 0, cnt2 = 0;
        for (int i = 0; i < n; i++)
        {
            if (i % 2)
            {
                mx1 = max(mx1, a[i]);
                cnt1++;
            }
            else
            {
                mx2 = max(mx2, a[i]);
                cnt2++;
            }
        }
        return max(mx1 + cnt1, mx2 + cnt2);
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","dp,greedy",hard
201,"You are given an array rectangles where rectangles[i] = [li, wi] represents the ith rectangle of length li and width wi.

You can cut the ith rectangle to form a square with a side length of k if both k <= li and k <= wi. For example, if you have a rectangle [4,6], you can cut it to get a square with a side length of at most 4.

Let maxLen be the side length of the largest square you can obtain from any of the given rectangles.

Return the number of rectangles that can make a square with a side length of maxLen.
solution main function
```cpp
class Solution {
public:
    int solve(vector<vector<int>>& rectangles) {
        
    }
};
```

Example 1:
Input: rectangles = [[5,8],[3,9],[5,12],[16,5]]
Output: 3

Example 2:
Input: rectangles = [[2,3],[3,7],[4,3],[3,7]]
Output: 3

Constraints:

1 <= rectangles.length <= @data
rectangles[i].length == 2
1 <= li, wi <= 10^9
li != wi

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<vector<int>>& v){
        int maxSqr=0,ans=0;
        for(int i=0;i<v.size();i++){
            int temp=min(v[i][0],v[i][1]);
            if(temp==maxSqr)ans++;
            else if(temp>maxSqr){
                maxSqr=temp;
                ans=1;
            }
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;cin>>n;
    vector<vector<int> > s;
    for(int i=1,x;i<=n;i++)
    {
        vector<int> temp;
        cin>>x; temp.push_back(x);
        cin>>x; temp.push_back(x);
        s.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",sort,easy
202,"You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.

A string is called balanced if and only if:

    It is the empty string, or
    It can be written as AB, where both A and B are balanced strings, or
    It can be written as [C], where C is a balanced string.

You may swap the brackets at any two indices any number of times.

Return the minimum number of swaps to make s balanced.

solution main function

```cpp
class Solution {
public:
    int solve(string s) {
        
    }
};
```

Example 1:
Input: s = ""][][""
Output: 1

Example 2:
Input: s = ""[]""
Output: 0

Constraints:

n == s.length
2 <= n <= @data
n is even.
s[i] is either '[' or ']'.
The number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(string s) {
        int stackSize = 0;
        int n = s.size();

        for (int i = 0; i < n; i++) {
            char ch = s[i];
            // If character is opening bracket, increment the stack size.
            if (ch == '[')
                stackSize++;
            else {
                // If the character is closing bracket, and we have an opening
                // bracket, decrease the stack size.
                if (stackSize > 0) stackSize--;
            }
        }
        return (stackSize + 1) / 2;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string s; cin>>s;
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    cout<<result;
    return 0;
}","two_pointers,string,greedy",medium
203,"# Problem Statement
Ball is the teacher in Paperfold University. The seats of his classroom are arranged in $2$ rows with $m$ seats each.

Ball is teaching $a + b + c$ monkeys, and he wants to assign as many monkeys to a seat as possible. Ball knows that $a$ of them only want to sit in row $1$, $b$ of them only want to sit in row $2$, and $c$ of them have no preference. Only one monkey may sit in each seat, and each monkey's preference must be followed if it is seated.

What is the maximum number of monkeys that Ball can seat?

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &m, int &a, int &b, int &c) { 
        // write your code here
    }
};
```
where:  
- return: the maximum number of monkeys you can seat.

# Example 1:  
- Input:  
n = 4, a = [0, 1, 2, 3]
- Output:  
1

# Constraints:  
- $1 \leq m, a, b, c \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 100000, 10000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &m, int &a, int &b, int &c)
    {
        int x = m;
        int y = m;
        int ans = 0;
        int take = min(x, a);
        x -= take;
        ans += take;
        take = min(y, b);
        y -= take;
        ans += take;
        take = min(x + y, c);
        ans += take;
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int m, a, b, c;
    cin >> m >> a >> b >> c;

    // solve
    Solution solution;
    auto result = solution.solve(m, a, b, c);

    // output
    cout << result << ""\n"";

    return 0;
}",math,easy
204,"# Problem Statement:
You had $n$ positive integers $a_1, a_2, \dots, a_n$ arranged in a circle. For each pair of neighboring numbers ($a_1$ and $a_2$, $a_2$ and $a_3$, ..., $a_{n - 1}$ and $a_n$, and $a_n$ and $a_1$), you wrote down: are the numbers in the pair equal or not.

Unfortunately, you've lost a piece of paper with the array $a$. Moreover, you are afraid that even information about equality of neighboring elements may be inconsistent. So, you are wondering: is there any array $a$ which is consistent with information you have about equality or non-equality of corresponding pairs?

The main function of the solution is defined as: 
```cpp
class Solution {
public:
    string solve(int &n, string &s) {   
        // write your code here
    }
};
```
Where:  
- `n` is an integer representing the number of elements in the array.  
- `s` is a string consisting of the characters 'N' and 'E', where:  
  - 'E' indicates the two adjacent numbers are equal.  
  - 'N' indicates the two adjacent numbers are not equal.  
- The return value is ""YES"" if there exists an array $a$ consistent with the information you have, otherwise, it is ""NO"".

# Example 1: 
- Input:  
n = 3  
s = ""EEE""
- Output:  
YES

# Constraints:
- $2 \leq n \leq @data$
- Time limit: @time_limit ms
- Memory limit: @memory_limit KB","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(int &n, string &s)
    {
        int cnt = 0;
        for (auto x : s)
            if (x == 'N')
                cnt++;
        if (cnt == 1)
            return ""NO"";
        else
            return ""YES"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    string s;
    cin >> s;

    // solve
    Solution solution;
    auto result = solution.solve(n, s);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,data_structures",medium
205,"# Problem Statement
You are given an array $a$ of length $n$. Start with $c = 0$. Then, for each $i$ from $1$ to $n$ (in increasing order) do **exactly one** of the following:

-   Option $1$: set $c$ to $c + a_i$.
-   Option $2$: set $c$ to $|c + a_i|$, where $|x|$ is the absolute value of $x$.

Let the maximum final value of $c$ after the procedure described above be equal to $k$. Find the number of unique procedures that result in $c = k$. Two procedures are different if at any index $i$, one procedure chose option $1$ and another chose option $2$, even if the value of $c$ is equal for both procedures after that turn.

Since the answer may be large, output it modulo $998\,244\,353$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return the the number of unique procedures that result in c=k, modulo 998244353.

# Example 1:  
- Input:  
n = 4
a = [2, -5, 3, -3]
- Output: 
12

# Constraints:  
- $2 \leq n \leq @data$
- $-10^9 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(int &n, vector<int> &a)
    {
        const int mod = 998244353;
        long long cnt1 = 1, cnt2 = 1;
        long long c1 = 0, c2 = 0;
        for (int i = 0; i < n; i++)
        {
            long long pre1 = c1, pre2 = c2;
            c1 = max({pre1 + a[i], abs(pre2 + a[i])});
            c2 = pre2 + a[i];
            if (pre1 + a[i] == abs(pre2 + a[i]))
            {
                if (pre1 == pre2)
                    cnt1 = cnt1 * 2 % mod, cnt2 = cnt2 * 2 % mod;
                else
                    cnt1 = (cnt1 * 2 + cnt2) % mod;
            }
            else if (c1 == pre1 + a[i])
            {
                cnt1 = cnt1 * 2 % mod;
                if (c2 >= 0)
                    cnt2 = cnt2 * 2 % mod;
            }
            else
                cnt1 = cnt2;
        }
        return cnt1;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",dp,hard
206,"You are given a binary string s that contains at least one '1'.

You have to rearrange the bits in such a way that the resulting binary number is the maximum odd binary number that can be created from this combination.

Return a string representing the maximum odd binary number that can be created from the given combination.

Note that the resulting string can have leading zeros.

solution main function

```cpp
class Solution {
public:
    string solve(string s) {
        
    }
};
```

Example 1:
Input: s = ""010""
Output: ""001""

Example 2:
Input: s = ""010""
Output: ""001""

Constraints:

1 <= s.length <= @data
s consists only of '0' and '1'.
s contains at least one '1'

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    string solve(string s) {
        // Create char array
        const int N = s.length(); 
        char* arr = new char[N + 1]; 
        strcpy(arr, s.c_str()); 

        // Initialize two pointers
        int left = 0;
        int right = N -  1;

        while(left <= right) {
            
            // Increment left if equals 1
            if (arr[left] == '1') {
                left++;
            }
            // Decrement right if equals 0
            if (arr[right] == '0') {
                right--;
            }
            // Swap if neither pointer can be iterated
            if (left <= right && arr[left] == '0' && arr[right] == '1') {
                arr[left] = '1';
                arr[right] = '0';
            }
        }

        // Swap rightmost 1 bit to the end
        arr[left - 1] = '0';
        arr[N - 1] = '1';

        return arr;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string str; cin>>str;
    // solve
    Solution solution;
    auto result = solution.solve(str);
    // output
    cout << result << ""\n"";
    // for(auto it:result) cout<<it<<' ';
    return 0;
}","math,string,greedy",easy
207,"Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where:

    answer[0] is a list of all distinct integers in nums1 which are not present in nums2.
    answer[1] is a list of all distinct integers in nums2 which are not present in nums1.

Note that the integers in the lists may be returned in any order.

solution main function

```cpp
class Solution {
public:
    vector<vector<int>> solve(vector<int>& nums1, vector<int>& nums2) {
        
    }
};
```

Example 1:
Input: nums1 = [1,2,3], nums2 = [2,4,6]
Output: [[1,3],[4,6]]

Example 2:
Input: nums1 = [1,2,3,3], nums2 = [1,1,2,2]
Output: [[3],[]]

Constraints:

1 <= nums1.length, nums2.length <= @data
-@data <= nums1[i], nums2[i] <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[64000, 6400, 1000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<vector<int>> solve(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> set1(nums1.begin(),nums1.end());
        unordered_set<int> set2(nums2.begin(),nums2.end());

        vector<int> temp;
        for (const auto & item: set1) {
            if (set2.find(item)==set2.end()) {
                temp.push_back(item);
            }
        }

        vector<int> temp2;
        for (const auto & item: set2) {
            if (set1.find(item)==set1.end()) {
                temp2.push_back(item);
            }
        }
        return {temp, temp2};
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> a,b;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        a.push_back(x);
    }
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        b.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(a,b);
    // output
    // cout << result << ""\n"";
    for(auto it:result)
    {
        for(auto i:it) cout<<i<<' ';
        cout<<endl;
    }
    return 0;
}",STL,medium
208,"# Problem Statement
After a trip with Sakurako, Kousuke was very scared because he forgot about his programming assignment. In this assignment, the teacher gave him an array $a$ of $n$ integers and asked him to calculate the number of **non-overlapping** segments of the array $a$, such that each segment is considered beautiful.

A segment $[l,r]$ is considered beautiful if $a_l + a_{l+1} + \dots + a_{r-1} + a_r=0$.

For a fixed array $a$, your task is to compute the maximum number of non-overlapping beautiful segments.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {   
        // write your code here
    }
};
```
where:  
- the return value is the maximum value of the same number at the end

# Example 1:  
- Input:  
n = 5
a = [2, 1, -3, 2, 1]
- Output:  
1

# Constraints:  
- $1 \leq n \leq @data$
- $-10^4 \leq a[i] \leq 10^4$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[100, 10000, 1000000]",1000.0,"[[6400, 1280, 640]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        set<int> s;
        s.insert(0);
        int sum = 0, ans = 0;
        for (int i = 0; i < n; i++)
        {
            sum += a[i];
            ans += s.count(sum) ? (s.clear(), s.insert(0), sum = 0, 1) : 0;
            s.insert(sum);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","data_structures,dp,greedy,math",easy
209,"You are given two integer arrays nums1 and nums2. We write the integers of nums1 and nums2 (in the order they are given) on two separate horizontal lines.

We may draw connecting lines: a straight line connecting two numbers nums1[i] and nums2[j] such that:

    nums1[i] == nums2[j], and
    the line we draw does not intersect any other connecting (non-horizontal) line.

Note that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line).

Return the maximum number of connecting lines we can draw in this way.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& nums1, vector<int>& nums2) {
        
    }
};
```

Example 1:
Input: nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]
Output: 3

Example 2:
Input: nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]
Output: 2

Constraints:

1 <= nums1.length, nums2.length <= @data
1 <= nums1[i], nums2[j] <= 2000

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[50, 100, 1000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums1, vector<int>& nums2) {
        int n1 = nums1.size();
        int n2 = nums2.size();

        vector<int> dp(n2 + 1), dpPrev(n2 + 1);

        for (int i = 1; i <= n1; i++) {
            for (int j = 1; j <= n2; j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[j] = 1 + dpPrev[j - 1];
                } else {
                    dp[j] = max(dp[j - 1], dpPrev[j]);
                }
            }
            dpPrev = dp;
        }

        return dp[n2];
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector< int > a,b;
    for(int i=1,x;i<=n;i++)
    {
        cin>>x;
        a.push_back(x);
    }
    for(int i=1,x;i<=n;i++)
    {
        cin>>x;
        b.push_back(x);
    }
    // solve
    Solution solution;
    int result = solution.solve(a,b);
    
    // output
    cout << result << ""\n"";

    return 0;
}",dp,medium
210,"You are given an array of positive integers price where price[i] denotes the price of the ith candy and a positive integer k.

The store sells baskets of k distinct candies. The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket.

Return the maximum tastiness of a candy basket.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: price = [13,5,1,8,21,2], k = 3
Output: 8

Example 2:
Input: price = [1,3,1], k = 2
Output: 2
Constraints:

2 <= k <= price.length <= @data
1 <= price[i] <= 10^9

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
 bool canweplace(vector<int>&stalls,int dis,int k){
        //dis=mid
        int cntcows=1;//start with placing first cow at stall[0]
        int lastcow=stalls[0];//position of last cow
        for(int i=0;i<stalls.size();i++){
            if(stalls[i]-lastcow>=dis){
                cntcows++;
                lastcow=stalls[i];
            }
            if(cntcows==k) return true;
        }
        return false;
    }
    int solve(vector<int>& prices, int k) {
     int n=prices.size(); 
     sort(prices.begin(),prices.end()) ;
     int low=1, high=prices[n-1]-prices[0];
     int ans=-1;
     while(low<=high){
        int mid=low+(high-low)/2;
        if(canweplace(prices,mid,k)==true) {
            ans=mid; low=mid+1;

        }
        else high=mid-1;
     }
    return high;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,k; cin>>n>>k;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s,k);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","search,other",medium
211,"You are given two integers n and m that consist of the same number of digits.

You can perform the following operations any number of times:

    Choose any digit from n that is not 9 and increase it by 1.
    Choose any digit from n that is not 0 and decrease it by 1.

The integer n must not be a
prime
number at any point, including its original value and after each operation.

The cost of a transformation is the sum of all values that n takes throughout the operations performed.

Return the minimum cost to transform n into m. If it is impossible, return -1.

solution main function
```cpp
class Solution {
public:
    int solve(int n, int m) {
        
    }
};
```

Example 1:
Input: n = 10, m = 12
Output: 85

Example 2:
Input: n = 4, m = 8
Output: -1

Constraints:

1 <= n, m < 10^4
n and m consist of the same number of digits.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
vector<int> isPrime;

void generatePrimes() {
    if (!isPrime.empty()) return;
    isPrime.resize(1e5 + 1, 1);
    isPrime[0] = isPrime[1] = 0;
    for (int i = 2; i <= 1e5; i++) {
        if (isPrime[i]) {
            for (int j = 2 * i; j <= 1e5; j += i) {
                isPrime[j] = 0;
            }
        }
    }
}

class Solution {
public:
    int solve(int n, int m) {
        generatePrimes();
        if (isPrime[n] || isPrime[m]) return -1;

        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;
        unordered_set<int> visited;

        q.push({n, n});
        while (!q.empty()) {
            auto [steps, curr] = q.top();
            q.pop();

            if (visited.count(curr)) continue;
            visited.insert(curr);

            if (curr == m) return steps;

            string s = to_string(curr);
            for (int i = 0; i < s.length(); i++) {
                char original = s[i];

                if (s[i] < '9') {
                    s[i]++;
                    int next = stoi(s);
                    if (!isPrime[next] && !visited.count(next)) {
                        q.push({steps + next, next});
                    }
                    s[i] = original;
                }

                if (s[i] > '0' && !(i == 0 && s[i] == '1')) {
                    s[i]--;
                    int next = stoi(s);
                    if (!isPrime[next] && !visited.count(next)) {
                        q.push({steps + next, next});
                    }
                    s[i] = original;
                }
            }
        }
        return -1;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m;
    cin>>n>>m;
    // solve
    Solution solution;
    auto result = solution.solve(n,m);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    printf(""%d"",result);
    return 0;
}","graph,math",medium
212,"# Problem Statement
You are given a sequence $a$, consisting of $n$ integers, where the $i$\-th element of the sequence is equal to $a_i$. You are also given two integers $x$ and $y$ ($x \le y$).

A pair of integers $(i, j)$ is considered interesting if the following conditions are met:

-   $1 \le i &lt; j \le n$;
-   if you simultaneously remove the elements at positions $i$ and $j$ from the sequence $a$, the sum of the remaining elements is at least $x$ and at most $y$.

Your task is to determine the number of interesting pairs of integers for the given sequence $a$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, long long &x, long long &y, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the number of interesting pairs of integers, please use `long long` type to avoid overflow

# Example 1:  
- Input:  
n = 4, x = 8, y = 10
a = [4, 6, 3, 6]
- Output:  
4

# Constraints:  
- $3 \leq n \leq @data$
- $1 \leq x \leq y \leq 10^14$
- $1 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(int &n, long long &x, long long &y, vector<int> &a)
    {
        long long sum = 0;
        for (int i = 0; i < n; i++)
            sum += a[i];
        sort(a.begin(), a.end());
        long long res = 0;
        for (int i = n - 1, l = 0, r = 0; i >= 0; i--)
        {
            while (r < i && sum - a[i] - a[r] >= x)
                r++;
            while (l < r && sum - a[l] - a[i] > y)
                l++;
            if (l >= i)
                break;
            res += min(r, i) - l;
        }
        return res;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    long long x, y;
    cin >> n >> x >> y;

    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, x, y, a);

    // output
    cout << result << ""\n"";

    return 0;
}","two_pointers,binary,sort",medium
213,"# Problem Statement
Vladislav wrote the integers from $1$ to $n$, inclusive, on the board. Then he replaced each integer with the sum of its digits.

What is the sum of the numbers on the board now?

For example, if $n=12$ then initially the numbers on the board are:
$$
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12.
$$
 Then after the replacement, the numbers become:
$$
1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3.
$$
 The sum of these numbers is $1+2+3+4+5+6+7+8+9+1+2+3=51$. Thus, for $n=12$ the answer is $51$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n) {   
        // write your code here
    }
};
```
where:  
- the return value is the total sum of the digits of all numbers

# Example 1:  
- Input:  
n = 12
- Output:  
51

# Constraints:  
- $1 \leq n \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[100, 10000, 1000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n)
    {
        string s = to_string(n);
        s = 'k' + s;
        n = s.size() - 1;
        int tem = pow(10, n - 1);
        int sum = 0;
        int ans = 0;
        int num = 0;
        for (int i = 1; i <= n; i++)
            num = num * 10 + (s[i] - '0');
        for (int i = 1; i <= n; i++)
        {
            int d = s[i] - '0';
            ans += sum * 45 * tem;
            sum = sum * 10 + d;
            ans += max(0, (d - 1 + 1) * (d - 1) / 2) * tem;
            num %= tem;
            ans += d * (num + 1);
            tem /= 10;
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;

    // solve
    Solution solution;
    auto result = solution.solve(n);

    // output
    cout << result << ""\n"";

    return 0;
}","math,dp",easy
214,"There is A crossing pawn at $A$on the board that needs to go to the target $B$point. Pawn walking rules: can go down, or right. At the same time, there is an opposing horse at the $C$point on the board, and the point where the horse is located and all the points reachable by the jump step are called the control point of the opposing horse. Therefore, it is called ""horse blocking the river and pawn"".
The board is represented by coordinates, $A$point $(0, 0)$, $B$point $(n, m)$, and the same horse position coordinates need to be given.
Now you are asked to calculate the number of paths that the pawn can take from point $A$to point $B$, assuming that the position of the horse is fixed, not that the pawn moves one step at a time.

solution main function
```cpp
class Solution
{
    public:
    long long solve(int n, int m, int x, int y)
}
```
Pass in parameters:
Four integers, $n,m,x,y$, represent the coordinates of point B and horse, respectively.

Return parameters:
An integer indicating the number of all paths.

Example 1:
Input: n=6,m=6,x=3,y=3
Output: 6

Constraints:
0<n,m,x,y@data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[8, 10, 20]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    long long solve(int n, int m, int x, int y) {
        int bx = n + 2, by = m + 2, mx = x + 2, my = y + 2;
        vector<long long> f(by + 1, 0);
        f[2] = 1;

        auto check = [&](int i, int j) {
            if (i == mx && j == my) return true;
            return (abs(mx - i) + abs(my - j) == 3) && (max(abs(mx - i), abs(my - j)) == 2);
        };

        for (int i = 2; i <= bx; i++) {
            for (int j = 2; j <= by; j++) {
                if (check(i, j)) {
                    f[j] = 0;
                } else {
                    f[j] += f[j - 1];
                }
            }
        }

        return f[by];
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m,x,y;
    cin>>n>>m>>x>>y;
    // solve
    Solution solution;
            auto result = solution.solve(n, m, x, y);
    
    // output
    cout << result ;

    return 0;
}",dp,medium
215,"# Problem Statement
Timur initially had a binary string$^{\dagger}$ $s$ (possibly of length $0$). He performed the following operation several (possibly zero) times:

-   Add $\texttt{0}$ to one end of the string and $\texttt{1}$ to the other end of the string. For example, starting from the string $\texttt{1011}$, you can obtain either $\color{red}{\texttt{0}}\texttt{1011}\color{red}{\texttt{1}}$ or $\color{red}{\texttt{1}}\texttt{1011}\color{red}{\texttt{0}}$.

You are given Timur's final string. What is the length of the **shortest** possible string he could have started with?

$^{\dagger}$ A binary string is a string (possibly the empty string) whose characters are either $\texttt{0}$ or $\texttt{1}$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, string &s) {
        // write your code here
    }
};
```
where:  
- return a single nonnegative integer  the shortest possible length of Timur's original string. Note that Timur's original string could have been empty, in which case you should output 0
.

# Example 1:  
- Input:  
n = 3
s = ""100""
- Output:  
1

# Constraints:  
- $1 \leq n \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, string &s)
    {
        int i = 0, j = n;
        while (i + 2 <= j && s[i] != s[j - 1])
            i++, j--;
        return j - i;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    string s;
    cin >> s;

    // solve
    Solution solution;
    auto result = solution.solve(n, s);

    // output
    cout << result << ""\n"";

    return 0;
}",two_pointers,medium
216,"Given the array nums, obtain a subsequence of the array whose sum of elements is strictly greater than the sum of the non included elements in such subsequence. 

If there are multiple solutions, return the subsequence with minimum size and if there still exist multiple solutions, return the subsequence with the maximum total sum of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array. 

Note that the solution with the given constraints is guaranteed to be unique. Also return the answer sorted in non-increasing order.

solution main function
```cpp
class Solution {
public:
    vector<int> solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [4,3,10,9,8]
Output: [10,9] 

Example 2:
Input: nums = [4,4,7,6,7]
Output: [7,7,6] 

Constraints:

1 <= nums.length <= @data
1 <= nums[i] <= 100

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> solve(vector<int>& nums) {
        vector<int> res;
        auto sub_sum = 0, half_sum = accumulate(begin(nums), end(nums), 0) / 2;
        priority_queue<int> pq(begin(nums), end(nums));
        while (sub_sum <= half_sum) {
            res.push_back(pq.top());
            sub_sum += res.back();
            pq.pop();
        }
        return res;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;cin>>n;
    vector<int> a;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        a.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(a);
    
    // output
    for(auto it:result) cout<<it<<' ';
    // cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","greedy,sort",easy
217,"You are given a 0-indexed m x n matrix grid consisting of positive integers.

You can start at any cell in the first column of the matrix, and traverse the grid in the following way:

    From a cell (row, col), you can move to any of the cells: (row - 1, col + 1), (row, col + 1) and (row + 1, col + 1) such that the value of the cell you move to, should be strictly bigger than the value of the current cell.

Return the maximum number of moves that you can perform.

solution main function

```cpp
class Solution {
public:
    int solve(vector<vector<int>>& grid) {
        
    }
};
```

Example 1:
Input: grid = [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]]
Output: 3

Example 2:
Input: grid = [[3,2,4],[2,1,9],[1,1,7]]
Output: 0

Constraints:

m == grid.length
n == grid[i].length
2 <= m, n <= 1000
4 <= m * n <= @data
1 <= grid[i][j] <= 10^6

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<vector<int>>& grid) {
        int M = grid.size(), N = grid[0].size();

        vector<vector<int>> dp(M, vector<int>(2, 0));

        for (int i = 0; i < M; i++) {
            dp[i][0] = 1;
        }

        int maxMoves = 0;
        for (int j = 1; j < N; j++) {
            for (int i = 0; i < M; i++) {
                if (grid[i][j] > grid[i][j - 1] && dp[i][0] > 0) {
                    dp[i][1] = max(dp[i][1], dp[i][0] + 1);
                }
                if (i - 1 >= 0 && grid[i][j] > grid[i - 1][j - 1] &&
                    dp[i - 1][0] > 0) {
                    dp[i][1] = max(dp[i][1], dp[i - 1][0] + 1);
                }
                if (i + 1 < M && grid[i][j] > grid[i + 1][j - 1] &&
                    dp[i + 1][0] > 0) {
                    dp[i][1] = max(dp[i][1], dp[i + 1][0] + 1);
                }

                maxMoves = max(maxMoves, dp[i][1] - 1);
            }

            for (int k = 0; k < M; k++) {
                dp[k][0] = dp[k][1];
                dp[k][1] = 0;
            }
        }

        return maxMoves;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    vector<vector<int> > mat;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=m;j++)
        {
            int x; cin>>x;
            temp.push_back(x);
        }
        mat.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(mat);
    
    // output
    cout << result << ""\n"";

    return 0;
}",dp,medium
218,"A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line.

You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed).

Return the number of indices where heights[i] != expected[i].

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& heights) {
        
    }
};
```

Example 1:
Input: heights = [1,1,4,2,1,3]
Output: 3

Example 2:
Input: heights = [5,1,2,3,4]
Output: 5

Constraints:

1 <= heights.length <= @data
1 <= heights[i] <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& heights) {
        vector<int> expected = heights;
        sort(expected.begin(), expected.end());
        int cnt = 0;
        for (int i = 0; i < heights.size(); ++i) {
            if (heights[i] != expected[i]) {
                cnt++;
            }
        }
        return cnt;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> num;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num);
    // output
    cout << result << ""\n"";
    // for(auto it:result) cout<<it<<' ';
    return 0;
}",sort,easy
219,"Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.

Return the number of nice sub-arrays.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& nums, int k) {
        
    }
};
```

Example 1:
Input: nums = [1,1,2,1,1], k = 3
Output: 2

Example 2:
Input: nums = [2,4,6], k = 1
Output: 0

Constraints:

1 <= nums.length <= @data
1 <= nums[i] <= 10^5
1 <= k <= nums.length

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums, int k) {
        return atMost(nums, k) - atMost(nums, k - 1);
    }

private:
    int atMost(vector<int>& nums, int k) {
        int windowSize = 0, subarrays = 0, start = 0;

        for (int end = 0; end < nums.size(); end++) {
            windowSize += nums[end] % 2;
            // Find the first index start where the window has exactly k odd
            // elements.
            while (windowSize > k) {
                windowSize -= nums[start] % 2;
                start++;
            }
            // Increment number of subarrays with end - start + 1.
            subarrays += end - start + 1;
        }

        return subarrays;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,k;
    vector<int> num;
    cin>>n>>k;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num,k);
    
    // output
    cout<<result;
    return 0;
}",math,medium
220,"# Problem Statement
You have $5$ different types of coins, each with a value equal to one of the first $5$ triangular numbers: $1$, $3$, $6$, $10$, and $15$. These coin types are available in abundance. Your goal is to find the minimum number of these coins required such that their total value sums up to exactly $n$.

We can show that the answer always exists.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n) {
        // write your code here
    }
};
```
where:  
- return: the minimum number of coins required.

# Example 1:  
- Input:  
n = 2
- Output:  
2

# Constraints:  
- $1 \leq n \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10000, 1000000, 100000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n)
    {
        array<int, 5> a = {1, 3, 6, 10, 15};
        int cnt = 0;
        if (n >= 30)
        {
            int num = n / 15;
            n = n % 15 + 15 * 2;
            cnt = num - 2;
        }
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int j = 1; j <= n; j++)
            for (int i = 0; i < 5; i++)
            {
                if (j - a[i] >= 0)
                    dp[j] = min(dp[j], dp[j - a[i]] + 1);
            }
        return dp[n] + cnt;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;

    // solve
    Solution solution;
    auto result = solution.solve(n);

    // output
    cout << result << ""\n"";

    return 0;
}","dp,math",hard
221,"Xuan Xuan and Kai Kai are playing a game called ""Dragon Tiger Fight"", the game board is a line segment, there are $n$barracks on the line segment (numbered $1 \sim n$from left to right), and the adjacent numbered barracks are separated by $1$cm, that is, the board is a line segment with a length of $n-1$cm. There are $c_i$engineers in the $i$barracks.
Xuan Xuan is on the left, representing ""dragon""; Kai Kai is on the right, representing ""Tiger"". They use barracks $m$as a demarcation line, the sappers on the left belong to the Dragon force, the sappers on the right belong to the tiger force, and the sappers in barracks $m$are very tangled, they don't belong to either side.
The momentum of a barracks is: the number of engineers in the barracks $\times $the distance between the barracks and the $m$barracks; The power of a party participating in the game is defined as the sum of the momentum of all the barracks belonging to that party.
During the game, at some point, a total of $s_1$engineers suddenly appeared in the $p_1$barracks. As a friend of Xuan Xuan and Kai Kai, you know that if the gap between the two sides is too great, Xuan Xuan and Kai Kai are not willing to continue to play. In order for the game to continue, you need to select a barracks $p_2$and send all your $s_2$engineers to the barracks $p_2$, making the momentum gap between the two sides as small as possible.
Note: The sengineer you hold in the barracks has the same power as the other Sengineers in that barracks (if you fall in the $m$barracks, you don't belong to any power).

solution main function
```cpp
class Solution
{
    public:
    long long solve(long long n, long long m, long long p1, long long s1, long long s2, vector<long long> &c)
}
```

Pass in parameters:
5 integers: $n,m,p_1,s_1,s_2$.
1 array, c contains $n$positive integers, the first positive integer represents the number of engineers in the barracks numbered $i$at the beginning of $c_i$.

Return parameters:
An integer $p_2$indicates the barracks number you selected. If multiple numbers are optimal, the smallest number is used.

Example 1:
Input: n=6,m=4,p1=6,s1=5,s2=2,c=[2, 3, 2, 3, 2, 3]
Output: 2

Example 2:
Input: n = 6, m = 5, p = 4, s1 = 1, s2 = 1, c = [1, 1, 1, 1, 1, 16]
Output: 1

Constraints:
1<m<n, 1p1n, 1n@data, 1c[i],s1,s2 10^9
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[5, 100, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution
{
public:
    long long solve(long long n, long long m, long long p1, long long s1, long long s2, vector<long long> &c)
    {
        c.insert(c.begin(), 0);
        long long gap = 0;
        double where;
        long long ans;
        c[p1] += s1;
        for (long long i = 1; i <= n; i++)
            gap += (m - i) * c[i];
        double dgap = gap;
        where = m + dgap / s2;
        if (where >= n)
            ans = n;
        else if (where <= 1)
            ans = 1;
        else
        {
            long long iwhere = where;
            if (iwhere == where)
                ans = iwhere;
            else
            {
                long long ans1 = abs(gap + (m - iwhere) * s2);
                long long ans2 = abs(gap + (m - iwhere - 1) * s2);
                ans = ans1 <= ans2 ? iwhere : iwhere + 1;
            }
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    long long  n,m,p1,s1,s2;
    cin>>n;
    vector<long long> c;
    for(long long i=1,x;i<=n;i++)
    {
        cin>>x;
        c.push_back(x);
    }
    cin>>m>>p1>>s1>>s2;
    // solve
    Solution solution;
            auto result = solution.solve(n,m,p1,s1,s2,c);
    
    // output
    cout << result << ""\n"";

    return 0;
}",greedy,hard
222,"# Problem Statement:
You are given $n$ of integers $a_1, a_2, \ldots, a_n$. Process $q$ queries of two types:

-   query of the form ""0 $x_j$"": add the value $x_j$ to all even elements of the array $a$,
-   query of the form ""1 $x_j$"": add the value $x_j$ to all odd elements of the array $a$.

Note that when processing the query, we look specifically at the odd/even value of $a_i$, not its index.

After processing each query, print the sum of the elements of the array $a$.

The main function of the solution is defined as: 
```cpp
vector<long long> solve(int &n, int &q, vector<int> &a, vector<pair<int, int>> &queries) {
    // write your code here
}
```
Where:  
- `n` is an integer representing the size of the array $a$.  
- `q` is an integer representing the number of queries.  
- `a` is a vector of integers, representing the initial array.  
- `queries` is a vector of pairs, where each pair represents a query of the given type and value.  
- The function should return a vector of long long integers, representing the sum of the array after processing each query.

# Example 1:
- Input:  
n = 1  
q = 1  
a = [1]  
queries = [(1, 1)]
- Output:  
[2]

# Constraints:
- $1 \leq n, q \leq @data$  
- $1 \leq a[i] \leq 10^9$  
- $1 \leq x_j \leq 10^4$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB","[10, 1000, 100000]",1000.0,"[[6400, 3200, 1280]]","class Solution
{
public:
    vector<long long> solve(int &n, int &q, vector<int> &a, vector<pair<int, int>> &queries)
    {
        int cnt[2]{};
        long long sum[2]{};

        for (int i = 0; i < n; i++)
        {
            int x = a[i];
            cnt[x % 2]++;
            sum[x % 2] += x;
        }
        vector<long long> ans;
        for (int i = 0; i < q; i++)
        {
            int t = queries[i].first;
            int x = queries[i].second;
            sum[t] += 1LL * x * cnt[t];
            if (x % 2)
            {
                cnt[!t] += cnt[t];
                sum[!t] += sum[t];
                cnt[t] = sum[t] = 0;
            }
            ans.push_back(sum[0] + sum[1]);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, q;
    cin >> n >> q;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];
    vector<pair<int, int>> queries(q);
    for (int i = 0; i < q; i++)
        cin >> queries[i].first >> queries[i].second;

    // solve
    Solution solution;
    auto result = solution.solve(n, q, a, queries);

    // output
    for (auto &x : result)
        cout << x << ""\n"";

    return 0;
}",math,medium
223,"Bracteoles are ready to drive down the road.
There are $n$stops on the highway, numbered from $1$to $n$. The distance between site $i$and site $i + 1$is $v_i$km.
Every station on the highway can be refueled, the price of a liter of gas at the station numbered $i$is $a_i$, and each station only sells integer liters of gas.
The Bract wants to drive from the site $1 to the site $n$. At first the Bract is at the site $1 and the tank of the car is empty. It is known that the tank of the car is large enough to hold as much oil as it wants, and it can move forward $d$km per liter of oil. Ask the bract from the site $1$to the site $n$, at least how much money to spend on fuel?

solution main function
```cpp
class Solution
{
    public:
        long long solve(int n, int d, vector<int> &v, vector<int> &a)
}
```
Pass in parameters:
2 integers, $n,d$.
2 arrays, v containing $n-1 $positive integers $v_1, v_2\dots v_{n-1}$, respectively, representing the distance between sites.
a contains $n$positive integers $a_1, a_2 \dots a_n$, which represent the price of refueling at different stations.

Return parameters:
An integer indicating how much the bract must spend to refuel from the site $1$to the site $n$.

Example 1:
Input: n = 5, d = 4, n = [10, 10, 10, 10], a = [9, 8, 9, 6, 5]
Output: 79

Constraints:
1n@data, 1d10^ 5,1 a[i],v[i] 10^5
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution
{
public:
    long long solve(int n, int d, vector<int> &v, vector<int> &a)
    {
        long long ans = 0, s = 0;
        int mi = INT_MAX;
        v.insert(v.begin(), 0);
        a.insert(a.begin(), 0);
        for (int i = 1; i < n; i++)
        {
            s += v[i];
            mi = min(mi, a[i]);
            if (s > 0)
            {
                ans += (s + d - 1) / d * mi;
                s -= (s + d - 1) / d * d;
            }
        }

        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,d; cin>>n>>d;
    vector<int> dist,val;
    for(int i=1,x;i<n;i++)
    {
        cin>>x;
        dist.push_back(x);
    }
    for(int i=1,x;i<=n;i++)
    {
        cin>>x;
        val.push_back(x);
    }
    // solve
    Solution solution;
            auto result = solution.solve(n,d,dist,val);
    
    // output
    cout << result << ""\n"";

    return 0;
}",dp,hard
224,"There is an undirected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.
You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given an integer array restricted which represents restricted nodes.
Return the maximum number of nodes you can reach from node 0 without visiting a restricted node.
Note that node 0 will not be a restricted node.

solution main function
```cpp
class Solution
{
    public:
    int solve(int n, vector<vector<int>>& edges, vector<int>& restricted)
}
```

Example 1:
Input: n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]
Output: 4

Example 2:
Input: n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]
Output: 3

Constraints:
2 <= n <= @data
edges.length == n - 1
edges[i].length == 2
0 <= ai, bi < n
ai != bi
edges represents a valid tree.
1 <= restricted.length < n
1 <= restricted[i] < n
All the values of restricted are unique.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 1000, 100000]",1000.0,"[[150000, 15000, 1500]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
    vector<int> p,sz;
    vector<bool> r;
public:
    int find(int x) {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    void unionSet(int a, int b) {
        a = find(a), b = find(b);
        if (a != b) {
            if (sz[a] > sz[b]) swap(a, b);
            p[a] = b, sz[b] += sz[a];
        }
    }
    int solve(int n, vector<vector<int>>& edges, vector<int>& restricted) {
        for (int i = 0; i <= n; i ++ ) p.push_back(i),sz.push_back(1),r.push_back(false);
        for (auto &x : restricted) r[x] = true;
        for (auto &e : edges) if (!r[e[1]] && !r[e[0]]) unionSet(e[0], e[1]);
        return sz[find(0)];
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m;
    cin>>n>>m;
    vector<vector<int> > e;
    vector<int> re;
    for(int i=1;i<n;i++)
    {
        int x,y; cin>>x>>y;
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        e.push_back(temp);
    }
    for(int i=1;i<=m;i++)
    {
        int x; cin>>x;
        re.push_back(x);
    }
    // solve
    Solution solution;
            auto result = solution.solve(n,e,re);
    
    // output
    cout<<result;
    return 0;
}",graph,medium
225,"Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string """".

A string is palindromic if it reads the same forward and backward.

The answer is modulus 998244353

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& arr) {
        
    }
};
```

Example 1:
Input: arr = [1,4,2,5,3]
Output: 58

Example 2:
Input: arr = [1,2]
Output: 3

Constraints:

1 <= arr.length <= @data
1 <= arr[i] <= 1000

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    #define ll long long
    const ll mod= 998244353;
    int solve(vector<int>& arr) {
        int n = int(arr.size());
        ll answer = 0;
        
        for (int i = 0; i < n; ++i) {
            ll left = i, right = n - i - 1;
            answer += arr[i] * (left / 2ll + 1ll)%mod * (right / 2ll + 1ll)%mod;
            answer%=mod;
            answer += arr[i] * ((left + 1ll) / 2ll)%mod * ((right + 1ll) / 2ll)%mod;
            answer%=mod;
        }
        
        return answer;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    vector<int> num;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num);
    
    // output
    cout<<result;
    return 0;
}",math,hard
226,"You are given a 2D array of axis-aligned rectangles. Each rectangle[i] = [xi1, yi1, xi2, yi2] denotes the ith rectangle where (xi1, yi1) are the coordinates of the bottom-left corner, and (xi2, yi2) are the coordinates of the top-right corner.

Calculate the total area covered by all rectangles in the plane. Any area covered by two or more rectangles should only be counted once.

Return the total area. Since the answer may be too large, return it modulo 10^9 + 7.

solution main function

```cpp
class Solution {
public:
    int solve(vector<vector<int>>& rectangles) {
        
    }
};
```

Example 1:
Input: rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]
Output: 6

Example 2:
Input: rectangles = [[0,0,1000000000,1000000000]]
Output: 49

Constraints:

1 <= rectangles.length <= @data
rectanges[i].length == 4
0 <= xi1, yi1, xi2, yi2 <= 10^9
xi1 <= xi2
yi1 <= yi2

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[50, 100, 1000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
   
    long long func(vector<pair<int,int>>& intervals, int m) {
        if(intervals.empty()) return 0;
        
        sort(intervals.begin(), intervals.end());
        long long area = 0;
        int prev = -1;
        
        for(auto& it : intervals) {
            // Calculate height without modulo
            long long height = (long long)max(0, (it.second - max(prev, it.first)));
            area += height;  // Just add the height
            prev = max(prev, it.second);
        }
        
        return area;  // Return pure height sum
    }
    
    int solve(vector<vector<int>>& rectangles) {
        const int MOD = 1e9 + 7;
        vector<vector<int>> lines;
        
        for(auto& rect : rectangles) {
            lines.push_back({rect[0], 0, rect[1], rect[3]});
            lines.push_back({rect[2], 1, rect[1], rect[3]});
        }
        
        sort(lines.begin(), lines.end());
        
        int prev_x = lines[0][0];
        long long total_area = 0;
        vector<pair<int,int>> intervals;
        
        for(const auto& line : lines) {
            long long width = (long long)(line[0] - prev_x);
            long long height = func(intervals, width);
            // Multiply width and height before taking modulo
            total_area += width * height;  
            
            if(line[1] == 1) {
                auto it = find(intervals.begin(), intervals.end(), 
                             make_pair(line[2], line[3]));
                if(it != intervals.end()) {
                    intervals.erase(it);
                }
            } else {
                intervals.push_back({line[2], line[3]});
            }
            prev_x = line[0];
        }
        
        // Take modulo only at the end
        return total_area % MOD;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<vector<int> > s;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=4;j++)
        {
            int x; cin>>x;
            temp.push_back(x);
        }
        s.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    cout << result << ""\n"";

    return 0;
}",data_structures,hard
227,"# Problem Statement
On another boring day, Egor got bored and decided to do something. But since he has no friends, he came up with a game to play.

Egor has a deck of $n$ cards, the $i$\-th card from the top has a number $a_i$ written on it. Egor wants to play a certain number of rounds until the cards run out. In each round, he takes a non-zero number of cards from the top of the deck and finishes the round. If the sum of the numbers on the cards collected during the round is between $l$ and $r$, inclusive, the round is won; otherwise, it is lost.

Egor knows by heart the order of the cards. Help Egor determine the maximum number of rounds he can win in such a game. Note that Egor is not required to win rounds consecutively.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &l, int &r, vector<int> &a) { 
        // write your code here
    }
};
```
where:  
- the return value is the maximum number of rounds Egor can win

# Example 1:  
- Input:  
n = 5, l = 3, r = 10
a = [2, 1, 11, 3, 7]
- Output:  
3

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq l \leq r \leq 10^9$
- $1 \leq a[i] \leq 10^9$ 
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 720, 64]]","class Solution
{
public:
    int solve(int &n, int &l, int &r, vector<int> &a)
    {
        int start = 0;
        int current_sum = 0;
        int max_rounds = 0;
        for (int end = 0; end < n; ++end)
        {
            current_sum += a[end];
            while (current_sum > r && start <= end)
            {
                current_sum -= a[start];
                ++start;
            }
            if (current_sum >= l && current_sum <= r)
            {
                ++max_rounds;
                current_sum = 0;
                start = end + 1; 
            }
        }
        return max_rounds;
    }
};
","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, l, r;
    cin >> n >> l >> r;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, l, r, a);

    // output
    cout << result << ""\n"";

    return 0;
}","two_pointers,dp,math",hard
228,"Given two positive integers n and k, the binary string Sn is formed as follows:

    S1 = ""0""
    Si = Si - 1 + ""1"" + reverse(invert(Si - 1)) for i > 1

Where + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).

For example, the first four strings in the above sequence are:

    S1 = ""0""
    S2 = ""011""
    S3 = ""0111001""
    S4 = ""011100110110001""

Return the kth bit in Sn. It is guaranteed that k is valid for the given n.

solution main function

```cpp
class Solution {
public:
    char solve(int n, int k) {
        
    }
};
```

Example 1:
Input: n = 3, k = 1
Output: ""0""

Example 2:
Input: n = 4, k = 11
Output: ""1""

Constraints:

1 <= n <= @data
1 <= k <= 2^n - 1

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 15, 20]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    char solve(int n, int k) {
        // Find the position of the rightmost set bit in k
        // This helps determine which ""section"" of the string we're in
        int positionInSection = k & -k;

        // Determine if k is in the inverted part of the string
        // This checks if the bit to the left of the rightmost set bit is 1
        bool isInInvertedPart = ((k / positionInSection) >> 1 & 1) == 1;

        // Determine if the original bit (before any inversion) would be 1
        // This is true if k is even (i.e., its least significant bit is 0)
        bool originalBitIsOne = (k & 1) == 0;

        if (isInInvertedPart) {
            // If we're in the inverted part, we need to flip the bit
            return originalBitIsOne ? '0' : '1';
        } else {
            // If we're not in the inverted part, return the original bit
            return originalBitIsOne ? '1' : '0';
        }
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,k;
    cin>>n>>k;
    // solve
    Solution solution;
    auto result = solution.solve(n,k);
    
    // output
    cout<<result;
    return 0;
}",string,hard
229,"Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.

A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.

solution main function

```cpp
class Solution {
public:
    vector<int> solve(vector<vector<int>>& matrix) {
        
    }
};
```

Example 1:
Input: matrix = [[3,7,8],[9,11,13],[15,16,17]]
Output: [15]

Example 2:
Input: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]
Output: [12]

Constraints:

m == mat.length
n == mat[i].length
1 <= n, m <= @data
1 <= matrix[i][j] <= 10^5.
All elements in the matrix are distinct.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 100, 500]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> solve (vector<vector<int>>& matrix) {
        int N = matrix.size(), M = matrix[0].size();
        
        int rMinMax = INT_MIN;
        for (int i = 0; i < N; i++) {

            int rMin = INT_MAX;
            for (int j = 0; j < M; j++) {
                rMin = min(rMin, matrix[i][j]);
            }
            rMinMax = max(rMinMax, rMin);
        }
        
        int cMaxMin = INT_MAX;
        for (int i = 0; i < M; i++) {

            int cMax = INT_MIN;
            for (int j = 0; j < N; j++) {
                cMax = max(cMax, matrix[j][i]);
            }
            cMaxMin = min(cMaxMin, cMax);
        }
        
        if (rMinMax == cMaxMin) {
            return {rMinMax};
        }
        
        return {};
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    vector<vector<int> > s;
    int n,m; cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1,x;j<=m;j++)
        {
            scanf(""%d"",&x);
            temp.push_back(x);
        }
        s.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    sort(result.begin(),result.end());
    for(auto it:result) cout<<it<<' ';
    return 0;
}",math,easy
230,"Given a valid parentheses string s, return the nesting depth of s. The nesting depth is the maximum number of nested parentheses.

solution main function

```cpp
class Solution {
public:
    int solve(string s) {
        
    }
};
```

Example 1:
Input: s = ""(1)+((2))+(((3)))""
Output: 3

Example 2:
Input: s = ""()(())((()()))""
Output: 3


Constraints:


1 <= s.length <= @data
s consists of digits 0-9 and characters '+', '-', '*', '/', '(', and ')'.
It is guaranteed that parentheses expression s is a VPS.


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(string s) {
        int ans = 0;
        int openBrackets = 0;

        for (char c : s) {
            if (c == '(') {
                openBrackets++;
            } else if (c == ')') {
                openBrackets--;
            }
            
            ans = max(ans, openBrackets);
        }
        
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string s;
    cin>>s;
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    cout<<result;
    return 0;
}",string,easy
231,"# Problem Statement
You are given a sequence $a=[a_1,a_2,\dots,a_n]$ consisting of $n$ **positive** integers.

Let's call a group of consecutive elements a segment. Each segment is characterized by two indices: the index of its left end and the index of its right end. Denote by $a[l,r]$ a segment of the sequence $a$ with the left end in $l$ and the right end in $r$, i.e. $a[l,r]=[a_l, a_{l+1}, \dots, a_r]$.

For example, if $a=[31,4,15,92,6,5]$, then $a[2,5]=[4,15,92,6]$, $a[5,5]=[6]$, $a[1,6]=[31,4,15,92,6,5]$ are segments.

We split the given sequence $a$ into segments so that:

-   each element is in **exactly** one segment;
-   the sums of elements for all segments are **equal**.

For example, if $a$ = \[$55,45,30,30,40,100$\], then such a sequence can be split into three segments: $a[1,2]=[55,45]$, $a[3,5]=[30, 30, 40]$, $a[6,6]=[100]$. Each element belongs to exactly segment, the sum of the elements of each segment is $100$.

Let's define thickness of split as the length of the longest segment. For example, the thickness of the split from the example above is $3$.

Find the minimum thickness among all possible splits of the given sequence of $a$ into segments in the required way.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the maximum possible number of students in a balanced team.

# Example 1:  
- Input:  
n = 6
a = [10, 17, 12, 15, 2]
- Output:  
3

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        int ans = 0;
        sort(a.begin(), a.end());
        for (int i = 0, j = 0; i < n; i += 1)
        {
            while (j < n and a[j] <= a[i] + 5)
                j += 1;
            ans = max(ans, j - i);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","sort,two_pointers",hard
232,"Given an undirected graph with n vertices (numbered 1 to n) and m edges, find the minimum number of strokes needed to draw all the edges in the graph. 
The `edges` array represents the edges in the graph, where `edges[i] = [a, b]` indicates that there is an undirected edge between node `a` and node `b`.

solution main function
```cpp
class Solution
{
    public:
    int solve(int n, vector<vector<int>>& edges)
    {

    }
}
```

Example 1:
Inputn = 5, edges = [[2,3],[2,4],[2,5],[3,4],[4,5]]
Output: 1

Constraints:

2 <= n <= @data
edges.size <=5*@data

edges[i].size ==2
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution
{
    public:
    int solve(int n, vector<vector<int>>& edges)
    {
        int m=edges.size(),ans=0;
        vector<int> cnt;
        cnt.resize(n+10,0);
        for(auto it:edges)
            for(auto i:it)
                cnt[i]++;
        for(int i=1;i<=n;i++)
            if(cnt[i]&1)
			    ans++;
        if(ans==0) return ans; 
        return ans/2;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    vector< vector<int> > edge;
    for(int i=1,x,y;i<=m;i++)
    {
        scanf(""%d%d"",&x,&y);
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        edge.push_back(temp);
    }
    // solve
    Solution solution;
            auto result = solution.solve(n,edge);
    
    // output
    cout << result << ""\n"";

    return 0;
}",graph,easy
233,"Given a string s, return the number of unique palindromes of length three that are a subsequence of s.

Note that even if there are multiple ways to obtain the same subsequence, it is still only counted once.

A palindrome is a string that reads the same forwards and backwards.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

    For example, ""ace"" is a subsequence of ""abcde"".

solution main function

```cpp
class Solution {
public:
    int solve(string s) {
        
    }
};
```

Example 1:
Input: s = ""aabca""
Output: 3

Example 2:
Input: s = ""adc""
Output: 0

Constraints:

3 <= s.length <= @data
s consists of only lowercase English letters.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(string s) {
        vector<int> first;
        first.resize(26, -1);
        vector<int> last;
        last.resize(26, -1);
        
        for (int i = 0; i < s.size(); i++) {
            int curr = s[i] - 'a';
            if (first[curr] == - 1) {
                first[curr] = i;
            }
            
            last[curr] = i;
        }
        
        int ans = 0;
        for (int i = 0; i < 26; i++) {
            if (first[i] == -1) {
                continue;
            }
            
            unordered_set<char> between;
            for (int j = first[i] + 1; j < last[i]; j++) {
                between.insert(s[j]);
            }
            
            ans += between.size();
        }
        
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string s; cin>>s;
    // solve
    Solution solution;
    auto result = solution.solve(s);
    // output
    cout << result << ""\n"";
    // for(auto it:result) cout<<it<<' ';
    return 0;
}","string,bit_manipulation",hard
234,"# Problem Statement
You are given a cyclic array $a_1, a_2, \ldots, a_n$.

You can perform the following operation on $a$ at most $n - 1$ times:

-   Let $m$ be the current size of $a$, you can choose any two adjacent elements where the previous one is no greater than the latter one (In particular, $a_m$ and $a_1$ are adjacent and $a_m$ is the previous one), and delete exactly one of them. In other words, choose an integer $i$ ($1 \leq i \leq m$) where $a_i \leq a_{(i \bmod m) + 1}$ holds, and delete exactly one of $a_i$ or $a_{(i \bmod m) + 1}$ from $a$.

Your goal is to find the minimum number of operations needed to make all elements in $a$ equal.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the minimum number of operations needed to make all elements in a equal.

# Example 1:  
- Input:  
n = 3, a = [1, 2, 3]
- Output:  
2

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq n$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        sort(a.begin(), a.end());
        int ans = 0;
        int res = 0;
        int zhi = a[0];
        for (int i = 0; i <= n - 1; i++)
        {
            if (a[i] == zhi)
            {
                res++;
            }
            else
            {
                ans = max(ans, res);
                zhi = a[i];
                res = 1;
            }
        }
        ans = max(ans, res);
        return n - ans;
    }

};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",sort,easy
235,"# Problem Statement
Alice and Bob are playing a game. They have an array $a_1, a_2,\ldots,a_n$. The game consists of two steps:

-   First, Alice will remove **at most** $k$ elements from the array.
-   Second, Bob will multiply **at most** $x$ elements of the array by $-1$.

Alice wants to maximize the sum of elements of the array while Bob wants to minimize it. Find the sum of elements of the array after the game if both players play optimally.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &k, int &x, vector<int> &a) {   
        // write your code here
    }
};
```
where:  
- `n` is the number of elements in the array, `k` is the maximum number of elements Alice can remove, and `x` is the maximum number of elements Bob can multiply by $-1$.
- `a` is the array of elements.
- The return value is the sum of elements of the array after the game.

# Example 1:  
- Input:  
n = 4, k = 1, x = 1
a = [3, 1, 2, 4]
- Output:  
2

# Constraints:  
- $1 \leq n \leq @data$  
- $1 \leq x,k \leq n$
- $1 \leq a[i] \leq 10^3$ 
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, int &k, int &x, vector<int> &a)
    {
        sort(a.begin(), a.end());
        int ans = -1e9;
        for (int i = 1; i < n; i++)
            a[i] += a[i - 1];
        for (int i = 0; i <= k; i++)
        {
            int res = -((n - i) == 0 ? 0 : a[n - i - 1]) + 2 * ((n - i - x) > 0 ? a[n - i - x - 1] : 0);
            ans = max(ans, res);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, k, x;
    cin >> n >> k >> x;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, k, x, a);

    // output
    cout << result << ""\n"";

    return 0;
}","math,sort",medium
236,"Balanced strings are those that have an equal quantity of 'L' and 'R' characters.

Given a balanced string s, split it into some number of substrings such that:

    Each substring is balanced.

Return the maximum number of balanced strings you can obtain.

solution main function
```cpp
class Solution {
public:
    int solve(string s) {
        
    }
};
```

Example 1:
Input: s = ""RLRRLLRLRL""
Output: 4

Example 2:
Input: s = ""RLRRRLLRLL""
Output: 2

Constraints:


2 <= s.length <= @data
s[i] is either 'L' or 'R'.
s is a balanced string.


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(string s) {

        int x=0,l=0,r=0,n=s.size();

        for(int i=0;i<n;i++){
            if(s[i]=='R') r++;
            else l++;

            if(r==l){
                x++;
                l=0;
                r=0;
            }
        }
        return x;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string s;
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","string,greedy,other",easy
237,"# Problem Statement
Today, Cat and Fox found an array $a$ consisting of $n$ non-negative integers.

Define the loneliness of $a$ as the **smallest** positive integer $k$ ($1 \le k \le n$) such that for any two positive integers $i$ and $j$ ($1 \leq i, j \leq n - k +1$), the following holds:

$$
a_i | a_{i+1} | \ldots | a_{i+k-1} = a_j | a_{j+1} | \ldots | a_{j+k-1},
$$
 where $x | y$ denotes the bitwise OR of $x$ and $y$. In other words, for every $k$ consecutive elements, their bitwise OR should be the same. Note that the loneliness of $a$ is well-defined, because for $k = n$ the condition is satisfied.

Cat and Fox want to know how lonely the array $a$ is. Help them calculate the loneliness of the found array.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the loneliness of the given array.

# Example 1:  
- Input:  
n = 3
a = [2, 2, 2]
- Output:  
1

# Constraints:  
- $1 \leq n \leq @data$
- $0 \leq a[i] \leq 10^6$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        int ans = 1;
        for (int j = 0; j < 20; j++)
        {
            int lst = -1;
            for (int i = 0; i < n; i++)
            {
                if (a[i] >> j & 1)
                {
                    ans = max(ans, i - lst);
                    lst = i;
                }
            }
            if (lst != -1)
                ans = max(ans, n - lst);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","bit_manipulation,binary,two_pointers,math",medium
238,"# Problem Statement
After receiving yet another integer array $a_1, a_2, \ldots, a_n$ at her birthday party, Index decides to perform some operations on it.

Formally, there are $m$ operations that she is going to perform in order. Each of them belongs to one of the two types:

-   $\texttt{1 l r}$. Given two integers $l$ and $r$, for all $1 \leq i \leq n$ such that $l \leq a_i \leq r$, set $a_i := a_i + 1$.
-   $\texttt{2 l r}$. Given two integers $l$ and $r$, for all $1 \leq i \leq n$ such that $l \leq a_i \leq r$, set $a_i := a_i - 1$.

For example, if the initial array $a = [7, 1, 3, 4, 3]$, after performing the operation $\texttt{+} \space 2 \space 4$, the array $a = [7, 1, 4, 5, 4]$. Then, after performing the operation $\texttt{-} \space 1 \space 10$, the array $a = [6, 0, 3, 4, 3]$.

Index is curious about the maximum value in the array $a$. Please help her find it after each of the $m$ operations.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    vector<int> solve(int &n, int &m, vector<int> &a, vector<array<int, 3>> &ops) {
        // write your code here
    }
};
```
where:  
- `ops` is the array of operations, each element is an array of length 3, representing an operation
- return an array, where the elements are the maximum value after each operation

# Example 1:  
- Input:  
n = 5, m = 5
a = [1, 2, 3, 2, 1]
ops = [[1, 1, 3], [2, 2, 3], [1, 1, 2], [1, 2, 4], [2, 6, 8]]
- Output:  
[4, 4, 4, 5, 5]

# Constraints:  
- $1 \leq n, m \leq @data$
- $1 \leq a[i] \leq 10^9$ 
- $1 \leq l \leq r \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 1280, 640]]","class Solution
{
public:
    vector<int> solve(int &n, int &m, vector<int> &a, vector<array<int, 3>> &ops)
    {
        vector<int> res;
        int mx = *max_element(a.begin(), a.end());
        for (auto &[op, l, r] : ops)
        {
            if (l <= mx && mx <= r)
                mx += op == 1 ? 1 : -1;
            res.push_back(mx);
        }
        return res;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, m;
    cin >> n >> m;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];
    vector<array<int, 3>> ops(m);
    for (int i = 0; i < m; i++)
        cin >> ops[i][0] >> ops[i][1] >> ops[i][2];

    // solve
    Solution solution;
    auto result = solution.solve(n, m, a, ops);

    // output
    for (auto &x : result)
        cout << x << "" "";
    cout << ""\n"";

    return 0;
}","greedy,data_structures",easy
239,"# Problem Statement
The next lecture in a high school requires two topics to be discussed. The $i$\-th topic is interesting by $a_i$ units for the teacher and by $b_i$ units for the students.

The pair of topics $i$ and $j$ ($i &lt; j$) is called **good** if $a_i + a_j &gt; b_i + b_j$ (i.e. it is more interesting for the teacher).

Your task is to find the number of **good** pairs of topics.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, vector<int> &a, vector<int> &b) {
        // write your code here
    }
};
```
where:  
- return: the number of **good** pairs of topics.

# Example 1:  
- Input:  
n = 5
a = [4, 8, 2, 6, 2]
b = [4, 5, 4, 1, 3] 
- Output:  
7

# Constraints:  
- $2 \leq n \leq @data$
- $1 \leq a[i], b[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(int &n, vector<int> &a, vector<int> &b)
    {
        for (int i = 0; i < n; i++)
            a[i] -= b[i];
        sort(a.begin(), a.end());
        long long ans = 0;
        for (int i = 0, j = n; i < n; i++)
        {
            while (j > 0 && a[i] + a[j - 1] > 0)
                j--;
            ans += n - max(i + 1, j);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n), b(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];
    for (int i = 0; i < n; i++)
        cin >> b[i];
    // solve
    Solution solution;
    auto result = solution.solve(n, a, b);

    // output
    cout << result << ""\n"";

    return 0;
}","two_pointers,sort",easy
240,"Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.
Return the maximum product you can get.
The answer is modulus 998244353

solution main function
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

Example 1:
Input: n = 1
Output: 1

Example 2:
Input: n = 2
Output: 5

Constraints:
1 <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[50, 1000, 1000000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    const long long mod=998244353;
    int power(long long x,long long y)
    {
        long long temp=1;
        while(y)
        {
            if(y&1) temp=temp*x%mod;
            x=x*x%mod; y>>=1;
        }
        return temp;
    }
    int solve(int n) {
        if (n <= 3) {
            return n - 1;
        }
        int quotient = n / 3;
        int remainder = n % 3;
        if (remainder == 0)
            return power(3, quotient);
        else if (remainder == 1)
            return power(3, quotient - 1) * 4ll%mod;
        else
            return power(3, quotient) * 2ll%mod;
    }
};","#include <bits/stdc++.h>
#include <iterator>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
            auto result = solution.solve(n);
    
    // output
    cout<<result;
    return 0;
}",math,medium
241,"You are working in a ball factory where you have n balls numbered from lowLimit up to highLimit inclusive (i.e., n == highLimit - lowLimit + 1), and an infinite number of boxes numbered from 1 to infinity.

Your job at this factory is to put each ball in the box with a number equal to the sum of digits of the ball's number. For example, the ball number 321 will be put in the box number 3 + 2 + 1 = 6 and the ball number 10 will be put in the box number 1 + 0 = 1.

Given two integers lowLimit and highLimit, return the number of balls in the box with the most balls.

solution main function
```cpp
class Solution {
public:
    int solve(int lowLimit, int highLimit) {
        
    }
};
```

Example 1:
Input: lowLimit = 1, highLimit = 10
Output: 2

Example 2:
Input: lowLimit = 5, highLimit = 15
Output: 2

Constraints:

1 <= lowLimit <= highLimit <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
private:
    int sum(int n) {
        int s = 0;
        for(; n > 0; n /= 10){
            s += n % 10;
        }
        return s;
    }
public:
    int solve(int lowLimit, int highLimit) {
        int cnt[46] ={0}; //10^5 means 9+9+9+9+9 = 45
        int m = 0;
        for (int n = lowLimit; n<=highLimit; n++) {
            int box = sum(n);
            cnt[box]++;
            m = max(m, cnt[box]);
        }
        return m;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m;cin>>n>>m;
    // solve
    Solution solution;
    auto result = solution.solve(n,m);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",sort,easy
242,"# Problem Statement
You received an $n\times m$ grid from a mysterious source. The source also gave you a magic positive integer constant $k$.

The source told you to color the grid with some colors, satisfying the following condition:

-   If $(x_1,y_1)$, $(x_2,y_2)$ are two distinct cells with the same color, then $\max(|x_1-x_2|,|y_1-y_2|)\ge k$.

You don't like using too many colors. Please find the minimum number of colors needed to color the grid.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &m, int &k) {
        // write your code here
    }
};
```
where:  
- return: the minimum number of colors needed to color the grid.

# Example 1:  
- Input: 
n = 3, m = 3, k = 2
- Output:  
4

# Constraints:  
- $1 \leq n, m \leq @data$
- $1 \leq k \leq 10^4$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, int &m, int &k)
    {
        return min(n, k) * min(m, k);
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, m, k;
    cin >> n >> m >> k;

    // solve
    Solution solution;
    auto result = solution.solve(n, m, k);

    // output
    cout << result << ""\n"";

    return 0;
}",constructive_algorithms,easy
243,"In English, we have a concept called root, which can be followed by some other word to form another longer word - let's call this word derivative. For example, when the root ""help"" is followed by the word ""ful"", we can form a derivative ""helpful"".
Given a dictionary consisting of many roots and a sentence consisting of words separated by spaces, replace all the derivatives in the sentence with the root forming it. If a derivative can be replaced by more than one root, replace it with the root that has the shortest length.
Return the sentence after the replacement.

solution main function
```cpp
class Solution
{
    public:
    string solve(vector<string>& dictionary, string sentence)
}
```

Example 1:
Input: dictionary = [""cat"",""bat"",""rat""], sentence = ""the cattle was rattled by the battery""
Output: ""the cat was rat by the bat""

Example 2:
Input: dictionary = [""a"",""b"",""c""], sentence = ""aadsfasf absbs bbab cadsfafs""
Output: ""a a b c""


Constraints:
1 <= dictionary.length <= @data
1 <= dictionary[i].length <= 100
dictionary[i] consists of only lower-case letters.
1 <= sentence.length <= 106
sentence consists of only lower-case letters and spaces.
The number of words in sentence is in the range [1, 1000]
The length of each word in sentence is in the range [1, 1000]
Every two consecutive words in sentence will be separated by exactly one space.
sentence does not have leading or trailing spaces.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 100, 1000]",1000.0,"[[204800, 102400, 51200]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    struct Trie {
        unordered_map<char, Trie *> children;
    };
    string solve(vector<string>& dictionary, string sentence) {
        Trie *trie = new Trie();
        for (auto &word : dictionary) {
            Trie *cur = trie;
            for (char &c: word) {
                if (!cur->children.count(c)) {
                    cur->children[c] = new Trie();
                }
                cur = cur->children[c];
            }
            cur->children['#'] = new Trie();
        }
        vector<string> words = split(sentence, ' ');
        for (auto &word : words) {
            word = findRoot(word, trie);
        }
        string ans;
        for (int i = 0; i < words.size() - 1; i++) {
            ans.append(words[i]);
            ans.append("" "");
        }
        ans.append(words.back());
        return ans;
    }

    vector<string> split(string &str, char ch) {
        int pos = 0;
        int start = 0;
        vector<string> ret;
        while (pos < str.size()) {
            while (pos < str.size() && str[pos] == ch) {
                pos++;
            }
            start = pos;
            while (pos < str.size() && str[pos] != ch) {
                pos++;
            }
            if (start < str.size()) {
                ret.emplace_back(str.substr(start, pos - start));
            }
        }
        return ret;
    }

    string findRoot(string &word, Trie *trie) {
        string root;
        Trie *cur = trie;
        for (char &c : word) {
            if (cur->children.count('#')) {
                return root;
            }
            if (!cur->children.count(c)) {
                return word;
            }
            root.push_back(c);
            cur = cur->children[c];
        }
        return root;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m;
    cin>>n>>m;
    vector<string> words;
    string text;
    for(int i=1;i<=n;i++)
    {
        string s; cin>>s;
        words.push_back(s);
    }
    for(int i=1;i<=m;i++)
    {
        string s; cin>>s;
        text+=s;
        if(i!=m) text+="" "";
    }
    // solve
    Solution solution;
            auto result = solution.solve(words,text);
    
    // output
    cout<<result;
    return 0;
}","string,data_structures",medium
244,"Given a positive integer n, return the punishment number of n.

The punishment number of n is defined as the sum of the squares of all integers i such that:

    1 <= i <= n
    The decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i.


solution main function
```cpp
class Solution {
public:
    int solve(int n) {
        
    }
};
```

Example 1:
Input: n = 10
Output: 182

Example 2:
Input: n = 37
Output: 1478

Constraints:

1 <= n <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 500, 1000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(int n) {
        vector<int> arr = {1, 9, 10, 36, 45, 55, 82, 91, 99, 100, 235, 297, 369, 370, 379, 414, 657, 675, 703, 756, 792, 909, 918, 945, 964, 990, 991, 999, 1000};
        vector<long long> prefix = {0};
        for(int i : arr) prefix.emplace_back(prefix.back() + i*i);
        int i = upper_bound(arr.begin(),arr.end(),n) - arr.begin();
        return prefix[i];
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
    auto result = solution.solve(n);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","math,other",Medium
245,"# Problem Statement:
Given an array $a=[a_1,a_2,\dots,a_n]$ of $n$ positive integers, you can do operations of two types on it:

1.  Add $1$ to **every** element with an **odd** index. In other words change the array as follows: $a_1 := a_1 +1, a_3 := a_3 + 1, a_5 := a_5+1, \dots$.
    
2.  Add $1$ to **every** element with an **even** index. In other words change the array as follows: $a_2 := a_2 +1, a_4 := a_4 + 1, a_6 := a_6+1, \dots$.

Determine if after any number of operations it is possible to make the final array contain only even numbers or only odd numbers. In other words, determine if you can make all elements of the array have the same parity after any number of operations.

Note that you can do operations of both types any number of times (even none). Operations of different types can be performed a different number of times.

The main function of the solution is defined as: 
```cpp
class Solution {
public:
    string solve(int &n, vector<int> &a) {   
        // write your code here
    }
};
```
Where:  
- The return value is ""YES"" if it is possible to make all elements of the array have the same parity after any number of operations, and ""NO"" otherwise.


# Example 1:
- Input:  
n = 5  
a = [1000, 1, 1000, 1, 1000]
- Output:  
YES

# Constraints:
- $2 \leq n \leq @data$
- $1 \leq a[i] \leq 10^9$ 
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB","[10, 1000, 100000]",1000.0,"[[3200, 320, 32]]","class Solution
{
public:
    string solve(int &n, vector<int> &a)
    {
        for (int i = 2; i < n; i++)
            if (a[i] % 2 != a[i - 2] % 2)
                return ""NO"";
        return ""YES"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,math",medium
246,"You are given a string s.

A split is called good if you can split s into two non-empty strings sleft and sright where their concatenation is equal to s (i.e., sleft + sright = s) and the number of distinct letters in sleft and sright is the same.

Return the number of good splits you can make in s.

solution main function
```cpp
class Solution {
public:
    int solve(string s) {
        
    }
};
```

Example 1:
Input: s = ""aacaba""
Output: 2

Example 2:
Input: s = ""abcd""
Output: 1


Constraints:

1 <= s.length <= @data
s consists of only lowercase English letters.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(string s) {
        ios::sync_with_stdio(0);
        cin.tie(0);
        int ls[26] = {0}, rs[26] = {0}, res = 0, lu=0, ru=0;
        for(char &c: s){
            rs[c-'a']++;
            ru += (rs[c-'a']==1);
        }
        for(char &c: s){
            rs[c-'a']--;
            ls[c-'a']++;
            ru -= (rs[c-'a']==0);
            lu += (ls[c-'a']==1);
            res += (ru==lu);
        }
        return res;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string s; cin>>s;
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","string,dynamic_programming,other",medium
247,"# Problem Statement
Vanya really likes math. One day when he was solving another math problem, he came up with an interesting tree. This tree is built as follows.

Initially, the tree has only one vertex with the number $1$ the root of the tree. Then, Vanya adds two children to it, assigning them consecutive numbers $2$ and $3$, respectively. After that, he will add children to the vertices in increasing order of their numbers, starting from $2$, assigning their children the minimum unused indices. As a result, Vanya will have an infinite tree with the root in the vertex $1$, where each vertex will have exactly two children, and the vertex numbers will be arranged sequentially by layers.

Vanya wondered what the sum of the vertex numbers on the path from the vertex with number $1$ to the vertex with number $n$ in such a tree is equal to. Since Vanya doesn't like counting, he asked you to help him find this sum.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(long long &n) {
        // write your code here
    }
};
```
where:  
- return: the sum of the vertex numbers on the path from the vertex with number $1$ to the vertex with number $n$.

# Example 1:  
- Input:  
n = 3
- Output:  
4

# Constraints:  
- $1 \leq n \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000000, 1000000000000, 10000000000000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(long long &n)
    {
        long long ans = 0;
        while (n)
        {
            ans += n;
            n /= 2;
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    long long n;
    cin >> n;

    // solve
    Solution solution;
    auto result = solution.solve(n);

    // output
    cout << result << ""\n"";

    return 0;
}","math,tree,bit_manipulation",easy
248,"You are given an integer array nums with the following properties:

    nums.length == 2 * n.
    nums contains n + 1 unique elements.
    Exactly one element of nums is repeated n times.

Return the element that is repeated n times.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [1,2,3,3]
Output: 3

Example 2:
Input: nums = [2,1,2,5,3,2]
Output: 2

Constraints:

2 <= n <= @data
nums.length == 2 * n
0 <= nums[i] <= 10^4
nums contains n + 1 unique elements and one of them is repeated exactly n times.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
 public:
  int solve(vector<int>& nums) {
    for (int i = 0; i + 2 < nums.size(); ++i)
      if (nums[i] == nums[i + 1] || nums[i] == nums[i + 2])
        return nums[i];
    return nums.back();
  }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    vector<int> str;
    cin>>n;
    for(int i=1;i<=2*n;i++)
    {
        int s; cin>>s;
        str.push_back(s);
    }
    // solve
    Solution solution;
    auto result = solution.solve(str);
    
    // output
    cout<<result;
    return 0;
}",greedy,easy
249,"You are given a 0-indexed string array words.

Let's define a boolean function isPrefixAndSuffix that takes two strings, str1 and str2:

    isPrefixAndSuffix(str1, str2) returns true if str1 is both a prefix and a suffix
    of str2, and false otherwise.

For example, isPrefixAndSuffix(""aba"", ""ababa"") is true because ""aba"" is a prefix of ""ababa"" and also a suffix, but isPrefixAndSuffix(""abc"", ""abcd"") is false.

Return an integer denoting the number of index pairs (i, j) such that i < j, and isPrefixAndSuffix(words[i], words[j]) is true.

solution main function

```cpp
class Solution {
public:
    int solve(string s) {
        
    }
};
```

Example 1:
Input: words = [""a"",""aba"",""ababa"",""aa""]
Output: 4

Example 2:
Input: words = [""pa"",""papa"",""ma"",""mama""]
Output: 2

Constraints:

1 <= words.length <= @data
1 <= words[i].length <= @data
words[i] consists only of lowercase English letters.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 50, 100]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<string>& words) {
        int n = words.size();
        int count = 0;

        // Step 1: Iterate through each pair of words
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                string& str1 = words[i];
                string& str2 = words[j];

                // Step 2: Skip if the first string is larger than the second
                if (str1.size() > str2.size()) continue;

                // Step 3: Check if str1 is both the prefix and suffix of str2
                if (str2.find(str1) == 0 &&
                    str2.rfind(str1) == str2.size() - str1.size()) {
                    ++count;
                }
            }
        }

        // Step 4: Return the total count of prefix-suffix pairs
        return count;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    vector<string> str;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        string s; cin>>s;
        str.push_back(s);
    }
    // solve
    Solution solution;
    auto result = solution.solve(str);
    
    // output
    cout<<result;
    return 0;
}",string,easy
250,"Yangtze River Yacht Club set up $n$yacht rental station on the Yangtze River $1,2,\cdots,n$. Visitors can hire their yacht at these yacht hire stations and return it at any of the yacht hire stations downstream. The rental between the yacht rental station $i$and the yacht rental station $j$is $r(i,j)$($1\le i\lt j\le n$). Try to design an algorithm to calculate the minimum rental required from the yacht rental station $1 to the yacht rental station $n$.

solution main function
```cpp
class Solution
{
    public:
    int solve(int n, vector<vector<int> >&r)
}
```

Pass in parameters:
1 integer n.
A two-dimensional vector array $n-1$row is a semi-matrix $r(i,j)$($1\le i<j\le n$)

Return parameters:
An integer representing the minimum rental required from the yacht rental station $1 to the yacht rental Station $n$.

Example 1:
Input: n=3,r=[[5, 15], [7]]
Output: 12

Constraints:
0<n@data,r(i,j)1000
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 100, 1000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution
{
public:
    int solve(int n, vector<vector<int> >&r)
    {
		int f[n+1];
		for(int i=0;i<=n;i++) f[i]=0;
		for (int i=1;i<=n;i++)
			for (int j=i+1;j<=n;j++)
			{
				if (f[j]==0||f[j]>f[i]+r[i-1][j-i-1])
					f[j]=f[i]+r[i-1][j-i-1];
			}
	return f[n];
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin >> n;
    vector<vector<int> > r;
    for(int i=1;i<n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=n-i;j++)
        {
            int x; cin>>x;
            temp.push_back(x);
        }
        r.push_back(temp);
    }

    // solve
    Solution solution;
            auto result = solution.solve(n,r);
    
    // output
    cout << result << ""\n"";

    return 0;
}","dp,graph",medium
251,"Given an array points where points[i] = [xi, yi] represents a point on the X-Y plane, return true if these points are a boomerang.

A boomerang is a set of three points that are all distinct and not in a straight line.

solution main function
```cpp
class Solution {
public:
    bool solve(vector<vector<int>>& points) {
        
    }
};
```

Example 1:
Input: points = [[1,1],[2,3],[3,2]]
Output: true

Example 2:
Input: points = [[1,1],[2,2],[3,3]]
Output: false

Constraints:

points.length == 3
points[i].length == 2
0 <= xi, yi <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[20, 50, 100]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
        bool solve(vector<vector<int>>& p) {
        return (p[0][0] - p[1][0]) * (p[0][1] - p[2][1]) != (p[0][0] - p[2][0]) * (p[0][1] - p[1][1]);
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    vector<vector<int>> s;
    for(int i=1;i<=3;i++)
    {
        vector<int> temp;
        for(int j=1;j<=2;j++)
        {
            int x; cin>>x;
            temp.push_back(x);
        }
        s.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    printf(""%d"",result);
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","math,sort,other",easy
252,"There is a row of $N$coins on the table, and each coin is heads up. Now to flip all the coins tails up, the rule is that you can flip any $N- $1 coin at a time (heads up are flipped tails up and vice versa). Find the shortest sequence of operations (turning each flip of $N-1 coin into one operation).

solution main function
```cpp
class Solution
{
    public:
    pair< int,vector<string> > solve(int n)
}
```

Pass in parameters:
An even natural number $n$.

Return parameters:
An integer represents the minimum number of operations required.
A vector<string> array that stores the state of the coins on the table after each operation (a row containing $N$integers $0$or $1$, representing the state of each coin, $0$representing heads up and $1$representing tails up). The output of redundant Spaces is not allowed.
In cases where there are multiple operation options, only the lexicographic order of the operation needs to output a minimum of one.
The lexicographic order of operations means that for each position in an operation, $1$means flip and $0$means no flip.
But what you need to output is the state after each operation, $0$means heads up, $1$means tails up.

Example 1:
Input: n=4
Output: (4,[""0111"", ""1100"", ""0001"", ""1111""])

Constraints:
0<n@data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 50, 100]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution
{
public:
    pair< int,vector<string> > solve(int n)
    {
        vector<string> ans;
        for (int i=1;i<=n;i++){
            string s;
            for (int j=1;j<=i;j++) s.push_back(48|~i&1);
            for (int j=i+1;j<=n;j++) s.push_back(48|i&1);
            ans.push_back(s);
        }
        return {n,ans};
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
            auto result = solution.solve(n);
    
    // output
    cout<<result.first<<endl;
    for(auto it:result.second)
        cout<<it<<endl;
    return 0;
}",math,hard
253,"# Problem Statement
Arseniy came up with another business plan  to sell soda from a vending machine! For this, he purchased a machine with $n$ shelves, as well as $k$ bottles, where the $i$\-th bottle is characterized by the brand index $b_i$ and the cost $c_i$.

You can place any number of bottles on each shelf, but all bottles on the same shelf must be of the same brand.

Arseniy knows that all the bottles he puts on the shelves of the machine will be sold. Therefore, he asked you to calculate the **maximum** amount he can earn.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &k, vector<pair<int, int>> &b) {
        // write your code here
    }
};
```
where:  
- `n`: the number of shelves, `k`: the number of bottles
- `bottle`: the brand index $b_i$ and cost $c_i$ of each bottle
- return: the maximum amount he can earn

# Example 1:  
- Input:  
n = 3, k = 3
bottle = [(2, 6), (2, 7), (1, 15)]
- Output:  
28

# Constraints:  
- $1 \leq n, k \leq @data$
- $1 \leq bottle[i].first \leq k$ 
- $1 \leq bottle[i].second \leq 10^3$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 3200, 640]]","class Solution
{
public:
    int solve(int &n, int &k, vector<pair<int, int>> &bottle)
    {
        n = min(n, k);
        vector<int> s(k);
        for (int i = 0; i < k; i++)
        {
            int b = bottle[i].first;
            int c = bottle[i].second;
            b--;
            s[b] += c;
        }
        sort(s.begin(), s.end(), greater<int>());
        int ans = accumulate(s.begin(), s.begin() + n, 0);
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, k;
    cin >> n >> k;
    vector<pair<int, int>> bottle(k);
    for (int i = 0; i < k; i++)
        cin >> bottle[i].first >> bottle[i].second;

    // solve
    Solution solution;
    auto result = solution.solve(n, k, bottle);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,sort",easy
254,"We are playing the Guessing Game. The game will work as follows:

    I pick a number between 1 and n.
    You guess a number.
    If you guess the right number, you win the game.
    If you guess the wrong number, then I will tell you whether the number I picked is higher or lower, and you will continue guessing.
    Every time you guess a wrong number x, you will pay x dollars. If you run out of money, you lose the game.

Given a particular n, return the minimum amount of money you need to guarantee a win regardless of what number I pick.

solution main function

```cpp
class Solution {
public:
    int solve(int n) {
        
    }
};
```

Example 1:
Input: n = 10
Output: 16

Example 2:
Input: n = 1
Output: 0

Constraints:

1 <= n <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[8, 50, 200]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(int n) {
        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));
        for(int len=2; len<=n; ++len){
            for(int begin=0; begin<=n-len; ++begin){
                
                int end = begin + len;
                for(int i=begin; i<end; ++i){
                    int numPicked = i+1;
                    if(i == begin){
                        dp[begin][end] = numPicked + dp[begin+1][end];
                    } else {
                        dp[begin][end] = min(dp[begin][end], max(dp[begin][i], dp[i+1][end]) + numPicked);
                    }
                    
                }
            }
        }

        return dp[0][n];
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
    auto result = solution.solve(n);
    
    // output
    cout << result << ""\n"";

    return 0;
}","math,dp",medium
255,"You are given an m * n binary matrix grid, where 0 represents a sea cell and 1 represents a land cell.
A move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid.
Return the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves.

solution main function
```cpp
class Solution
{
    public:
    int solve(vector<vector<int>>& grid)
}
```
Example 1:
Inputgrid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
Output: 3

Example 2:
Inputgrid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
Output: 0

Constraints:
m == grid.length
n == grid[i].length
1 <= m, n <= @data
grid[i][j] is either 0 or 1
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 100, 1000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution 
{   
    int dx[4] = {0,0,1,-1};
    int dy[4] = {1,-1,0,0};
    int m,n;
public:
    int solve(vector<vector<int>>& grid) 
    {   
        int ret = 0;
        m = grid.size(),n = grid[0].size();
        queue<pair<int,int>>q;
        for(int i = 0; i < m; i++)
            for(int j = 0; j < n; j++)
                if(grid[i][j] == 1)
                {
                    if(i == 0 || j == 0 || i == m - 1 || j == n - 1)
                    {   
                        q.push({i, j});
                        grid[i][j] = 2;
                    }
                }


        while(q.size())
        {
            auto [a,b] = q.front();
            q.pop();
            for(int i = 0;i<4;i++)
            {
                int x = a+dx[i],y = b+dy[i];
                if(x>=0&&x<m&&y>=0&&y<n&&grid[x][y]==1) q.push({x,y}),grid[x][y] = 2;
            }
        }

       for(int i = 0;i<m;i++)
            for(int j = 0;j<n;j++)
                if(grid[i][j] == 1) ret++;

        return ret;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m;
    cin>>n>>m;
    vector<vector<int> > g;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=m;j++)
        {
            int x; cin>>x;
            temp.push_back(x);
        }
        g.push_back(temp);
    }
    // solve
    Solution solution;
            auto result = solution.solve(g);
    
    // output
    cout<<result;
    return 0;
}",graph,medium
256,"# Problem Statement
Petya organized a strange birthday party. He invited $n$ friends and assigned an integer $k_i$ to the $i$\-th of them. Now Petya would like to give a present to each of them. In the nearby shop there are $m$ unique presents available, the $j$\-th present costs $c_j$ dollars ($1 \le c_1 \le c_2 \le \ldots \le c_m$). It's **not** allowed to buy a single present more than once.

For the $i$\-th friend Petya can either buy them a present $j \le k_i$, which costs $c_j$ dollars, or just give them $c_{k_i}$ dollars directly.

Help Petya determine the minimum total cost of hosting his party.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, int &m, vector<int> &k, vector<int> &c) {
        // write your code here
    }
};
```
where:  
- return: the minimum total cost of hosting the party, please use `long long` to avoid overflow

# Example 1:  
- Input:  
n = 5, m = 4
k = [2, 3, 4, 3, 2]
c = [3, 5, 12, 20]
- Output:  
30

# Constraints:  
- $1 \leq n, m \leq @data$
- $1 \leq k[i] \leq m$
- $1 \leq c[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(int &n, int &m, vector<int> &k, vector<int> &c)
    {
        sort(k.begin(), k.end());
        long long ans = 0;
        for (int i = n - 1; i >= 0; i--)
        {
            ans += c[min(k[i] - 1, n - 1 - i)];
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, m;
    cin >> n >> m;
    vector<int> k(n), c(m);
    for (int i = 0; i < n; i++)
        cin >> k[i];
    for (int i = 0; i < m; i++)
        cin >> c[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, m, k, c);

    // output
    cout << result << ""\n"";

    return 0;
}","binary,dp,sort,two_pointers",hard
257,"Given an integer number n, return the difference between the product of its digits and the sum of its digits. 

solution main function
```cpp
class Solution {
public:
    int solve(int n) {
        
    }
};
```

Example 1:
Input: n = 234
Output: 15 

Example 2:
Input: n = 4421
Output: 21

Constraints:

1 <= n <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(int n) {
        int sum = 0, product = 1;
        for (; n > 0; n /= 10) {
            sum += n % 10;
            product *= n % 10;
        }
        return product - sum;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
    auto result = solution.solve(n);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","math,other",easy
258,"# Problem Statement
You are given an array of integers. Vasya can permute (change order) its integers. He wants to do it so that as many as possible integers will become on a place where a smaller integer used to stand. Help Vasya find the maximal number of such integers.

For instance, if we are given an array $[10, 20, 30, 40]$, we can permute it so that it becomes $[20, 40, 10, 30]$. Then on the first and the second positions the integers became larger ($20&gt;10$, $40&gt;20$) and did not on the third and the fourth, so for this permutation, the number that Vasya wants to maximize equals $2$. Read the note for the first example, there is one more demonstrative test case.

Help Vasya to permute integers in such way that the number of positions in a new array, where integers are greater than in the original one, is maximal.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the maximal number of the array's elements which after a permutation will stand on the position where a smaller element stood in the initial array.

# Example 1:  
- Input:  
n = 5
a = [1, 1, 1, 1, 1]
- Output:  
0


# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        int j = 0;
        sort(a.begin(), a.end());
        for (int i = 0; i < n; i++)
        {
            if (a[i] > a[j])
                j++;
        }
        return j;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","math,sort",medium
259,"An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:

    'A': Absent.
    'L': Late.
    'P': Present.

Any student is eligible for an attendance award if they meet both of the following criteria:

    The student was absent ('A') for strictly fewer than 2 days total.
    The student was never late ('L') for 3 or more consecutive days.

Given an integer n, return the number of possible attendance records of length n that make a student eligible for an attendance award. The answer may be very large, so return it modulo 10^9 + 7.

solution main function

```cpp
class Solution {
public:
    int solve(int n) {
        
    }
};
```

Example 1:
Input: n = 2
Output: 8

Example 2:
Input: n = 1
Output: 3

Constraints:

1 <= n <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(int n) {
        int MOD = 1000000007;
        // Cache to store current sub-problem results.
        vector<vector<int>> dpCurrState =
            vector<vector<int>>(2, vector<int>(3, 0));
        // Cache to store next sub-problem results.
        vector<vector<int>> dpNextState =
            vector<vector<int>>(2, vector<int>(3, 0));

        // Base case: there is 1 string of length 0 with zero 'A' and zero 'L'.
        dpCurrState[0][0] = 1;

        // Iterate on smaller sub-problems and use the current smaller
        // sub-problem to generate results for bigger sub-problems.
        for (int len = 0; len < n; ++len) {
            for (int totalAbsences = 0; totalAbsences <= 1; ++totalAbsences) {
                for (int consecutiveLates = 0; consecutiveLates <= 2;
                     ++consecutiveLates) {
                    // Store the count when 'P' is chosen.
                    dpNextState[totalAbsences][0] =
                        (dpNextState[totalAbsences][0] +
                         dpCurrState[totalAbsences][consecutiveLates]) %
                        MOD;
                    // Store the count when 'A' is chosen.
                    if (totalAbsences < 1) {
                        dpNextState[totalAbsences + 1][0] =
                            (dpNextState[totalAbsences + 1][0] +
                             dpCurrState[totalAbsences][consecutiveLates]) %
                            MOD;
                    }
                    // Store the count when 'L' is chosen.
                    if (consecutiveLates < 2) {
                        dpNextState[totalAbsences][consecutiveLates + 1] =
                            (dpNextState[totalAbsences][consecutiveLates + 1] +
                             dpCurrState[totalAbsences][consecutiveLates]) %
                            MOD;
                    }
                }
            }

            // Next state sub-problems will become current state sub-problems in
            // next iteration.
            dpCurrState = dpNextState;
            // Next state sub-problem results will reset to zero.
            dpNextState = vector<vector<int>>(2, vector<int>(3, 0));
        }

        // Sum up the counts for all combinations of length 'n' with different
        // absent and late counts.
        int count = 0;
        for (int totalAbsences = 0; totalAbsences <= 1; ++totalAbsences) {
            for (int consecutiveLates = 0; consecutiveLates <= 2;
                 ++consecutiveLates) {
                count = (count + dpCurrState[totalAbsences][consecutiveLates]) %
                        MOD;
            }
        }
        return count;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
    auto result = solution.solve(n);
    
    // output
    cout << result << ""\n"";

    return 0;
}",dp,hard
260,"There is a water room in the school, which is equipped with a total of $m$taps for students to turn on the water, and the water supply of each tap is equal to $1 per second.
Now there are $n$students ready to receive water, their initial order of receiving water has been determined. These students are numbered from $1$to $n$in the order of receiving water, and the amount of water received by students with $i$is $w_i$. When receiving water, students from $1$to $m$each occupy a faucet and open the faucet at the same time. When one of the students $j$completes the water demand $w_j$, the next student $k$who waits in line to receive water immediately takes the place of the student $j$and starts to receive water. The replacement process is instantaneous and no water is wasted. That is, when $j$finishes receiving water at the end of $x$second, $k$starts receiving water immediately at $x+1$second. If the current number of people receiving water $n'$is less than $m$, only $n'$tap water supply, other $m - n'$tap closed.
Now give the amount of water received by $n$students, and ask how many seconds it takes for all students to receive water according to the above rules.

solution main function
```cpp
class Solution
{
    public:
    int solve(int n, int m, vector<int> &w)
}
```

Pass in parameters:
The two integers are $n and m$, respectively, indicating the number of people receiving water and the number of taps.
1 array, $n$integers $w_1,w_2,\ldots,w_n$, separated by a space between each two integers, $w_i$indicates the amount of water received by the student with $i$

Return parameters:
An integer representing the total time required to connect the water.

Example 1:
Input: n=5,m=3,w=[4, 4, 1, 2, 1]
Output: 4

Example 2:
Input: n=8,m=4,w=[23, 71, 87, 32, 70, 93, 80, 76]
Output: 163

Constraints:
0<n@data, 1m100, mn, 1wi100
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 100, 10000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution
{
public:
    int solve(int n, int m, vector<int> &w)
    {
        w.insert(w.begin(), 0);
        int t = m + 1;
        int ans = 0;
        while (t <= n + m)
        {
            for (int i = 1; i <= m; i++)
            {
                w[i]--;
                if (w[i] == 0)
                {
                    w[i] = w[t];
                    t++;
                }
            }
            ans++;
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m;cin>>n>>m;
    vector<int> w;
    for(int i=1,x;i<=n;i++)
    {
        cin>>x;
        w.push_back(x);
    }
    // solve
    Solution solution;
            auto result = solution.solve(n,m,w);
    
    // output
    cout << result << ""\n"";

    return 0;
}",greedy,medium
261,"# Problem Statement
You are given a number in binary representation consisting of exactly $n$ bits, possibly, with leading zeroes. For example, for $n = 5$ the number $6$ will be given as $00110$, and for $n = 4$ the number $9$ will be given as $1001$.

Let's fix some integer $i$ such that $1 \le i \le n$. In one operation you can swap any two adjacent bits in the binary representation. Your goal is to find the smallest number of operations you are required to perform to make the number divisible by $2^i$, or say that it is impossible.

Please note that for each $1 \le i \le n$ you are solving the problem independently.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    vector<long long> solve(int &n, string &s) {   
        // write your code here
    }
};
```
where:  
- `n` is the number of bits in the binary representation
- `s` is the binary representation of the number
- Return an array, where the $i$-th element of the array represents the smallest number of operations required to make the number divisible by $2^i$, and the answer is large, use a $64$-bit integer type.

# Example 1:  
- Input:  
n = 2
s = ""01""
- Output:  
[1, -1]

# Constraints:  
- $1 \leq n \leq @data$ 
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 3200, 2048]]","class Solution
{
public:
    vector<long long> solve(int &n, string &s)
    {

        long long ans = 0;
        vector<long long> res;
        int l = n, r = n;
        for (int i = 1; i <= n; i++)
        {
            if (ans != -1)
            {
                if (l > n - i && s[n - i] == '0')
                    l -= 1;
                else
                {
                    while (l > 0 && s[l - 1] == '1')
                        l -= 1;
                    if (l == 0)
                        ans = -1;
                    else
                        ans += r - l;
                    l -= 1;
                }
                r -= 1;
            }
            res.push_back(ans);
        }
        return res;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    string s;
    cin >> s;

    // solve
    Solution solution;
    auto result = solution.solve(n, s);

    // output
    for (auto x : result)
        cout << x << "" "";
    cout << ""\n"";

    return 0;
}","two_pointers,binary,greedy,math",hard
262,"# Problem Statement
Amidst skyscrapers in the bustling metropolis of Metro Manila, the newest Noiph mall in the Philippines has just been completed! The construction manager, Penchick, ordered a state-of-the-art monument to be built with $n$ pillars.

The heights of the monument's pillars can be represented as an array $h$ of $n$ positive integers, where $h_i$ represents the height of the $i$\-th pillar for all $i$ between $1$ and $n$.

Penchick wants the heights of the pillars to be in **non-decreasing** order, i.e. $h_i \le h_{i + 1}$ for all $i$ between $1$ and $n - 1$. However, due to confusion, the monument was built such that the heights of the pillars are in **non-increasing** order instead, i.e. $h_i \ge h_{i + 1}$ for all $i$ between $1$ and $n - 1$.

Luckily, Penchick can modify the monument and do the following operation on the pillars as many times as necessary:

-   Modify the height of a pillar to any positive integer. Formally, choose an index $1\le i\le n$ and a positive integer $x$. Then, assign $h_i := x$.

Help Penchick determine the minimum number of operations needed to make the heights of the monument's pillars **non-decreasing**.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &h) {
        // write your code here
    }
};
```
where:  
- output a single integer representing the minimum number of operations needed to make the heights of the pillars non-decreasing.

# Example 1:  
- Input:  
n = 5
a = [5, 3, 2, 4, 1]
- Output:  
4

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq h[i] \leq n$
- $h[i] \geq h[i + 1]$ for all $i$ between $1$ and $n - 1$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &h)
    {
        int ans = n;
        int l = -1;
        int c = 0;
        for (int i = 0; i < n; i++)
        {
            if (h[i] == l)
                c++;
            else
                c = 1;
            l = h[i];
            ans = min(ans, n - c);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","dp,greedy,math",hard
263,"# Problem Statement
Eralim, being the mafia boss, manages a group of $n$ fighters. Fighter $i$ has a rating of $a_i$.

Eralim arranges a tournament of $n - 1$ battles, in each of which two not yet eliminated fighters $i$ and $j$ (**$1 \le i &lt; j \le n$**) are chosen, and as a result of the battle, fighter $i$ is eliminated from the tournament, and the rating of fighter $j$ is reduced by the rating of fighter $i$. That is, $a_j$ is decreased by $a_i$. Note that fighter $j$'s rating can become negative. The fighters indexes do not change.

Eralim wants to know what maximum rating the last remaining fighter can preserve if he chooses the battles optimally.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return:the maximum rating that the last remaining fighter can preserve.

# Example 1:  
- Input:  
n = 2, a = [2, 1]
- Output:  
-1

# Constraints:  
- $2 \leq n \leq @data$
- $1 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(int &n, vector<int> &a)
    {
        long long ans = 0;
        for (int i = 1; i <= n; i++)
        {
            if (i <= n - 2)
                ans = ans + a[i - 1];
            else
                ans = a[i - 1] - ans;
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","constructive_algorithms,math",easy
264,"You are given two 0-indexed strings str1 and str2.

In an operation, you select a set of indices in str1, and for each index i in the set, increment str1[i] to the next character cyclically. That is 'a' becomes 'b', 'b' becomes 'c', and so on, and 'z' becomes 'a'.

Return true if it is possible to make str2 a subsequence of str1 by performing the operation at most once, and false otherwise.

Note: A subsequence of a string is a new string that is formed from the original string by deleting some (possibly none) of the characters without disturbing the relative positions of the remaining characters.

solution main function

```cpp
class Solution {
public:
    bool solve(string str1, string str2) {
        
    }
};
```

Example 1:
Input: str1 = ""abc"", str2 = ""ad""
Output: true

Example 2:
Input: str1 = ""zc"", str2 = ""ad""
Output: true

Constraints:

1 <= str1.length,str2.length <= @data
str1 and str2 consist of only lowercase English letters.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 150]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    bool solve(string str1, string str2) {
        int str2Index = 0;
        int lengthStr1 = str1.size(), lengthStr2 = str2.size();

        // Traverse through both strings using a for loop
        for (int str1Index = 0;
             str1Index < lengthStr1 && str2Index < lengthStr2; ++str1Index) {
            // Check if characters match, or if str1[str1Index] can be
            // incremented to str2[str2Index]
            if (str1[str1Index] == str2[str2Index] ||
                (str1[str1Index] + 1 == str2[str2Index]) ||
                (str1[str1Index] - 25 == str2[str2Index])) {
                // If match found, move to next character in str2
                str2Index++;
            }
        }
        // Check if all characters in str2 were matched
        return str2Index == lengthStr2;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string a,b; cin>>a>>b;
    // solve
    Solution solution;
    int result = solution.solve(a,b);
    
    // output
    cout<<result;
    return 0;
}","two_pointers,string",medium
265,"You are given an integer array cookies, where cookies[i] denotes the number of cookies in the ith bag. You are also given an integer k that denotes the number of children to distribute all the bags of cookies to. All the cookies in the same bag must go to the same child and cannot be split up.

The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.

Return the minimum unfairness of all distributions.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& cookies, int k) {
        
    }
};
```

Constraints:

2 <= cookies.length <= 8
1 <= cookies[i] <= @data
2 <= k <= cookies.length


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[4, 6, 8]",1000.0,"[[25600, 1280, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int foo;
    int helper(vector<int>& cookies, int k, vector<int>& children, int index) {
        if (index == cookies.size()) {
            foo = min(foo, *max_element(children.begin(), children.end()));
            return foo;
        }

        int ans = INT_MAX;
        for (int i = 0; i < k; ++i) {
            children[i] += cookies[index];
            if (children[i] < foo)
                ans = min(ans, helper(cookies, k, children, index + 1));
            children[i] -= cookies[index];

            if (children[i] == 0) break;
        }

        return ans;
    }

    int solve(vector<int>& cookies, int k) {
        foo = INT_MAX;
        vector<int> children(k, 0);
        helper(cookies, k, children, 0);
        return foo;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,k; cin>>n>>k;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s,k);
    // output
    cout << result << ""\n"";
    // for(auto it:result) cout<<it<<' ';
    return 0;
}","bit_manipulation,dp",medium
266,"A shop is selling candies at a discount. For every two candies sold, the shop gives a third candy for free.

The customer can choose any candy to take away for free as long as the cost of the chosen candy is less than or equal to the minimum cost of the two candies bought.

    For example, if there are 4 candies with costs 1, 2, 3, and 4, and the customer buys candies with costs 2 and 3, they can take the candy with cost 1 for free, but not the candy with cost 4.

Given a 0-indexed integer array cost, where cost[i] denotes the cost of the ith candy, return the minimum cost of buying all the candies.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& cost) {
        
    }
};
```

Example 1:
Input: cost = [1,2,3]
Output: 5

Example 2:
Input: cost = [6,5,7,9,2,2]
Output: 23

Constraints:


1 <= cost.length <= @data
1 <= cost[i] <= 100


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& cost) {
        sort(cost.begin(),cost.end(),greater<int>());
        int sum=0;
        int count=0;
        for(int i=0;i<cost.size();i++)
        {
            if(count==2)
             {
                count=0;
             }
            else
            {  sum+=cost[i];
             count++;}
        }
        
        return sum;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","sort,greedy",easy
267,"# Problem Statement
To train young Kevin's arithmetic skills, his mother devised the following problem.

Given $n$ integers $a_1, a_2, \ldots, a_n$ and a sum $s$ initialized to $0$, Kevin performs the following operation for $i = 1, 2, \ldots, n$ in order:

-   Add $a_i$ to $s$. If the resulting $s$ is even, Kevin earns a point and repeatedly divides $s$ by $2$ until it becomes odd.

Note that Kevin can earn at most one point per operation, regardless of how many divisions he does.

Since these divisions are considered more beneficial for Kevin's development, his mother wants to rearrange $a$ so that the number of Kevin's total points is maximized. Determine the maximum number of points.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- returns the maximum number of points.

# Example 1:  
- Input:  
n = 2, a = [1, 2]
- Output:  
2

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        int odd = 0;
        for (int i = 0; i < n; i++)
        {
            odd += a[i] % 2;
        }
        return min(n - 1, odd) + min(1, n - odd);
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",math,easy
268,"On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone.
A stone can be removed if it shares either the same row or the same column as another stone that has not been removed.
Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.

solution main function
```cpp
class Solution
{
    public:
    int solve(vector<vector<int>>& stones)
}
```

Example 1:
Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
Output: 5

Example 2:
Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
Output: 3

Constraints:
1 <= stones.length <= @data
0 <= xi, yi <= 10^4
No two stones are at the same coordinate point.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[128000, 12800, 1280]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    void dfs(int i, vector<vector<int>>& stones, vector<bool>& visited) {
        visited[i] = true;
        for (int j = 0; j < stones.size(); ++j) {
            if (!visited[j] && (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1])) {
                dfs(j, stones, visited); 
            }
        }
    }

    int solve(vector<vector<int>>& stones) {
        int size = stones.size();
        vector<bool> visited(size, false);
        int count = 0; 

        for (int i = 0; i < size; i++) {
            if (!visited[i]) { 
                dfs(i, stones, visited); 
                count++; 
            }
        }

        return size - count;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    cin>>n;
    vector<vector<int> > stones;
    for(int i=1;i<=n;i++)
    {
        int x,y; cin>>x>>y;
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        stones.push_back(temp);
    }
    // solve
    Solution solution;
            auto result = solution.solve(stones);
    
    // output
    cout<<result;
    return 0;
}","graph,data_structures",medium
269,"# Problem Statement
You are given an array $a$ of $n$ positive integers and an integer $x$. You can do the following two-step operation any (possibly zero) number of times:

1.  Choose an index $i$ ($1 \leq i \leq n$).
2.  Increase $a_i$ by $x$, in other words $a_i := a_i + x$.

Find the maximum value of the $\operatorname{MEX}$ of $a$ if you perform the operations optimally.

The $\operatorname{MEX}$ (minimum excluded value) of an array is the smallest non-negative integer that is not in the array. For example:

-   The $\operatorname{MEX}$ of $[2,2,1]$ is $0$ because $0$ is not in the array.
-   The $\operatorname{MEX}$ of $[3,1,0,1]$ is $2$ because $0$ and $1$ are in the array but $2$ is not.
-   The $\operatorname{MEX}$ of $[0,3,1,2]$ is $4$ because $0$, $1$, $2$ and $3$ are in the array but $4$ is not.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &x, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the maximum value of the $\operatorname{MEX}$ of $a$ if you perform the operations optimally.

# Example 1:  
- Input: 
n = 6, x = 3, a = [0, 3, 2, 1, 5, 2]
- Output:  
4

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq x \leq 10^6$
- $0 \leq a[i] \leq 10^6$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve1(int &n, int &x, vector<int> &a)
    {
        vector<int> cnt(n + 1, 0);
        for (int i = 0; i < n; i++)
            if (a[i] <= n)
                cnt[a[i]]++;
        for (int i = 0; i <= n; i++)
        {
            if (cnt[i] == 0)
                return i;
            if (i + x <= n)
                cnt[i + x] += cnt[i] - 1;
        }
    }
    int solve2(int &n, int &x, vector<int> &a)
    {
        for (int i = 0; i <= n; i++)
        {
            bool flag = false;
            for (int j = 0; j < n; j++)
            {
                if (a[j] < i)
                    a[j] += (i - a[j] + x - 1) / x * x;
                if (a[j] == i)
                {
                    flag = true, a[j] = 1E9;
                    break;
                }
            }
            if (flag == false)
                return i;
        }
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, x;
    cin >> n >> x;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, x, a);

    // output
    cout << result << ""\n"";

    return 0;
}",math,medium
270,"# Problem Statement
Pak Chanek has an array $a$ of $n$ positive integers. Since he is currently learning how to calculate the floored average of two numbers, he wants to practice it on his array $a$.

While the array $a$ has at least two elements, Pak Chanek will perform the following three-step operation:

1.  Pick two different indices $i$ and $j$ ($1 \leq i, j \leq |a|$; $i \neq j$), note that $|a|$ denotes the current size of the array $a$.
2.  Append $\lfloor \frac{a_i+a_j}{2} \rfloor$$^{\text{}}$ to the end of the array.
3.  Remove elements $a_i$ and $a_j$ from the array and concatenate the remaining parts of the array.

For example, suppose that $a=[5,4,3,2,1,1]$. If we choose $i=1$ and $j=5$, the resulting array will be $a=[4,3,2,1,3]$. If we choose $i=4$ and $j=3$, the resulting array will be $a=[5,4,1,1,2]$.

After all operations, the array will consist of a single element $x$. Find the maximum possible value of $x$ if Pak Chanek performs the operations optimally.

$^{\text{}}$$\lfloor x \rfloor$ denotes the floor function of $x$, which is the greatest integer that is less than or equal to $x$. For example, $\lfloor 6 \rfloor = 6$, $\lfloor 2.5 \rfloor=2$, $\lfloor -3.6 \rfloor=-4$ and $\lfloor \pi \rfloor=3$

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return:the maximum possible value of x after all numbers have been picked. 

# Example 1:  
- Input:  
n = 5
a = [1, 7, 8, 4, 5]
- Output:  
6

# Constraints:  
- $2 \leq n \leq @data$
- $1 \leq a[i] \leq 10^4$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        sort(a.begin(), a.end());
        int ans = a[0];
        for (int i = 1; i < n; i++)
        {
            ans = (ans + a[i]) / 2;
        }
        return ans;
    }
};
","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","data_structures,greedy,math,sort",hard
271,"# Problem Statement
You are given an array $a$ of length $n$. In one operation, you can pick an index $i$ from $2$ to $n-1$ inclusive, and do one of the following actions:

-   Decrease $a_{i-1}$ by $1$, then increase $a_{i+1}$ by $1$.
    
-   Decrease $a_{i+1}$ by $1$, then increase $a_{i-1}$ by $1$.

After each operation, all the values must be non-negative. Can you make all the elements equal after any number of operations?

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- print ""YES"" without quotation marks if it is possible to make all the elements equal after any number of operations; otherwise, print ""NO"" without quotation marks. 

# Example 1:  
- Input:  
n = 3, a = [3, 2, 1]  
- Output:  
YES

# Constraints:  
- $3 \leq n \leq @data$
- $1 \leq a[i] \leq 10^4$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(int &n, vector<int> &a)
    {
        int s1 = 0;
        int s2 = 0;
        for (int i = 0; i < n; i++)
        {
            if (i % 2 == 0)
                s1 += a[i];
            else
                s2 += a[i];
        }
        int c1 = (n + 1) / 2;
        int c2 = n / 2;
        if (s1 % c1 == 0 && s2 % c2 == 0 && s1 / c1 == s2 / c2)
            return ""YES"";
        else
            return ""NO"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",math,medium
272,"Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal.

A subarray is a contiguous part of the array.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& nums, int goal) {
        
    }
};
```

Example 1:
Input: nums = [1,0,1,0,1], goal = 2
Output: 4

Example 2:
Input: nums = [0,0,0,0,0], goal = 0
Output: 15

Constraints:


1 <= nums.length <= @data
nums[i] is either 0 or 1.
0 <= goal <= nums.length


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums, int goal) {
        return slidingWindowAtMost(nums, goal) - slidingWindowAtMost(nums, goal - 1);
    }
private:
    // Helper function to count the number of subarrays with sum at most the given goal
    int slidingWindowAtMost(vector<int> &nums, int goal){
        int start = 0, currentSum = 0, totalCount = 0; 
        
        // Iterate through the array using a sliding window approach
        for (int end = 0; end < nums.size(); end++) {
            currentSum += nums[end];
            
            // Adjust the window by moving the start pointer to the right
            // until the sum becomes less than or equal to the goal
            while (start <= end && currentSum > goal) {
                currentSum -= nums[start++];
            }

            // Update the total count by adding the length of the current subarray
            totalCount += end - start + 1;
        }
        return totalCount;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,goal; cin>>n>>goal;
    vector<int> num;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num,goal);
    
    // output
    cout<<result;
    return 0;
}",math,medium
273,"You are given an array nums consisting of positive integers.

We call a subarray of an array complete if the following condition is satisfied:

    The number of distinct elements in the subarray is equal to the number of distinct elements in the whole array.

Return the number of complete subarrays.

A subarray is a contiguous non-empty part of an array.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [1,3,1,2,2]
Output: 4

Example 2:
Input: nums = [5,5,5,5]
Output: 10

Constraints:

1 <= nums.length <= @data
1 <= nums[i] <= 2000

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums) {
    unordered_map<int, int> mp, all; 
    for(auto n: nums) all[n]++;      //put all elements to get the size of discrete elements
    int front = 0, back = 0, ans = 0;
    while(front < nums.size()){
        mp[nums[front]]++;
        while(back <= front && mp.size() == all.size()){
            if(--mp[nums[back]] == 0) mp.erase(nums[back]);  //update back pointer and map untill the condition satisfy
            back++;
            ans += (nums.size() - front);  //update answer - with number of array possible starting at pointer value of ""back""
        }
        front++;
    }
    return ans;
}
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",other,medium
274,"# Problem Statement
You are given a sequence $a=[a_1,a_2,\dots,a_n]$ consisting of $n$ **positive** integers.

Let's call a group of consecutive elements a segment. Each segment is characterized by two indices: the index of its left end and the index of its right end. Denote by $a[l,r]$ a segment of the sequence $a$ with the left end in $l$ and the right end in $r$, i.e. $a[l,r]=[a_l, a_{l+1}, \dots, a_r]$.

For example, if $a=[31,4,15,92,6,5]$, then $a[2,5]=[4,15,92,6]$, $a[5,5]=[6]$, $a[1,6]=[31,4,15,92,6,5]$ are segments.

We split the given sequence $a$ into segments so that:

-   each element is in **exactly** one segment;
-   the sums of elements for all segments are **equal**.

For example, if $a$ = \[$55,45,30,30,40,100$\], then such a sequence can be split into three segments: $a[1,2]=[55,45]$, $a[3,5]=[30, 30, 40]$, $a[6,6]=[100]$. Each element belongs to exactly segment, the sum of the elements of each segment is $100$.

Let's define thickness of split as the length of the longest segment. For example, the thickness of the split from the example above is $3$.

Find the minimum thickness among all possible splits of the given sequence of $a$ into segments in the required way.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the minimum thickness

# Example 1:  
- Input:  
n = 6
a = [55,45,30,30,40,100]
- Output:  
3

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq 10^5$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 5000, 10000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        int sum = 0;
        for (int i = 0; i < n; i++)
            sum += a[i];
        int ans = n;
        auto check = [&](int p) -> int
        {
            int tem = 0;
            int mx = 0;
            for (int l = 1, r = 1; l <= n;)
            {
                while (r <= n && tem + a[r - 1] <= p)
                    tem += a[(r++) - 1];
                if (tem != p)
                    return n;
                mx = max(r - l, mx);
                l = r;
                tem = 0;
            }
            return mx;
        };
        for (int i = 1; i * i <= sum && i <= n; i++)
        {
            if (sum % i == 0)
                ans = min(ans, check(sum / i));
            if (sum % i == 0 && (sum / i) != i && sum / i <= n)
                ans = min(ans, check(i));
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,math,two_pointers",easy
275,"Given an integer array nums and an integer k, modify the array in the following way:

    choose an index i and replace nums[i] with -nums[i].

You should apply this process exactly k times. You may choose the same index i multiple times.

Return the largest possible sum of the array after modifying it in this way.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& nums, int k) {
        
    }
};
```

Example 1:
Input: nums = [4,2,3], k = 1
Output: 5

Example 2:
Input: nums = [3,-1,0,2], k = 3
Output: 6

Constraints:

1 <= nums.length <= @data
-100 <= nums[i] <= 100
1 <= k <= 10^4

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums, int k) {
       sort(nums.begin(),nums.end());
        int n=nums.size(),mini=INT_MAX,sum=0;
        for(int i=0;i<n;i++){
            if(k && nums[i]<0){
                nums[i]=-1*nums[i];
                k--;
            }
        }
        for(int i=0;i<n;i++){
           mini=min(mini,nums[i]);
           sum+=nums[i];
        }
        k=k%2;
        
        if(mini>0 && k){
            sum-=2*mini;

        }
        if(mini<0 && k){
            sum+=-2*mini;
        }
        return sum;
               
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,k; cin>>n>>k;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s,k);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    printf(""%d"",result);
    return 0;
}","greedy,sort,other",easy
276,"You have n computers.  You are given the integer n and a 0-indexed integer array batteries where the ith battery can run a computer for batteries[i] minutes.  You are interested in running all n computers simultaneously using the given batteries.

Initially, you can insert at most one battery into each computer.  After that and at any integer time moment, you can remove a battery from a computer and insert another battery any number of times.  The inserted battery can be a totally new battery or a battery from another computer.  You may assume that the removing and inserting processes take no time.

Note that the batteries cannot be recharged.

Return the maximum number of minutes you can run all the n computers simultaneously.

solution main function

```cpp
class Solution {
public:
    long long solve(int n, vector<int>& batteries) {
        
    }
};
```

Example 1:
Input: n = 2, batteries = [3,3,3]
Output: 4

Example 2:
Input: n = 2, batteries = [1,1,1,1]
Output: 2

Constraints:

1 <= n <= batteries.length <= @data
1 <= batteries[i] <= 10^9

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    bool check(int n, vector<int>& batteries, long long mid) {
        long long target = n * mid; 
        long long sum = 0;
        
        for (int battery : batteries) {
            sum += min((long long)battery, mid); 
            if (sum >= target) return true;    
        }
        
        return false;
    }
    
    long long solve(int n, vector<int>& batteries) {
        long long low = 1; 
        long long high = accumulate(batteries.begin(), batteries.end(), 0LL) / n; 
        long long result = 0;
        
        while (low <= high) {
            long long mid = low + (high - low) / 2;
            
            if (check(n, batteries, mid)) {
                result = mid;  
                low = mid + 1; 
            } else {
                high = mid - 1; 
            }
        }
        
        return result;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    vector<int> s;
    for(int i=1;i<=m;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(n,s);
    
    // output
    cout << result << ""\n"";

    return 0;
}","greedy,sort,binary",medium
277,"# Problem Statement
Karel is a salesman in a car dealership. The dealership has $n$ different models of cars. There are $a_i$ cars of the $i$\-th model. Karel is an excellent salesperson and can convince customers to buy up to $x$ cars (of Karel's choice), as long as the cars are from different models.

Determine the minimum number of customers Karel has to bring in to sell all the cars.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, int &x, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the minimum possible number of customers needed to sell all the cars.

# Example 1:  
- Input: 
n = 3, x = 2, a = [3, 1, 2] 
- Output:  
3

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq x \leq 10$
- $1 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(int &n, int &x, vector<int> &a)
    {
        long long sum = 0;
        int mx = 0;
        for (int i = 0; i < n; i++)
        {
            sum += a[i];
            mx = max(mx, a[i]);
        }

        long long ans = max<long long>((sum + x - 1) / x, mx);
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, x;
    cin >> n >> x;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, x, a);

    // output
    cout << result << ""\n"";

    return 0;
}","search,math",hard
278,"# Problem Statement
A subarray is a continuous part of array.

Yarik recently found an array $a$ of $n$ elements and became very interested in finding the maximum sum of a **non empty** subarray. However, Yarik doesn't like consecutive integers with the same parity, so the subarray he chooses must have alternating parities for adjacent elements.

For example, $[1, 2, 3]$ is acceptable, but $[1, 2, 4]$ is not, as $2$ and $4$ are both even and adjacent.

You need to help Yarik by finding the maximum sum of such a subarray.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the maximum sum of the subarray

# Example 1:  
- Input:  
n = 5
a = [1, 2, 3, 4, 5]
- Output:  
15

# Constraints:  
- $1 \leq n \leq @data$
- $-10^3 \leq a[i] \leq 10^3$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        int ans = -1E9;
        int suf = -1E9;
        for (int i = 0; i < n; i++)
        {
            if (i && (a[i] - a[i - 1]) % 2 == 0)
            {
                suf = 0;
            }
            suf = max(suf, 0) + a[i];
            ans = max(ans, suf);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,two_pointers,dp",hard
279,"Given an n x n integer matrix grid, return the minimum sum of a falling path with non-zero shifts.

A falling path with non-zero shifts is a choice of exactly one element from each row of grid such that no two elements chosen in adjacent rows are in the same column.

solution main function

```cpp
class Solution {
public:
    int solve(vector<vector<int>>& grid) {
        
    }
};
```

Example 1:
Input: grid = [[1,2,3],[4,5,6],[7,8,9]]
Output: 13

Example 2:
Input: grid = [[7]]
Output: 7

Constraints:

n == grid.length == grid[i].length
1 <= n <= @data
-99 <= grid[i][j] <= 99

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[50, 100, 500]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<vector<int>>& grid) {
        int N = grid.size();
        int prev_min1 = -1, prev_min2 = -1;

        for (int r = N - 1; r >= 0; --r)
        {
            int cur_min1 = -1, cur_min2 = -1;

            for (int c = 0; c < N; ++c)
            {
                if (r < N - 1)
                    grid[r][c] += prev_min1 == c ? grid[r + 1][prev_min2] : grid[r + 1][prev_min1];

                if (cur_min1 == -1 || grid[r][c] < grid[r][cur_min1])
                {
                    cur_min2 = cur_min1;
                    cur_min1 = c;
                }
                else if (cur_min2 == -1 || grid[r][c] < grid[r][cur_min2])
                    cur_min2 = c; 
            }

            prev_min1 = cur_min1;
            prev_min2 = cur_min2;
        }

        return grid[0][prev_min1];
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<vector<int> > num;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int i=1;i<=n;i++)
        {
            int x; cin>>x;
            temp.push_back(x);
        }
        num.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num);
    
    // output
    cout<<result;
    return 0;
}",greedy,medium
280,"# Problem Statement
Today, Sakurako was studying arrays. An array $a$ of length $n$ is considered good if and only if:

-   the array $a$ is increasing, meaning $a_{i - 1} &lt; a_i$ for all $2 \le i \le n$;
-   the differences between adjacent elements are increasing, meaning $a_i - a_{i-1} &lt; a_{i+1} - a_i$ for all $2 \le i &lt; n$.

Sakurako has come up with boundaries $l$ and $r$ and wants to construct a good array of maximum length, where $l \le a_i \le r$ for all $a_i$.

Help Sakurako find the maximum length of a good array for the given $l$ and $r$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &l, int &r) {
        // write your code here
    }
};
```
where:  
- return:the length of the longest good array Sakurako can form given l and r. 

# Example 1:  
- Input:  
l = 1, r = 2
- Output:  
2

# Constraints:  
- $1 \leq l \leq r \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 1000000, 1000000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &l, int &r)
    {
        int n = r - l;
        int a = sqrt(2 * n);
        while (a * (a + 1) / 2 <= n) {
            a++;
        }
        return a;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int l, r;
    cin >> l >> r;

    // solve
    Solution solution;
    auto result = solution.solve(l, r);

    // output
    cout << result << ""\n"";

    return 0;
}",math,easy
281,"# Problem Statement
There is a rectangular maze of size $n\times m$. Denote $(r,c)$ as the cell on the $r$\-th row from the top and the $c$\-th column from the left. Two cells are adjacent if they share an edge. A path is a sequence of adjacent empty cells.

Each cell is initially empty. Li Hua can choose some cells (except $(x_1, y_1)$ and $(x_2, y_2)$) and place an obstacle in each of them. He wants to know the minimum number of obstacles needed to be placed so that there isn't a path from $(x_1, y_1)$ to $(x_2, y_2)$.

Suppose you were Li Hua, please solve this problem.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &m, int &x1, int &y1, int &x2, int &y2) {
        // write your code here
    }
};
```
where:  
- return the minimum number of obstacles needed to be placed.

# Example 1:  
- Input:
n = 4, m = 4
x1 = 2, y1 = 2, x2 = 3, y2 = 3
- Output:  
4

# Constraints:  
- $4 \leq n, m \leq @data$
- $1 \leq x1, x2 \leq n$
- $1 \leq y1, y2 \leq m$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 100000, 10000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, int &m, int &x1, int &y1, int &x2, int &y2)
    {
        int ans = min((x1 != 1) + (x1 != n) + (y1 != 1) + (y1 != m),
                     (x2 != 1) + (x2 != n) + (y2 != 1) + (y2 != m));
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, m;
    cin >> n >> m;
    int x1, x2, y1, y2;
    cin >> x1 >> y1 >> x2 >> y2;

    // solve
    Solution solution;
    auto result = solution.solve(n, m, x1, y1, x2, y2);

    // output
    cout << result << ""\n"";

    return 0;
}",graph,easy
282,"Given a string s. In one step you can insert any character at any index of the string.

Return the minimum number of steps to make s palindrome.

A Palindrome String is one that reads the same backward as well as forward.

solution main function

```cpp
class Solution {
public:
    int solve(string s) {
        
    }
};
```

Example 1:
Input: s = ""zzazz""
Output: 0

Example 2:
Input: s = ""mbadm""
Output: 2

Constraints:

1 <= s.length <= @data
s consists of lowercase English letters.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[50, 100, 1000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int lcs(string& s1, string& s2, int m, int n) {
        vector<int> dp(n + 1), dpPrev(n + 1);

        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                if (i == 0 || j == 0) {
                    // One of the two strings is empty.
                    dp[j] = 0;
                } else if (s1[i - 1] == s2[j - 1]) {
                    dp[j] = 1 + dpPrev[j - 1];
                } else {
                    dp[j] = max(dpPrev[j], dp[j - 1]);
                }
            }
            dpPrev = dp;
        }

        return dp[n];
    }

    int solve(string s) {
        int n = s.length();
        string sReverse = s;
        reverse(sReverse.begin(), sReverse.end());

        return n - lcs(s, sReverse, n, n);
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string s;cin>>s;
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    cout<<result;
    return 0;
}",string,medium
283,"# Problem Statement
You are given two binary strings $a$ and $b$. A binary string is a string consisting of the characters '0' and '1'.

Your task is to determine the maximum possible number $k$ such that a prefix of string $a$ of length $k$ is a subsequence of string $b$.

A sequence $a$ is a subsequence of a sequence $b$ if $a$ can be obtained from $b$ by the deletion of several (possibly, zero or all) elements.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(string &a, string &b) {
        // write your code here
    }
};
```
where:  
- return: the maximum possible number $k$ such that a prefix of string $a$ of length $k$ is a subsequence of string $b$.

# Example 1:  
- Input:  
a = ""10011""
b = ""1110""
- Output: 
2

# Constraints:  
- $1 \leq a.length, b.length \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(string &a, string &b)
    {
        int n = a.size();
        int m = b.size();
        int ans = 0;
        for (int i = 0; i < m; i++)
        {
            if (ans < n && b[i] == a[ans])
            {
                ans++;
            }
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    string a, b;
    cin >> a >> b;
    // solve
    Solution solution;
    auto result = solution.solve(a, b);

    // output
    cout << result << ""\n"";

    return 0;
}","two_pointers,string",easy
284,"You are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k.

Pick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized.

Return the minimum possible difference.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& nums, int k) {
        
    }
};
```

Example 1:
Input: nums = [90], k = 1
Output: 0

Example 2:
Input: nums = [9,4,1,7], k = 2
Output: 2

Constraints:

1 <= k <= nums.length <= @data
0 <= nums[i] <= 10^5

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums, int k) {
      sort(nums.begin(),nums.end());
      int sum=INT_MAX;
      int l=0,r=k-1;
      while(r<nums.size()){
        sum=min(sum,nums[r]-nums[l]);
        l=l+1,r=r+1;
      }
      return sum; 
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,k;cin>>n>>k;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s,k);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",math,easy
285,"Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.

solution main function

```cpp
class Solution {
public:
    long long solve(vector<vector<int>>& matrix) {
        
    }
};
```


Example 1:
Input: matrix =
[
  [0,1,1,1],
  [1,1,1,1],
  [0,1,1,1]
]
Output: 15

Example 2:
Input: matrix = 
[
  [1,0,1],
  [1,1,0],
  [1,1,0]
]
Output: 7

Constraints:

1 <= arr.length <= @data
1 <= arr[0].length <= data
0 <= arr[i][j] <= 1

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[50, 100, 1000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<vector<int>>& matrix) {
        int row = matrix.size(), col = matrix[0].size(), result = 0, prev = 0;
        vector<int> dp(col + 1, 0);

        for (int i = 1; i <= row; i++) {
            for (int j = 1; j <= col; j++) {
                if (matrix[i - 1][j - 1] == 1) {
                    int temp = dp[j];
                    dp[j] = 1 + min(prev, min(dp[j - 1], dp[j]));
                    prev = temp;
                    result += dp[j];
                } else {
                    dp[j] = 0;
                }
            }
        }
        return result;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    vector<vector<int> > mat;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=m;j++)
        {
            int x; cin>>x;
            temp.push_back(x);
        }
        mat.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(mat);
    
    // output
    cout<<result;
    return 0;
}",dp,medium
286,"You are given an m x n binary matrix grid and an integer health.

You start on the upper-left corner (0, 0) and would like to get to the lower-right corner (m - 1, n - 1).

You can move up, down, left, or right from one cell to another adjacent cell as long as your health remains positive.

Cells (i, j) with grid[i][j] = 1 are considered unsafe and reduce your health by 1.

Return true if you can reach the final cell with a health value of 1 or more, and false otherwise.  

solution main function
```cpp
class Solution {
public:
    bool solve(vector<vector<int>>& grid, int health) {
        
    }
};
```

Example 1:
Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]], health = 1
Output: true

Example 2:
Input: grid = [[0,1,1,0,0,0],[1,0,1,0,0,0],[0,1,1,1,0,1],[0,0,1,0,1,0]], health = 3
Output: false

Constraints:


m == grid.length
n == grid[i].length
1 <= m, n <= @data
2 <= m * n
1 <= health <= m + n
grid[i][j] is either 0 or 1.


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 20, 50]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    bool solve(vector<vector<int>>& grid, int health) {
        int n=grid.size();
        int m=grid[0].size();
        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>>qu;  //height : {row,col}
        vector<vector<int>>vis(n,vector<int>(m,0));
        if(grid[0][0]==1){
            qu.push({health-1,{0,0}});
        }
        else{
        qu.push({health,{0,0}});
        }
        vis[0][0]=1;
        
        while(!qu.empty()){
            int val=qu.top().first;
            int row=qu.top().second.first;
            int col=qu.top().second.second;

            if(row==n-1 && col==m-1){
                if(val>=1){
                    return true;
                }
            }

            qu.pop();
            int drow[4]={0,-1,0,1};
            int dcol[4]={-1,0,1,0};
            

            for(int i=0;i<4;i++){
                int n_row=row+drow[i];
                int n_col=col+dcol[i];
                if(n_row>=0 && n_row<n && n_col>=0 && n_col<m  &&  !vis[n_row][n_col] && grid[n_row][n_col]==0){
                    vis[n_row][n_col]=1;
                    qu.push({val,{n_row,n_col}});
                }
                else if (n_row>=0 && n_row<n && n_col>=0 && n_col<m  &&  !vis[n_row][n_col] && grid[n_row][n_col]!=0){
                    vis[n_row][n_col]=1;
                    qu.push({val-1,{n_row,n_col}});
                }
            }
        }

        return false;

    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m;
    vector<vector<int>> g;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=m;j++)
        {
            int x; cin>>x;
            temp.push_back(x);
        }
        g.push_back(temp);
    }
    int h;cin>>h;
    // solve
    Solution solution;
    auto result = solution.solve(g,h);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    printf(""%d"",result);
    return 0;
}","graph,search",medium
287,"# Problem Statement
ErnKor is ready to do anything for Julen, even to swim through crocodile-infested swamps. We decided to test this love. ErnKor will have to swim across a river with a width of $1$ meter and a length of $n$ meters.

The river is very cold. Therefore, **in total** (that is, throughout the entire swim from $0$ to $n+1$) ErnKor can swim in the water for no more than $k$ meters. For the sake of humanity, we have added not only crocodiles to the river, but also logs on which he can jump. Our test is as follows:

Initially, ErnKor is on the left bank and needs to reach the right bank. They are located at the $0$ and $n+1$ meters respectively. The river can be represented as $n$ segments, each with a length of $1$ meter. Each segment contains either a log 'L', a crocodile 'C', or just water 'W'. ErnKor can move as follows:

-   If he is on the surface (i.e., on the bank or on a log), he can jump forward for no more than $m$ ($1 \le m \le 10$) meters (he can jump on the bank, on a log, or in the water).
-   If he is in the water, he can only swim to the next river segment (or to the bank if he is at the $n$\-th meter).
-   ErnKor cannot land in a segment with a crocodile in any way.

Determine if ErnKor can reach the right bank.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, int &m, int &k, string &a) {
        // write your code here
    }
};
```
where:  
- output ""YES"" if ErnKor can pass the test, and output ""NO"" otherwise.

# Example 1:  
- Input:
n = 6, m = 2, k = 0
a = ""LWLLLW""  
- Output:  
YES

# Constraints:  
- $1 \leq n \leq @data$
- $0 \leq k \leq @data$
- $1 \leq m \leq 10$
- $a[i] \in \{ 'L', 'W', 'C' \}$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(int &n, int &m, int &k, string &a)
    {
        int x = -1;
        for (int i = 0; i <= n; i++)
        {
            if (x >= 0 && a[x] == 'W')
            {
                x = i;
                k--;
            }
            else if (i == n || a[i] == 'L' || i - x == m)
                x = i;
            if (x >= 0 && x < n && a[x] == 'C')
            {
                return ""NO"";
            }
        }
        return k >= 0 ? ""YES"" : ""NO"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, m, k;
    cin >> n >> m >> k;
    string a;
    cin >> a;
    // solve
    Solution solution;
    auto result = solution.solve(n, m, k, a);

    // output
    cout << result << ""\n"";

    return 0;
}","dp,greedy",hard
288,"# Problem Statement
Petya has an array $a_i$ of $n$ integers. His brother Vasya became envious and decided to make his own array of $n$ integers.

To do this, he found $m$ integers $b_i$ ($m\ge n$), and now he wants to choose some $n$ integers of them and arrange them in a certain order to obtain an array $c_i$ of length $n$.

To avoid being similar to his brother, Vasya wants to make his array as different as possible from Petya's array. Specifically, he wants the total difference $D = \sum_{i=1}^{n} |a_i - c_i|$ to be as large as possible.

Help Vasya find the maximum difference $D$ he can obtain.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, int &m, vector<int> &a, vector<int> &b) {   
        // write your code here
    }
};
```
where:  
- the return value is a 64-bit integer representing the maximum difference $D$

# Example 1:  
- Input:  
n = 4, m = 6
a = [6, 1, 2, 4]
b = [3, 5, 1, 7, 2, 3]
- Output:  
16

# Constraints:  
- $1 \leq n \leq m \leq @data$
- $1 \leq a[i], b[i] \leq 10^9$ 
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(int &n, int &m, vector<int> &a, vector<int> &b)
    {
        sort(b.begin(), b.end());
        sort(a.begin(), a.end());
        long long ans = 0;
        int l1 = 0, l2 = 0, r1 = n - 1, r2 = m - 1;
        for (int i = 0; i < n; i++)
        {
            if ((r2 >= 0) && (b[r2] - a[l1] > a[r1] - b[l2]))
                ans += b[r2] - a[l1], r2--, l1++;
            else
                ans += a[r1] - b[l2], r1--, l2++;
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, m;
    cin >> n >> m;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];
    vector<int> b(m);
    for (int i = 0; i < m; i++)
        cin >> b[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, m, a, b);

    // output
    cout << result << ""\n"";

    return 0;
}","two_pointers,data_structures,greedy,sort",hard
289,"The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).

    For example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.

Given an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.

Return the maximum such product difference.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [5,6,2,7,4]
Output: 34

Example 2:
Input: nums = [4,2,5,9,7,4,8]
Output: 64

Constraints:

2 <= nums.length <= @data
1 <= nums[i] <= 10^3

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums) {
        int biggest = 0;
        int secondBiggest = 0;
        int smallest = INT_MAX;
        int secondSmallest = INT_MAX;
        
        for (int num : nums) {
            if (num > biggest) {
                secondBiggest = biggest;
                biggest = num;
            } else {
                secondBiggest = max(secondBiggest, num);
            }
            
            if (num < smallest) {
                secondSmallest = smallest;
                smallest = num;
            } else {
                secondSmallest = min(secondSmallest, num);
            }
        }
        
        return biggest * secondBiggest - smallest * secondSmallest;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    vector<int> num;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num);
    
    // output
    cout<<result;
    return 0;
}",sort,easy
290,"# Problem Statement
Polycarp has $n$ coins, the value of the $i$\-th coin is $a_i$. Polycarp wants to distribute all the coins between his pockets, but he cannot put two coins with the same value into the same pocket.

For example, if Polycarp has got six coins represented as an array $a = [1, 2, 4, 3, 3, 2]$, he can distribute the coins into two pockets as follows: $[1, 2, 3], [2, 3, 4]$.

Polycarp wants to distribute all the coins with the minimum number of used pockets. Help him to do that.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {   
        // write your code here
    }
};
```
where:  
- `n` is the number of coins  
- `a` is the array of coin values  
- return the minimum number of pockets needed

# Example 1:  
- Input:
n = 6  
a = [1, 2, 4, 3, 3, 2]
- Output: 
2

# Constraints:  
- $1 \leq n \leq @data$  
- $1 \leq a[i] \leq 10^9$  
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        sort(a.begin(), a.end());
        int ans = 0, pre = 0, cnt = 0;
        for (int i = 0; i < n; i++)
        {
            if (a[i] == pre)
            {
                cnt++;
                ans = max(ans, cnt);
            }
            else
            {
                cnt = 1;
                pre = a[i];
                ans = max(ans, cnt);
            }
        }
        return ans;
    }
};


","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,sort",medium
291,"You are given an integer array prices representing the prices of various chocolates in a store. You are also given a single integer money, which represents your initial amount of money.

You must buy exactly two chocolates in such a way that you still have some non-negative leftover money. You would like to minimize the sum of the prices of the two chocolates you buy.

Return the amount of money you will have leftover after buying the two chocolates. If there is no way for you to buy two chocolates without ending up in debt, return money. Note that the leftover must be non-negative.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& prices, int money) {
        
    }
};
```

Constraints:

2 <= prices.length <= @data
1 <= prices[i] <= @data
1 <= money <= 2*@data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& prices, int money) {
        int prices1=INT_MAX,prices2=INT_MAX;
        for(auto k : prices){
            if(k<prices1){
                prices2=prices1;
                prices1=k;
            }
            else if(k<prices2){
                prices2=k;
            }
        }
        return prices1+prices2 > money ? money : money-prices1-prices2;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,k; cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    cin>>k;
    // solve
    Solution solution;
    auto result = solution.solve(s,k);
    // output
    cout << result << ""\n"";
    // for(auto it:result) cout<<it<<' ';
    return 0;
}","greedy,sort",medium
292,"Child A is playing a message game with his friends. The rules of the game are as follows:
There are n players, all of whom are numbered from 0 to n-1, and child A is numbered 0
Each player has a fixed number of other players to whom information can be transmitted (or not). The information transfer relationship is one-way (for example, A can send information to B, but B cannot send information to A).
Each round of information must need to be passed to another person, and the information can be repeated through the same person
Given the total number of players n, and the two-dimensional array relation formed by the [player number, corresponding to the passable player number] relation. Returns the number of schemes passed from minor A (number 0) to the small partner (number n-1) after k rounds; If it cannot be reached, return 0.
The number of schemes is modded to 998244353

solution main function
```cpp
class Solution
{
    public:
    int solve(int n, vector<vector<int>>& relation, int k)
}
```

Example 1:
Input: n = 5, base = [[0, 2], [2, 1], [3, 4], [2, 3], [1, 4], [2, 0], [0, 4]], k = 3
Output: 3

Example 2:
Input: n = 3, relation = [[0,2],[2,1]], k = 2
Output: 0

Constraints:

2 <= n <= @data
1 <= k <= @data

1 <= relation.length <= 10*@data, and relation[i].length == 2
0 <= relation[i][0],relation[i][1] < n and relation[i][0]! = relation[i][1]
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 100, 1000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    const long long mod=998244353;
    int solve(int n, vector<vector<int>>& relation, int k) {
        vector<long long> dp(n);
        dp[0] = 1;
        for (int i = 0; i < k; i++) {
            vector<long long> nxt(n);
            for (auto& edge : relation) {
                int src = edge[0], dst = edge[1];
                nxt[dst] = (nxt[dst]+dp[src])%mod;
            }
            dp = nxt;
        }
        return dp[n - 1];
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m,k; cin>>n>>m;
    vector< vector<int> > relation;
    for(int i=1,x,y;i<=m;i++)
    {
        cin>>x>>y;
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        relation.push_back(temp);
    }
    cin>>k;
    // solve
    Solution solution;
            auto result = solution.solve(n,relation,k);
    
    // output
    cout << result << ""\n"";

    return 0;
}","dp,graph",hard
293,"# Problem Statement
To celebrate his recovery, k1o0n has baked an enormous $n$ metres long potato casserole.

Turns out, Noobish\_Monk just can't stand potatoes, so he decided to ruin k1o0n's meal. He has cut it into $k$ pieces, of lengths $a_1, a_2, \dots, a_k$ meters.

k1o0n wasn't keen on that. Luckily, everything can be fixed. In order to do that, k1o0n can do one of the following operations:

-   Pick a piece with length $a_i \ge 2$ and divide it into two pieces with lengths $1$ and $a_i - 1$. As a result, the number of pieces will increase by $1$;
-   Pick a slice $a_i$ and another slice with length $a_j=1$ ($i \ne j$) and merge them into one piece with length $a_i+1$. As a result, the number of pieces will decrease by $1$.

Help k1o0n to find the minimum number of operations he needs to do in order to merge the casserole into one piece with length $n$.

For example, if $n=5$, $k=2$ and $a = [3, 2]$, it is optimal to do the following:

1.  Divide the piece with length $2$ into two pieces with lengths $2-1=1$ and $1$, as a result $a = [3, 1, 1]$.
2.  Merge the piece with length $3$ and the piece with length $1$, as a result $a = [4, 1]$.
3.  Merge the piece with length $4$ and the piece with length $1$, as a result $a = [5]$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &k, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the minimum number of operations K1o0n needs to restore his pie after the terror of Noobish_Monk.

# Example 1:  
- Input:  
n = 5, k = 3, a = [3, 1, 1]
- Output:  
2

# Constraints:  
- $2 \leq k \leq @data$
- $1 \leq n \leq 10^9$
- $1 \leq a[i] \leq n - 1$
- $\sum_{i=1}^k a[i] = n$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, int &k, vector<int> &a)
    {
        int max = *max_element(a.begin(), a.end());
        int ans = 2 * (n - max) - (k - 1);
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, k;
    cin >> n >> k;
    vector<int> a(k);
    for (int i = 0; i < k; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, k, a);

    // output
    cout << result << ""\n"";

    return 0;
}",sort,easy
294,"# Problem Statement
Ehab loves number theory, but for some reason he hates the number $x$. Given an array $a$, find the length of its longest subarray such that the sum of its elements **isn't** divisible by $x$, or determine that such subarray doesn't exist.

An array $a$ is a subarray of an array $b$ if $a$ can be obtained from $b$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &x, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- print the length of the longest subarray whose sum isn't divisible by x. If there's no such subarray, print 1.

# Example 1:  
- Input:  
n = 3, x = 3
a = [1,2,3]
- Output:  
2

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq x, a[i] \leq 10^4$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, int &x, vector<int> &a)
    {
        int u = -1, v = -1;
        int ans = -1, sum = 0;
        for (int i = 0; i < n; ++i)
        {
            sum = (sum + a[i]) % x;
            if (sum)
                ans = max(ans, i + 1);
            if (u != -1 && sum != u)
                ans = max(ans, i + 1 - v);
            if (u == -1 && sum)
            {
                u = sum;
                v = i + 1;
            }
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, x;
    cin >> n >> x;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, x, a);

    // output
    cout << result << ""\n"";

    return 0;
}","math,two_pointers,data_structures",medium
295,"There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at node 0. You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.

At every node i, there is a gate. You are also given an array of even integers amount, where amount[i] represents:

    the price needed to open the gate at node i, if amount[i] is negative, or,
    the cash reward obtained on opening the gate at node i, otherwise.

The game goes on as follows:

    Initially, Alice is at node 0 and Bob is at node bob.
    At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.
    For every node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that:
        If the gate is already open, no price will be required, nor will there be any cash reward.
        If Alice and Bob reach the node simultaneously, they share the price/reward for opening the gate there. In other words, if the price to open the gate is c, then both Alice and Bob pay c / 2 each. Similarly, if the reward at the gate is c, both of them receive c / 2 each.
    If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node 0, he stops moving. Note that these events are independent of each other.

Return the maximum net income Alice can have if she travels towards the optimal leaf node.

solution main function
```cpp
class Solution {
public:
    int solve(vector<vector<int>>& edges, int bob, vector<int>& amount) {
        
    }
};
```

Example 1:
Input: edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6]
Output: 6

Example 2:
Input: edges = [[0,1]], bob = 1, amount = [-7280,2350]
Output: -7280

Constraints:


2 <= n <= @data
edges.length == n - 1
edges[i].length == 2
0 <= ai, bi < n
ai != bi
edges represents a valid tree.
1 <= bob < n
amount.length == n
amount[i] is an even integer in the range [-10^4, 10^4]

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<vector<int>>adj;
    vector<int>par,dis;
	//Find the parent and distance from node 0
    void dfs(int u,int p = 0,int d = 0){
        dis[u] = d;
        par[u] = p;
        for(int v:adj[u]){
            if(v==p)continue;
            dfs(v,u,d+1);
        }
    }
	// Find total sum to each node
    int dfs2(int u,vector<int>&amount,int p= 0){
        int ret = amount[u];
        int mxc = -INT_MAX;
        for(int v:adj[u]){
            if(v!=p){
                mxc= max(mxc,dfs2(v,amount,u));
            }
        }
		//if the node is leaf we just return its amount
        if(mxc==-INT_MAX)return ret;
        else return ret+mxc;
    }
    int solve(vector<vector<int>>& edges, int bob, vector<int>& amount) {
        int n = amount.size();
        adj.resize(n,vector<int>());
        for(auto&e:edges){
            adj[e[0]].push_back(e[1]);
            adj[e[1]].push_back(e[0]);
        }
        par.resize(n);
        dis.resize(n);
        dfs(0);
        int cur = bob;
        int bob_dis = 0;
		//update the path of from Bob to 0
        while(cur!=0){
            if(dis[cur]>bob_dis){
                amount[cur] = 0;
            }else if(dis[cur]==bob_dis){
                amount[cur]/=2;
            }
            cur = par[cur];
            bob_dis++;
        }
        return dfs2(0,amount);
    }
    
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,bob; cin>>n>>bob;
    vector<vector<int> > edge;
    vector< int > val;
    for(int i=1,x,y,z;i<n;i++)
    {
        scanf(""%d"",&x);
        scanf(""%d"",&y);
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        edge.push_back(temp);
    }
    for(int i=1,x;i<=n;i++)
    {
        scanf(""%d"",&x);
        val.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(edge,bob,val);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    printf(""%d"",result);
    return 0;
}","graph,search",medium
296,"There is only one character 'A' on the screen of a notepad. You can perform one of two operations on this notepad for each step:
    Copy All: You can copy all the characters present on the screen (a partial copy is not allowed).
    Paste: You can paste the characters which are copied last time.
Given an integer n, return the minimum number of operations to get the character 'A' exactly n times on the screen.

solution main function
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

Example 1:
Input: n = 3
Output: 3

Example 2:
Input: n = 1
Output: 0

Constraints:
1 <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 1000000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(int n) {
        if (n == 1) return 0; // No steps needed for 1 'A'
        int steps = n; // In the worst case, we will need `n` steps (1 copy and `n-1` pastes)
        for (int d = 2; d <= sqrt(n); ++d) {
            if (n % d == 0) {
                // If `d` is a divisor of `n`, we calculate the steps for `d` and `n / d`
                steps = min(steps, solve(d) + (n / d));
                // Since we only need to consider divisors once, we also check the factor pair `n / d`
                steps = min(steps, solve(n / d) + d);
            }
        }
        return steps;
    }
};","#include <bits/stdc++.h>
#include <iterator>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
            auto result = solution.solve(n);
    
    // output
    cout<<result;
    return 0;
}",math,medium
297,"# Problem Statement
Sakurako's exams are over, and she did excellently. As a reward, she received a permutation $p$. Kosuke was not entirely satisfied because he failed one exam and did not receive a gift. He decided to sneak into her room (thanks to the code for her lock) and spoil the permutation so that it becomes simple.

A permutation $p$ is considered simple if for every $i$ $(1\le i \le n)$ one of the following conditions holds:

-   $p_i=i$
-   $p_{p_i}=i$

For example, the permutations $[1, 2, 3, 4]$, $[5, 2, 4, 3, 1]$, and $[2, 1]$ are simple, while $[2, 3, 1]$ and $[5, 2, 1, 4, 3]$ are not.

In one operation, Kosuke can choose indices $i,j$ $(1\le i,j\le n)$ and swap the elements $p_i$ and $p_j$.

Sakurako is about to return home. Your task is to calculate the minimum number of operations that Kosuke needs to perform to make the permutation simple.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &p) {   
        // write your code here
    }
};
```
where:  
- the return value is the minimum number of operations needed to make the permutation simple

# Example 1:  
- Input:  
n = 5
p = [1, 2, 3, 4, 5]
- Output:  
0

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq p[i] \leq n$ 
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[100, 10000, 1000000]",1000.0,"[[6400, 640, 256]]","class Solution
{
public:
    int solve(int &n, vector<int> &p)
    {
        int ans = 0;
        vector<bool> vis(n);
        for (int i = 0; i < n; i++)
        {
            p[i]--;
        }
        for (int i = 0; i < n; i++)
        {
            if (vis[i])
                continue;
            int j = i;
            int len = 0;
            while (!vis[j])
            {
                vis[j] = true;
                j = p[j];
                len++;
            }
            ans += (len - 1) / 2;
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","data_structures,graph,greedy,search",hard
298,"Given a positive integer n, find the pivot integer x such that:

    The sum of all elements between 1 and x inclusively equals the sum of all elements between x and n inclusively.

Return the pivot integer x. If no such integer exists, return -1. It is guaranteed that there will be at most one pivot index for the given input.

solution main function

```cpp
class Solution {
public:
    int solve(int n) {
        
    }
};
```

Example 1:
Input: n = 8
Output: 6

Example 2:
Input: n = 1
Output: 1

Constraints:

1 <= n <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
 public:
  int solve(int n) {
        const int sum = (n * (n + 1) / 2);
        const int pivot = sqrt(sum);
        // If pivot * pivot is equal to sum (pivot found) return pivot, else return -1
        return pivot * pivot == sum ? pivot : -1;
  }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
    auto result = solution.solve(n);
    // output
    cout << result << ""\n"";
    // for(auto it:result) cout<<it<<' ';
    return 0;
}",math,easy
299,"Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sortedThe answer is modulo 998224353.

A string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.

solution main function
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

Example 1:
Input: n = 1
Output: 5

Example 2:
Input: n = 2
Output: 15

Constraints:
1 <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 1000000]",1000.0,"[[12800, 1280, 128]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    const long long mod=998244353;
    const long long inv_24=291154603;
    int solve(long long n) {
        return (n + 1ll) * (n + 2ll)%mod * (n + 3ll)%mod * (n + 4ll)%mod * inv_24%mod;
    }
};","#include <bits/stdc++.h>
#include <iterator>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
            auto result = solution.solve(n);
    
    // output
    cout<<result;
    return 0;
}","dp,math",hard
300,"Given two integer arrays arr1 and arr2, return the minimum number of operations (possibly zero) needed to make arr1 strictly increasing.

In one operation, you can choose two indices 0 <= i < arr1.length and 0 <= j < arr2.length and do the assignment arr1[i] = arr2[j].

If there is no way to make arr1 strictly increasing, return -1.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& arr1, vector<int>& arr2) {
        
    }
};
```

Example 1:
Input: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]
Output: 1

Example 2:
Input: arr1 = [1,5,3,6,7], arr2 = [4,3,1]
Output: 2

Constraints:

1 <= arr1.length, arr2.length <= @data
0 <= arr1[i], arr2[i] <= 10^9

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[50, 100, 600]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& arr1, vector<int>& arr2) {
        arr1.insert(arr1.begin(),-1);
        arr1.push_back(2e9);
        sort(arr2.begin(), arr2.end());
        arr2.erase(unique(arr2.begin(), arr2.end()), arr2.end());
        int n = arr1.size();
        vector<int> dp(n, 1e9);
        dp[0] = 0;
        int m = arr2.size();
        for (int i = 1; i < n; i++) {
            if (arr1[i] > arr1[i - 1])
                dp[i] = dp[i - 1];
            for (int j = 0; j < i; j++) {
                int idx = lower_bound(arr2.begin(), arr2.end(), arr1[j] + 1) -
                          arr2.begin();
                int cnt = i - j - 1;
                if (idx + cnt <= m && idx + cnt > 0 &&
                    arr2[idx + cnt - 1] < arr1[i]&&arr1[i]>arr1[j]) {
                    dp[i] = min(dp[j] + cnt, dp[i]);
                }
            }
        }
        if (dp[n - 1] == 1e9)
            return -1;
        else
            return dp[n - 1];
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m;
    vector<int> a,b;
    cin>>n>>m;
    for(int i=1,x;i<=n;i++)
    {
        cin>>x;
        a.push_back(x);
    }
    for(int i=1,x;i<=m;i++)
    {
        cin>>x;
        b.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(a,b);
    
    // output
    cout<<result;
    return 0;
}","sort,binary",hard
301,"# Problem Statement:
YunQian is standing on an infinite plane with the Cartesian coordinate system on it. In one move, she can move to the diagonally adjacent point on the top right or the adjacent point on the left.

That is, if she is standing on point $(x,y)$, she can either move to point $(x+1,y+1)$ or point $(x-1,y)$.

YunQian initially stands at point $(a,b)$ and wants to move to point $(c,d)$. Find the minimum number of moves she needs to make or declare that it is impossible.

The main function of the solution is defined as: 
```cpp
class Solution {
public:
    int solve(int &a, int &b, int &c, int &d) {
        // write your code here
    }
};
```

Where:  
- `a, b, c, d`: integers representing the coordinates of Yunqian's initial position and target position.  
- return value: the minimum number of moves Yunqian needs to make to reach the target position. If it is impossible to reach the target position, return -1.

# Example 1:
- Input:  
a = -1, b = 0, c = -1, d = 2
- Output:  
4

# Constraints:
- $-@data \leq a, b, c, d \leq @data$  
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &a, int &b, int &c, int &d)
    {
        a -= b;
        c -= d;
        if (a < c || b > d)
            return -1;
        return (a - c) + (d - b);
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int a, b, c, d;
    cin >> a >> b >> c >> d;
    // solve
    Solution solution;
    auto result = solution.solve(a, b, c, d);

    // output
    cout << result << ""\n"";

    return 0;
}","graph,greedy,math",hard
302,"# Problem Statement
There are n guilty people in a line, the i-th of them holds a claw with length Li. The bell rings and every person kills some of people in front of him. All people kill others at the same time. Namely, the i-th person kills the j-th person if and only if j<i and ji-Li.

You are given lengths of the claws. You need to find the total number of alive people after the bell rings.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the total number of alive people after the bell rings.

# Example 1:  
- Input:  
n = 4
L = [0, 1, 0, 10]
- Output:  
1

# Constraints:  
- $1 \leq n \leq @data$
- $0 \leq L[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &L)
    {
        for (int i = n - 1; i > 0; i--)
            L[i - 1] = max(L[i - 1], L[i] - 1);
        int ans = 1 + count(L.begin() + 1, L.end(), 0);
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,implementation",medium
303,"You are given a 2D integer array intervals where intervals[i] = [lefti, righti] represents the inclusive interval [lefti, righti].

You have to divide the intervals into one or more groups such that each interval is in exactly one group, and no two intervals that are in the same group intersect each other.

Return the minimum number of groups you need to make.

Two intervals intersect if there is at least one common number between them. For example, the intervals [1, 5] and [5, 8] intersect.

solution main function

```cpp
class Solution {
public:
    int solve(vector<vector<int>>& intervals) {
        
    }
};
```

Example 1:
Input: intervals = [[5,10],[6,8],[1,5],[2,3],[1,10]]
Output: 3

Example 2:
Input: intervals = [[1,3],[5,6],[8,10],[11,13]]
Output: 1

Constraints:

1 <= intervals.length <= @data
intervals[i].length == 2
1 <= lefti <= righti <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 1280, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    struct cmp {
        bool operator()(const pair<int,int>& a, const pair<int,int>& b) {
            if (a.first == b.first)
                return a.second > b.second;
            return a.first > b.first;
        }
    };
    struct cmp2 {
        bool operator()(const int& a, const int& b) { return a > b; }
    };
    int solve(vector<vector<int>>& intervals) {
        int n = intervals.size();
        sort(intervals.begin(), intervals.end());
        priority_queue<int, vector<int>, greater<int>> group;
        for(int i=0;i<n;i++) {
            pair<int,int> cur = make_pair(intervals[i][0],intervals[i][1]);
            if(group.empty())
                group.push(cur.second);
            else{
                int tail = group.top();
                if (tail < cur.first) {
                    tail = cur.second;
                    group.pop();
                    group.push(tail);
                } else
                    group.push(cur.second);
            }
        }
        return group.size();
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    vector<vector<int> > num;
    cin>>n;
    for(int i=1,x,y;i<=n;i++)
    {
        cin>>x>>y;
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        num.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num);
    
    // output
    cout<<result;
    return 0;
}","sort,greedy",medium
304,"There exists an undirected tree with n nodes numbered 0 to n - 1. You are given a 0-indexed 2D integer array edges of length n - 1, where edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the tree. You are also given a positive integer k, and a 0-indexed array of non-negative integers nums of length n, where nums[i] represents the value of the node numbered i.

Alice wants the sum of values of tree nodes to be maximum, for which Alice can perform the following operation any number of times (including zero) on the tree:

    Choose any edge [u, v] connecting the nodes u and v, and update their values as follows:
        nums[u] = nums[u] XOR k
        nums[v] = nums[v] XOR k

Return the maximum possible sum of the values Alice can achieve by performing the operation any number of times.

solution main function
```cpp
class Solution {
public:
    long long solve(vector<int>& nums, int k, vector<vector<int>>& edges) {
        
    }
};
```

Example 1:
Input: nums = [1,2,1], k = 3, edges = [[0,1],[0,2]]
Output: 6

Example 2:
Input: nums = [2,3], k = 7, edges = [[0,1]]
Output: 9

Constraints:

2 <= n == nums.length <= @data
1 <= k <= 10^9
0 <= nums[i] <= 10^9
edges.length == n - 1
edges[i].length == 2
0 <= edges[i][0], edges[i][1] <= n - 1
The input is generated such that edges represent a valid tree.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    typedef long long ll;
    long long solve(vector<int>& nums, int k, vector<vector<int>>& edges) {
        ll sum=0,cnt=0,sacrificeVal=1e18;
        for(int ele:nums){
            if((ele^k)>ele){
                sum+=(ele^k);
                sacrificeVal=min(sacrificeVal,1LL*((ele^k)-ele));
                cnt++; // increasing count of nodes whose val wnt to increase
            }
            else{
                sum+=ele;
                sacrificeVal=min(sacrificeVal,1LL*(ele-(ele^k)));
            }
        }
        if(cnt&1) return sum-sacrificeVal;
        return sum;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,k;
    vector<int > num;
    vector<vector<int> > e;
    cin>>n>>k;
    for(int i=1,x;i<=n;i++)
    {
        cin>>x;
        num.push_back(x);
    }
    for(int i=1;i<n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=2;j++)
        {
            int x; cin>>x;
            temp.push_back(x);
        }
        e.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(num,k,e);
    
    // output
    cout<<result;
    return 0;
}","sort,greedy,tree,bit_manipulation",hard
305,"Given an integer array nums, return the greatest common divisor of the smallest number and largest number in nums.

The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [2,5,6,9,10]
Output: 2

Example 2:
Input: nums = [7,5,6,8,3]
Output: 1

Constraints:

2 <= nums.length <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
    public:
        int gcd(int a, int b) {
            if (b == 0) return a;
            return gcd(b, a % b);
        }
        int solve(vector<int> &nums) {
            int min = 1e8;
            int max = 0;
            // Find the min and max from array
            for (int e : nums) {
                if (e < min) min = e;
                if (e > max) max = e;
            }
            return gcd(min, max);
        }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",math,easy
306,"Xiao Ming's flower shop has just opened. In order to attract customers, he wants to put a row of flowers in front of the shop, with a total of $m$POTS. By investigating customers' preferences, Xiao Ming made a list of customers' favorite $n$flowers. In order to display more flowers at the door, it is stipulated that the $i$flower can not exceed the $a_i$pot, and the same flower is placed together when the flowers are arranged, and the different kinds of flowers need to be arranged in order from the smallest to the largest according to the label.
Try programming to figure out how many different flower arrangements there are.

solution main function
```cpp
class Solution
{
    public:
    int solve(int n, int m, vector<int> &a)
}
```
Example 1:
Input: n=2,m=4,a=[3, 2]
Output: 2

Constraints:
0<n,m@data
0a[i]100
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 50, 100]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution
{
public:
    int solve(int n, int m, vector<int> &a)
    {
        const int mod = 1000007;
        a.insert(a.begin(), 0);
        vector<int> f(m + 1, 0), sum(m + 1, 0);
        f[0] = 1;

        for (int i = 0; i <= m; i++) 
            sum[i] = 1;

        for (int i = 1; i <= n; i++)
        {
            for (int j = m; j >= 1; j--)
            {
                int t = j - min(a[i], j) - 1;
                if (t < 0)
                    f[j] = (f[j] + sum[j - 1]) % mod;
                else
                    f[j] = (f[j] + sum[j - 1] - sum[t] + mod) % mod;
            }

            for (int j = 1; j <= m; j++)
                sum[j] = (sum[j - 1] + f[j]) % mod;
        }

        return f[m];
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m;
    vector<int> a;
    cin>>n>>m;
    for(int i=1,x;i<=n;i++)
    {
        cin>>x;
        a.push_back(x);
    }

    // solve
    Solution solution;
            auto result = solution.solve(n,m,a);
    
    // output
    cout << result << ""\n"";

    return 0;
}",dp,hard
307,"# Problem Statement
The girl named Masha was walking in the forest and found a complete binary tree of height $n$ and a permutation $p$ of length $m=2^n$.

A complete binary tree of height $n$ is a rooted tree such that every vertex except the leaves has exactly two sons, and the length of the path from the root to any of the leaves is $n$. The picture below shows the complete binary tree for $n=2$.

A permutation is an array consisting of $n$ different integers from $1$ to $n$. For example, \[$2,3,1,5,4$\] is a permutation, but \[$1,2,2$\] is not ($2$ occurs twice), and \[$1,3,4$\] is also not a permutation ($n=3$, but there is $4$ in the array).

Let's enumerate $m$ leaves of this tree from left to right. The leaf with the number $i$ contains the value $p_i$ ($1 \le i \le m$).

Masha considers a tree beautiful if the values in its leaves are ordered from left to right in increasing order.

In one operation, Masha can choose any non-leaf vertex of the tree and swap its left and right sons (along with their subtrees).

Help Masha understand if she can make a tree beautiful in a certain number of operations. If she can, then output the minimum number of operations to make the tree beautiful.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &m, vector<int> &p) {
        // write your code here
    }
};
```
where:  
- print the minimum possible number of operations for which Masha will be able to make the tree beautiful or -1, if this is not possible.

# Example 1:  
- Input:  
m = 8
p = [6, 5, 7, 8, 4, 3, 1, 2]
- Output:  
4


# Constraints:  
- $1 \leq m \leq @data$
- $m$ is a power of $2$
- $1 \leq p[i] \leq m$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 131072]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        int ans = 0;
        for (int len = 2; len <= n; len *= 2)
        {
            for (int i = 0; i < n; i += len)
            {
                if (a[i] > a[i + len / 2])
                {
                    ans++;
                    for (int j = 0; j < len / 2; j++)
                        swap(a[i + j], a[i + len / 2 + j]);
                }
            }
        }
        for (int i = 0; i < n; i++)
        {
            if (a[i] != i + 1)
                ans = -1;
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{

    // input
    int m;
    cin >> m;
    vector<int> p(m);
    for (int i = 0; i < m; i++)
        cin >> p[i];

    // solve
    Solution solution;
    auto result = solution.solve(m, p);
    
    // output
    cout << result << ""\n"";

    return 0;
}","search,graph,tree,sort",hard
308,"Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.)

(Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.)

Since the answer may be large, return the answer modulo 10^9 + 7.

solution main function
```cpp
class Solution {
public:
    int solve(int n) {
        
    }
};
```

Example 1:
Input: n = 5
Output: 12

Example 2:
Input: n = 100
Output: 682289015

Constraints:

1 <= n <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 500, 1000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int prime(int n) {
        if (n == 1) {
            return 0; 
        }
        for (int i = 2; i * i <= n; ++i) {
            if (n % i == 0) {
                return 0; 
            }
        }
        return 1; 
    }

    int solve(int n) {
        int count = 0; 
        for (int i = 1; i <= n; ++i) {
            if (prime(i) == 1) {
                count++; 
            }
        }
        long long int perm = 1; 
        for (int i = 1; i <= count; ++i) {
            perm = (perm * i) % 1000000007; 
        }
        for (int i = 1; i <= n - count; ++i) {
            perm = (perm * i) % 1000000007; 
        }
        return perm; 
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
    auto result = solution.solve(n);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",math,easy
309,"# Problem Statement
You are given an array $a$ of size $n$. You will do the following process to calculate your penalty:

1.  Split array $a$ into two (possibly empty) subsequences$^\dagger$ $s$ and $t$ such that every element of $a$ is either in $s$ or $t^\ddagger$.
2.  For an array $b$ of size $m$, define the penalty $p(b)$ of an array $b$ as the number of indices $i$ between $1$ and $m - 1$ where $b_i &lt; b_{i + 1}$.
3.  The total penalty you will receive is $p(s) + p(t)$.

If you perform the above process optimally, find the minimum possible penalty you will receive.

$^\dagger$ A sequence $x$ is a subsequence of a sequence $y$ if $x$ can be obtained from $y$ by the deletion of several (possibly, zero or all) elements.

$^\ddagger$ Some valid ways to split array $a=[3,1,4,1,5]$ into $(s,t)$ are $([3,4,1,5],[1])$, $([1,1],[3,4,5])$ and $([\,],[3,1,4,1,5])$ while some invalid ways to split $a$ are $([3,4,5],[1])$, $([3,1,4,1],[1,5])$ and $([1,3,4],[5,1])$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- output a single integer representing the minimum possible penalty you will receive.

# Example 1:  
- Input: 
n = 5
a = [1, 2, 3, 4, 5]
- Output:  
3

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq n$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        int ans = 0;
        for (int i = 0, x = n, y = n, ai; i < n; i += 1)
        {
            ai = a[i];
            if (ai > x and ai > y)
            {
                ans += 1;
                (x < y ? x : y) = ai;
            }
            else if (ai <= x and ai <= y)
            {
                (x < y ? x : y) = ai;
            }
            else if (ai <= x)
            {
                x = ai;
            }
            else
            {
                y = ai;
            }
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",dp,hard
310,"# Problem Statement
There are $n$ families travelling to Pnjamo to witness Mexico's largest-ever ""walking a chicken on a leash"" marathon. The $i$\-th family has $a_i$ family members. All families will travel using a single bus consisting of $r$ rows with $2$ seats each.

A person is considered happy if:

-   Another family member is seated in the same row as them, or
-   They are sitting alone in their row (with an empty seat next to them).

Determine the maximum number of happy people in an optimal seating arrangement. Note that **everyone** must be seated in the bus.

It is guaranteed that all family members will fit on the bus. Formally, it is guaranteed that $\displaystyle\sum_{i=1}^{n}a_i \le 2r$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &r, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return:the maximum number of happy people in an optimal seating arrangement. 

# Example 1:  
- Input: 
n = 3, r = 3, a = [2, 3, 1]
- Output:  
4

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq r \leq 10^3$
- $1 \leq a[i] \leq 10^3$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, int &r, vector<int> &a)
    {
        int s = 0;
        int odd = 0;
        for (int i = 0; i < n; i++)
        {
            s += a[i];
            odd += a[i] % 2;
        }

        int ans = s - max(0, (s + odd) / 2 - r) * 2;
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, r;
    cin >> n >> r;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, r, a);

    // output
    cout << result << ""\n"";

    return 0;
}",math,easy
311,"You are given an array nums consisting of positive integers.

Return the total frequencies of elements in nums such that those elements all have the maximum frequency.

The frequency of an element is the number of occurrences of that element in the array.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [1,2,2,3,1,4]
Output: 4

Example 2:
Input: nums = [1,2,3,4,5]
Output: 5

Constraints:

1 <= nums.length <= @data
1 <= nums[i] <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums) {
        unordered_map<int, int> frequencies;
        int maxFrequency = 0;
        int totalFrequencies = 0;

        // Find the frequency of each element
        // Determine the maximum frequency
        // Calculate the total frequencies of elements with the maximum frequency
        for (int num : nums) {
            frequencies[num]++;
            int frequency = frequencies[num];

            // If we discover a higher frequency element
            // Update maxFrequency
            // Re-set totalFrequencies to the new max frequency
            if (frequency > maxFrequency) {
                maxFrequency = frequency;
                totalFrequencies = frequency;
                // If we find an element with the max frequency, add it to the total
            } else if (frequency == maxFrequency) {
                totalFrequencies += frequency;
            }
        }
        return totalFrequencies;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> a;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        a.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(a);
    // output
    cout << result << ""\n"";
    // for(auto it:result) cout<<it<<' ';
    return 0;
}",math,easy
312,"# Problem Statement
You are given a string $s$ consisting of the characters 0, 1, and ?.

Let's call a string **unstable** if it consists of the characters 0 and 1 and any two adjacent characters are different (i.e. it has the form 010101... or 101010...).

Let's call a string **beautiful** if it consists of the characters 0, 1, and ?, and you can replace the characters ? to 0 or 1 (for each character, the choice is independent), so that the string becomes **unstable**.

For example, the strings 0??10, 0, and ??? are beautiful, and the strings 00 and ?1??1 are not.

Calculate the number of beautiful contiguous substrings of the string $s$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(string &s) {
        // write your code here
    }
};
```
where:  
- return:the number of beautiful substrings of the string s.

# Example 1:  
- Input:  
s = ""0?10""
- Output:  
8

# Constraints:  
- $1 \leq |s| \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(string &s)
    {
        int type = 0, cnt = 0;
        long long ans = 0;
        for (int i = 0, j = 0; i < (int)s.size(); i += 1)
        {
            while (j < (int)s.size())
            {
                if (s[j] == '?')
                    j += 1;
                else if (cnt == 0 or type == (s[j] - '0') ^ (j % 2))
                {
                    cnt += 1;
                    type = (s[j] - '0') ^ (j % 2);
                    j += 1;
                }
                else
                    break;
            }
            ans += j - i;
            if (s[i] != '?')
                cnt -= 1;
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    string s;
    cin >> s;

    // solve
    Solution solution;
    auto result = solution.solve(s);

    // output
    cout << result << ""\n"";

    return 0;
}","search,string,dp,two_pointers",hard
313,"# Problem Statement
Vasya has two hobbies adding permutations$^{\dagger}$ to arrays and finding the most frequently occurring element. Recently, he found an array $a$ and decided to find out the maximum number of elements equal to the same number in the array $a$ that he can obtain after adding some permutation to the array $a$.

More formally, Vasya must choose exactly one permutation $p_1, p_2, p_3, \ldots, p_n$ of length $n$, and then change the elements of the array $a$ according to the rule $a_i := a_i + p_i$. After that, Vasya counts how many times each number occurs in the array $a$ and takes the maximum of these values. You need to determine the maximum value he can obtain.

$^{\dagger}$A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {   
        // write your code here
    }
};
```
where:  
- the return value is the maximum value he can obtain

# Example 1:  
- Input:  
n = 2
a = [1, 2]
- Output:  
2

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {

        sort(a.begin(), a.end());
        a.erase(unique(a.begin(), a.end()), a.end());
        int ans = 0;
        for (int i = 0, j = 0; i < a.size(); i++)
        {
            while (j < a.size() && a[j] < a[i] + n)
                j++;
            ans = max(ans, j - i);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","two_pointers,binary,greedy,sort",hard
314,"# Problem Statement
One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.

He defined a snowflake as an undirected graph constructed according to the following rules:

-   Initially, the graph has only one vertex.
-   Then, more vertices are added to the graph. The initial vertex is connected by edges to $k$ new vertices ($k > 1$).
-   Each vertex that is connected to only one other vertex is connected by edges to $k$ more new vertices. This step should be done **at least once**.

After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check if a snowflake with $n$ vertices can exist.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n) {   
        // write your code here
    }
};
```
where:  
- return ""YES"" if a snowflake with $n$ vertices can exist, otherwise return ""NO"".

# Example 1:  
- Input:  
n = 15
- Output:  
""YES""

# Constraints:  
- $1 \leq n \leq @data$  
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[100, 10000, 1000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(int &n)
    {
        int ok = 0;
        for (int i = 2; i <= n && !ok; i++)
        {
            long long sum = 1 + i + 1LL * i * i, p = 1LL * i * i;
            if (sum > n)
                break;
            while (sum < n)
                sum += p *= i;
            if (sum == n)
                ok = 1;
        }
        return ok ? ""YES"" : ""NO"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;

    // solve
    Solution solution;
    auto result = solution.solve(n);

    // output
    cout << result << ""\n"";

    return 0;
}",math,medium
315,"# Problem Statement
A girl is preparing for her birthday and wants to buy the most beautiful bouquet. There are a total of $n$ flowers in the store, each of which is characterized by the number of petals, and a flower with $k$ petals costs $k$ coins. The girl has decided that the difference in the number of petals between any two flowers she will use in her bouquet should not exceed one. At the same time, the girl wants to assemble a bouquet with the maximum possible number of petals. Unfortunately, she only has $m$ coins, and she cannot spend more. What is the maximum total number of petals she can assemble in the bouquet?

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, long long &m, vector<int> &a) {   
        // write your code here
    }
};
```
where:  
- The return value is the maximum total number of petals that can be assembled in the bouquet. Note that the answer may be very large and should be stored in a 64-bit integer type.

# Example 1:  
- Input:  
n = 5, m = 10
a = [1, 1, 2, 2, 3]
- Output:  
7

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq m \leq 10^18$
- $1 \leq a[i] \leq 10^9$ 
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(int &n, long long &m, vector<int> &a)
    {
        sort(a.begin(), a.end());
        long long max_sum = 0, current_sum = 0;
        int l = 0;
        for (int r = 0; r < n; r++)
        {
            current_sum += a[r];
            while (l <= r && (a[r] - a[l] > 1 || current_sum > m))
            {
                current_sum -= a[l];
                l++;
            }
            max_sum = max(max_sum, current_sum);
        }
        return max_sum;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    long long m;
    cin >> n >> m;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, m, a);

    // output
    cout << result << ""\n"";

    return 0;
}","two_pointers,greedy,sort",medium
316,"You are given an array of strings products and a string searchWord.
Design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products.
Return a list of lists of the suggested products after each character of searchWord is typed.

solution main function
```cpp
class Solution {
public:
    vector<vector<string>> solve(vector<string>& products, string searchWord){

    }
};
```

Example 1:
Input: products = [""mobile"",""mouse"",""moneypot"",""monitor"",""mousepad""], searchWord = ""mouse""
Output: [[""mobile"",""moneypot"",""monitor""],[""mobile"",""moneypot"",""monitor""],[""mouse"",""mousepad""],[""mouse"",""mousepad""],[""mouse"",""mousepad""]]

Example 2:
Input: products = [""havana""], searchWord = ""havana""
Output: [[""havana""],[""havana""],[""havana""],[""havana""],[""havana""],[""havana""]]

Constraints:
1 <= products.length <= @data
1 <= products[i].length <= 3000
1 <= sum(products[i].length) <= 2 * 10^4
All the strings of products are unique.
products[i] consists of lowercase English letters.
1 <= searchWord.length <= @data
searchWord consists of lowercase English letters.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 500, 1000]",1000.0,"[[12800, 1280, 128]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<vector<string>> solve(vector<string>& products, string searchWord) {
        sort(products.begin(), products.end());
        string query;
        auto iter_last = products.begin();
        vector<vector<string>> ans;
        for (char ch : searchWord) {
            query += ch;
            auto iter_find = lower_bound(iter_last, products.end(), query);
            vector<string> selects;
            for (int i = 0; i < 3; ++i) {
                if (iter_find + i < products.end() && (*(iter_find + i)).find(query) == 0) {
                    selects.push_back(*(iter_find + i));
                }
            }
            ans.push_back(move(selects));
            iter_last = iter_find;
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    cin>>n;
    vector<string> dic;
    string bas;
    for(int i=1;i<=n;i++)
    {
        cin>>bas;
        dic.push_back(bas);
    }
    cin>>bas;
    // solve
    Solution solution;
            auto result = solution.solve(dic,bas);
    
    // output
    for(auto it:result)
    {
        for(auto str:it)
            cout<<str<<' ';
        cout<<endl;
    }
    return 0;
}","string,binary",easy
317,"There are n servers numbered from 0 to n - 1 connected by undirected server-to-server connections forming a network where connections[i] = [ai, bi] represents a connection between servers ai and bi. Any server can reach other servers directly or indirectly through the network.
A critical connection is a connection that, if removed, will make some servers unable to reach some other server.
Return all critical connections in the network in any order.

solution main function
```cpp
class Solution
{
    public:
    vector<vector<int>> solve(int n, vector<vector<int>>& connections)
}
```


Example 1:
Inputn = 4, connections = [[0,1],[1,2],[2,0],[1,3]]
Output: [[1,3]]

Example 2:
Inputn = 2, connections = [[0,1]]
Output: [[0,1]]

Constraints:
2 <= n <= @data
n - 1 <= connections.length <= 10^5
0 <= a[i], b[i] <= n - 1
a[i] != b[i]
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 100, 10000]",1000.0,"[[6400, 4000, 2200]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<vector<int> > solve(int n, vector<vector<int> >& connections) {
        vector<vector<int>> dict(n);
        for(auto& edge:connections){
            dict[edge[0]].emplace_back(edge[1]);
            dict[edge[1]].emplace_back(edge[0]);
        }
        vector<int> id(n, -1);
        vector<vector<int>> res;
        dfs(0, 0, -1, id, dict, res);
        return res;
    }

    int dfs(int node, int nodeId, int par, vector<int>& id, vector<vector<int>>& dict, vector<vector<int>>& res){
        id[node] = nodeId;
        for(int next:dict[node]){
            if(next == par) continue;
            else if(id[next] == -1) id[node] = min(id[node], dfs(next, nodeId+1, node, id, dict, res));
            else id[node] = min(id[next], id[node]);
        }
        if(id[node] == nodeId && node != 0) res.push_back({par, node});
        return id[node];
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m;
    cin>>n>>m;
    vector<vector<int> > edge;
    for(int i=1;i<=m;i++)
    {
        int x,y; cin>>x>>y;
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        edge.push_back(temp);
    }
    // solve
    Solution solution;
            auto result = solution.solve(n,edge);
    
    // output
    sort(result.begin(),result.end());
    for(auto it:result)
    {
        int x=it[0];
        int y=it[1];
        if(x>y) swap(x,y);
        cout<<x<<' '<<y<<' ';
    }
    return 0;
}",graph,easy
318,"# Problem Statement
Dmitry has a string $s$, consisting of lowercase Latin letters.

Dmitry decided to remove two **consecutive** characters from the string $s$ and you are wondering how many different strings can be obtained after such an operation.

For example, Dmitry has a string ""aaabcc"". You can get the following different strings: ""abcc""(by deleting the first two or second and third characters), ""aacc""(by deleting the third and fourth characters),""aaac""(by deleting the fourth and the fifth character) and ""aaab"" (by deleting the last two).

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, string &s) {
        // write your code here
    }
};
```
where:  
- return: the number of distinct strings that can be obtained by removing two consecutive letters. 

# Example 1:  
- Input:  
n = 6
s = ""aaabcc""  
- Output:  
4

# Constraints:  
- $3 \leq n \leq @data$
- $s$ consists of lowercase Latin letters
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, string &s)
    {
        int ans = n - 1;
        for (int i = 0; i + 2 < n; i++)
        {
            ans -= (s[i] == s[i + 2]);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    string s;
    cin >> s;

    // solve
    Solution solution;
    auto result = solution.solve(n, s);

    // output
    cout << result << ""\n"";

    return 0;
}","string,greedy,data_structures",hard
319,"# Problem Statement
Monocarp is working on his new site, and the current challenge is to make the users pick strong passwords.

Monocarp decided that strong passwords should satisfy the following conditions:

-   password should consist only of lowercase Latin letters and digits;
-   there should be no digit that comes after a letter (so, after each letter, there is either another letter or the string ends);
-   all digits should be sorted in the non-decreasing order;
-   all letters should be sorted in the non-decreasing order.

Note that it's allowed for the password to have only letters or only digits.

Monocarp managed to implement the first condition, but he struggles with the remaining ones. Can you help him to verify the passwords?

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, string &s) {
        // write your code here
    }
};
```
where:  
- print ""YES"" if the given password is strong and ""NO"" otherwise.

# Example 1:  
- Input:  
n = 4
s = ""12ac""
- Output:  
YES

# Constraints:  
- $1 \leq n \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(int &n, string &s)
    {
        if (is_sorted(s.begin(), s.end()))
        {
            return ""YES"";
        }
        return ""NO"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    string s;
    cin >> s;
    // solve
    Solution solution;
    auto result = solution.solve(n, s);

    // output
    cout << result << ""\n"";

    return 0;
}","sort,string",easy
320,"There are n couples sitting in 2n seats arranged in a row and want to hold hands.

The people and seats are represented by an integer array row where row[i] is the ID of the person sitting in the ith seat. The couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2n - 2, 2n - 1).

Return the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats.

solution main function
```cpp
class Solution {
public:
    int solve(int n, int m) {
        
    }
};
```

Example 1:
Input: row = [0,2,1,3]
Output: 1

Example 2:
Input: row = [3,2,0,1]
Output: 0

Constraints:

2n == row.length
2 <= n <= @data
n is even.
0 <= row[i] < 2n

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 20, 30]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class DSU
{public:
    vector<int>parent;
    DSU(int n)
    {
        parent.resize(n);
        for(int i=0;i<n;i++)
        {
            parent[i]=i;
        }
    }   
    int find(int x)
    {
        if(parent[x]!=x)
        {
            parent[x]=find(parent[x]);
        }
        return parent[x];
    }
    void unionset(int  x,int y)
    {
        int rootx=find(x);
        int rooty=find(y);
        if(rootx!=rooty)
        {
            parent[rootx]=rooty;
        }
    }
};
class Solution {
public:
Solution()
{
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
}
    int solve(vector<int>& row) {
        int n=row.size()/2;
        DSU obj(n);
        for(int i=0;i<row.size();i+=2)
        {
            int grp1=row[i]/2;
            int grp2=row[i+1]/2;
            obj.unionset(grp1,grp2);
        }
        int ans=0;
        for(int i=0;i<n;i++)
        {
            if(obj.find(i)==i)
            {
                ans++;
            }
        }
        return n-ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    cin>>n;
    vector<int> row;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        row.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(row);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    printf(""%d"",result);
    return 0;
}","graph,other",hard
321,"# Problem Statement
You are given an array of positive integers $a_1, a_2, \ldots, a_n$.

Make the product of all the numbers in the array (that is, $a_1 \cdot a_2 \cdot \ldots \cdot a_n$) divisible by $2^n$.

You can perform the following operation as many times as you like:

- select an arbitrary index $i$ ($1 \leq i \leq n$) and replace the value $a_i$ with $a_i=a_i \cdot i$.

You cannot apply the operation repeatedly to a single index. In other words, all selected values of $i$ must be different.

Find the smallest number of operations you need to perform to make the product of all the elements in the array divisible by $2^n$. Note that such a set of operations does not always exist.

The main function of the solution is defined as: 
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {   
        // write your code here
    }
};
```
Where:  
- `n` is an integer representing the size of the array.  
- `a` is a vector of integers, representing the given array.  
- The function should return an integer, representing the minimum number of operations required to make the product divisible by \(2^n\), or \(-1\) if it is not possible.

# Example 1:
- Input:  
n = 2  
a = [3, 2]
- Output:  
1

# Constraints:
- $1 \leq n \leq @data$ 
- $1 \leq a_i \leq 10^9$  
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        int cur = 0;
        for (int i = 0; i < n; i++)
        {
            int x = a[i];
            cur += __builtin_ctz(x);
        }
        int cnt[20]{};
        for (int i = 1; i <= n; i++)
            cnt[__builtin_ctz(i)]++;

        int ans = 0;
        for (int i = 19; i >= 0; i--)
        {
            while (cur < n && cnt[i])
            {
                cur += i;
                cnt[i]--;
                ans++;
            }
        }
        if (cur < n)
            ans = -1;
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","math,greedy,sort",medium
322,"# Problem Statement
Let's consider the following simple problem. You are given a string $s$ of length $n$, consisting of lowercase Latin letters, as well as an array of indices $ind$ of length $m$ ($1 \leq ind_i \leq n$) and a string $c$ of length $m$, consisting of lowercase Latin letters. Then, in order, you perform the update operations, namely, during the $i$\-th operation, you set $s_{ind_i} = c_i$. Note that you perform all $m$ operations from the first to the last.

Of course, if you change the order of indices in the array $ind$ and/or the order of letters in the string $c$, you can get different results. Find the lexicographically smallest string $s$ that can be obtained after $m$ update operations, if you can rearrange the indices in the array $ind$ and the letters in the string $c$ as you like.

A string $a$ is lexicographically less than a string $b$ if and only if one of the following conditions is met:

-   $a$ is a prefix of $b$, but $a \neq b$;
-   in the first position where $a$ and $b$ differ, the symbol in string $a$ is earlier in the alphabet than the corresponding symbol in string $b$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    void solve(int &n, int &m, string &s, vector<int> &ind, string &c, string &res) {
        // write your code here
    }
};
```
where:  
- return: the lexicographically smallest string s
 that can be obtained by rearranging the indices in the array ind and the letters in the string c as you like. The result should be stored in the variable res.

# Example 1:  
- Input:  
n = 1, m = 2
s = ""a""
ind = [1, 1]
c = ""cb""
- Output:  
res = ""b""

# Constraints:  
- $1 \leq n, m \leq @data$
- $s, c$ consists of lowercase Latin letters
- $1 \leq ind[i] \leq n$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    void solve(int &n, int &m, string &s, vector<int> &ind, string &c, string &res)
    {
        sort(ind.begin(), ind.end());
        sort(c.begin(), c.end());
        int last = 0, cnt = 0;
        for (int i = 0; i < m; i++)
        {
            if (ind[i] != last)
            {
                s[ind[i] - 1] = c[cnt++];
                last = ind[i];
            }
        }
        res = s;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, m;
    cin >> n >> m;
    string s;
    cin >> s;
    vector<int> ind(m);
    for (int i = 0; i < m; i++)
    {
        cin >> ind[i];
    }
    string c;
    cin >> c;

    // solve
    Solution solution;
    string result;
    solution.solve(n, m, s, ind, c, result);

    // output
    cout << result << ""\n"";

    return 0;
}","data_structures,greedy,sort",hard
323,"# Problem Statement
Vova really loves the [XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) operation (denoted as $\oplus$). Recently, when he was going to sleep, he came up with a fun game.

At the beginning of the game, Vova chooses two binary sequences $s$ and $t$ of length $n$ and gives them to Vanya. A binary sequence is a sequence consisting only of the numbers $0$ and $1$. Vanya can choose integers $l, r$ such that $1 \leq l \leq r \leq n$, and for all $l \leq i \leq r$ **simultaneously** replace $s_i$ with $s_i \oplus s_{i - l + 1}$, where $s_i$ is the $i$\-th element of the sequence $s$.

In order for the game to be interesting, there must be a possibility to win. Vanya wins if, with an **unlimited** number of actions, he can obtain the sequence $t$ from the sequence $s$. Determine if the game will be interesting for the sequences $s$ and $t$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, string &s, string &t) {
        // write your code here
    }
};
```
where:  
- output ""Yes"" if the game will be interesting, otherwise output ""No"".

# Example 1:  
- Input:  
n = 1, s = ""0"", t = ""1""
- Output:  
NO

# Constraints:  
- $1 \leq n \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(int &n, string &s, string &t)
    {
        for (int i = 0; i < n; i++)
        {
            if (s[i] == '0' && t[i] == '1')
                return ""NO"";
            if (s[i] == '1')
                return ""YES"";
        }
        return ""YES"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    string s, t;
    cin >> s >> t;
    // solve
    Solution solution;
    auto result = solution.solve(n, s, t);

    // output
    cout << result << ""\n"";

    return 0;
}","bit_manipulation,constructive_algorithms",hard
324,"# Problem Statement
You are playing a new famous fighting game: Kortal Mombat XII. You have to perform a brutality on your opponent's character.

You are playing the game on the new generation console so your gamepad have $26$ buttons. Each button has a single lowercase Latin letter from 'a' to 'z' written on it. All the letters on buttons are pairwise distinct.

You are given a sequence of hits, the $i$\-th hit deals $a_i$ units of damage to the opponent's character. To perform the $i$\-th hit you have to press the button $s_i$ on your gamepad. Hits are numbered from $1$ to $n$.

You know that if you press some button **more than** $k$ times **in a row** then it'll break. You cherish your gamepad and don't want to break any of its buttons.

To perform a brutality you have to land some of the hits of the given sequence. **You are allowed to skip any of them, however changing the initial order of the sequence is prohibited**. The total damage dealt is the sum of $a_i$ over all $i$ for the hits which weren't skipped.

**Note that if you skip the hit then the counter of consecutive presses the button won't reset**.

Your task is to skip some hits to deal the **maximum** possible total damage to the opponent's character and not break your gamepad buttons.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, int &k, vector<int> &a, string &s) {
        // write your code here
    }
};
```
where:  
- return: he maximum possible damage to the opponent's character you can deal without breaking your gamepad buttons.

# Example 1:  
- Input:  
n = 7, k = 3
a = [1, 5, 16, 18, 7, 2, 10]
s = ""baaaaca""
- Output:  
54

# Constraints:  
- $1 \leq k \leq n \leq @data$
- $1 \leq a[i] \leq 10^9$
- $s[i]$ is a lowercase Latin letter
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(int &n, int &k, vector<int> &a, string &s)
    {
        long long ans = 0;
        int start = 0;
        for (int i = 1; i <= n; i++)
        {
            if (i == n || s[i] != s[i - 1])
            {
                if (i - start > k)
                    sort(a.begin() + start, a.begin() + i);
                for (int j = 0; j < k && i - j - 1 >= start; j++)
                    ans += a[i - j - 1];
                start = i;
            }
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, k;
    cin >> n >> k;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];
    string s;
    cin >> s;

    // solve
    Solution solution;
    auto result = solution.solve(n, k, a, s);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,sort,two_pointers",hard
325,"# Problem Statement
Alice and Bob are playing a game. They have a permutation $p$ of size $n$ (a permutation of size $n$ is an array of size $n$ where each element from $1$ to $n$ occurs exactly once). They also have a chip, which can be placed on any element of the permutation.

Alice and Bob make alternating moves: Alice makes the first move, then Bob makes the second move, then Alice makes the third move, and so on. During the first move, Alice chooses any element of the permutation and places the chip on that element. During each of the next moves, the current player **has to** move the chip to any element that is simultaneously to the left and strictly less than the current element (i.e. if the chip is on the $i$\-th element, it can be moved to the $j$\-th element if $j &lt; i$ and $p_j &lt; p_i$). If a player cannot make a move (it is impossible to move the chip according to the rules of the game), that player **wins** the game.

Let's say that the $i$\-th element of the permutation is **lucky** if the following condition holds:

-   if Alice places the chip on the $i$\-th element during her first move, she can win the game no matter how Bob plays (i.e. she has a winning strategy).

You have to calculate the number of lucky elements in the permutation.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &p) {
        // write your code here
    }
};
```
where:  
- return: the number of lucky elements in the permutation.

# Example 1:  
- Input:  
n = 3
p = [2, 1, 3]
- Output:  
1


# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq p[i] \leq n$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &p)
    {
        for (int i = 0; i < n; i++)
            p[i]--;
        int minlose = n;
        int mn = n;
        int ans = 0;
        for (int i = 0; i < n; i++)
        {
            int win = 0;
            if (p[i] < mn)
            {
                mn = p[i];
                win = 1;
            }
            else
            {
                win = (minlose < p[i]);
            }
            if (!win)
            {
                ans += 1;
                minlose = min(minlose, p[i]);
            }
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","dp,greedy",hard
326,"Given an integer array nums, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.

solution main function
```cpp
class Solution {
public:
    vector<vector<int>> solve(vector<int>& nums) {

    }
};
```

Example 1:
Input: nums = [4,6,7,7]
Output: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]

Example 2:
Input: nums = [4,4,3,2,1]
Output: [[4,4]]

Constraints:
1 <= nums.length <= @data
-100 <= nums[i] <= 100
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[5, 10, 15]",1000.0,"[[12800, 1280, 128]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> temp; 
    vector<vector<int>> ans;

    void dfs(int cur, int last, vector<int>& nums) {
        if (cur == nums.size()) {
            if (temp.size() >= 2) {
                ans.push_back(temp);
            }
            return;
        }
        if (nums[cur] >= last) {
            temp.push_back(nums[cur]);
            dfs(cur + 1, nums[cur], nums);
            temp.pop_back();
        }
        if (nums[cur] != last) {
            dfs(cur + 1, last, nums);
        }
    }

    vector<vector<int>> solve(vector<int>& nums) {
        dfs(0, INT_MIN, nums);
        return ans;
    }
};","#include <bits/stdc++.h>
#include <iterator>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> num;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
            auto result = solution.solve(num);
    
    // output
    sort(result.begin(),result.end());
    for(auto it:result)
    {
        for(auto t:it)
            cout<<t<<' ';
        cout<<endl;
    }
    return 0;
}",bit_manipulation,medium
327,"A teacher of abacus arithmetic in a certain school used a test method to quickly test the ability of abacus arithmetic addition. He randomly generated a set of positive integers, each with different numbers, and asked the students to answer: How many of these numbers are exactly equal to the sum of two other (different) numbers in the set?
Recently the teacher gave some test questions, please help to find out the answers.

solution main function
```cpp
class Solution
{
    public:
    int solve(int n, vector<int> &num)
}
```

Pass in parameters:
1 integer, n.
An array with num containing n positive integers.

Return parameters:
An integer representing the answer to the quiz question

Example 1:
Input: n=4,num=[1, 2, 3, 4]
Output: 2

Constraints:
3n@data, 1num[i] 10000
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 20, 100]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution
{
public:
    int solve(int n, vector<int> &num)
    {
        num.insert(num.begin(), 0);
        int m = 0;
        sort(num.begin() + 1, num.begin() + n + 1);
        for (int i = 3; i <= n; i++)
        {
            for (int j = 1; j < i - 1; j++)
            {
                for (int k = j + 1; k < i; k++)
                {
                    if (num[j] + num[k] == num[i])
                    {
                        m++;
                        goto skip;
                    }
                }
            }
        skip:;
        }
        return m;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    cin>>n;
    vector<int> num;
    for(int i=1,x;i<=n;i++)
    {
        cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
            auto result = solution.solve(n,num);
    
    // output
    cout << result << ""\n"";

    return 0;
}",greedy,medium
328,"Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 <= i <= j < n.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& nums) {

    }
};
```

Example 1:
Input: nums = [3,10,5,25,2,8]
Output: 28

Example 2:
Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70]
Output: 127

Constraints:
1 <= nums.length <= @data
0 <= nums[i] <= 2^31 - 1
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[12800, 2560, 1280]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums) {
        int n=nums.size(),maxv=*max_element(nums.begin(),nums.end());
        if(maxv==0)
        return 0;
        int high=31-__builtin_clz(maxv);
        int ans=0,mask=0;
        unordered_set<int>seen;
        for(int i=high;i>=0;i--){
            seen.clear();
            mask|=1<<i;
            int tmp=ans|(1<<i);
            for(int x:nums){
                x&=mask;
                if(seen.find(tmp^x)!=seen.end()){
                    ans=tmp;
                    break;
                }
                seen.insert(x);
            }
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> num;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
            int result = solution.solve(num);
    
    // output
    cout<<result;
    return 0;
}","STL,bit_manipulation",medium
329,"# Problem Statement

You have an array of integers $a$ of length $n$. You can apply the following operation to the given array:

-   Swap two elements $a_i$ and $a_j$ such that $i \neq j$, $a_i$ and $a_j$ are either **both** even or **both** odd.

Determine whether it is possible to sort the array in non-decreasing order by performing the operation any number of times (possibly zero).

For example, let $a$ = \[$7, 10, 1, 3, 2$\]. Then we can perform $3$ operations to sort the array:

1.  Swap $a_3 = 1$ and $a_1 = 7$, since $1$ and $7$ are odd. We get $a$ = \[$1, 10, 7, 3, 2$\];
2.  Swap $a_2 = 10$ and $a_5 = 2$, since $10$ and $2$ are even. We get $a$ = \[$1, 2, 7, 3, 10$\];
3.  Swap $a_4 = 3$ and $a_3 = 7$, since $3$ and $7$ are odd. We get $a$ = \[$1, 2, 3, 7, 10$\].

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, vector<int> &a) {   
        // write your code here
    }
};
```
where:  
- Return value: Returns ""YES"" or ""NO"", indicating whether the array can be sorted in non-decreasing order.

# Example 1:  
- Input:  
n = 5
a = [6, 6, 4, 1, 6]
- Output:  
""NO""

# Constraints:  
- $1 \leq n \leq @data$  
- $1 \leq a[i] \leq 10^9$  
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 3200, 640]]","class Solution
{
public:
    string solve(int &n, vector<int> &a)
    {
        auto b = a;
        sort(b.begin(), b.end());
        for (int i = 0; i < n; i++)
        {
            if ((a[i] - b[i]) % 2)
                return ""NO"";
        }
        return ""YES"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,two_pointers,sort",easy
330,"# Problem Statement
Alice got a permutation $a_1, a_2, \ldots, a_n$ of $[1,2,\ldots,n]$, and Bob got another permutation $b_1, b_2, \ldots, b_n$ of $[1,2,\ldots,n]$. They are going to play a game with these arrays.

In each turn, the following events happen in order:

-   Alice chooses either the first or the last element of her array and removes it from the array;
-   Bob chooses either the first or the last element of his array and removes it from the array.

The game continues for $n-1$ turns, after which both arrays will have exactly one remaining element: $x$ in the array $a$ and $y$ in the array $b$.

If $x=y$, Bob wins; otherwise, Alice wins. Find which player will win if both players play optimally.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, vector<int> &a, vector<int> &b) {
        // write your code here
    }
};
```
where:  
- If Alice wins, print Alice; otherwise, print Bob.

# Example 1:  
- Input:  
n = 2
a = [1, 2]
b = [1, 2]
- Output:  
Bob

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i], b[i] \leq n$
- a[i]
- b[i]
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(int &n, vector<int> &a, vector<int> &b)
    {
        if (a == b)
            return ""Bob"";
        reverse(b.rbegin(), b.rend());
        if (a == b)
            return ""Bob"";
        return ""Alice"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];
    vector<int> b(n);
    for (int i = 0; i < n; i++)
        cin >> b[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a, b);

    // output
    cout << result << ""\n"";

    return 0;
}",game,hard
331,"Given a 0-indexed integer array nums, return the number of distinct quadruplets (a, b, c, d) such that:

    nums[a] + nums[b] + nums[c] == nums[d], and
    a < b < c < d

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& nums) {
        
    }
};
```

Example 1:
Input: nums = [1,2,3,6]
Output: 1

Example 2:
Input: nums = [3,3,6,4,5]
Output: 0

Constraints:

4 <= nums.length <= @data
1 <= nums[i] <= 100

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[30, 40, 50]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums) {

       int cnt=0;
       int n=nums.size();
       for(int i=0;i<n-3;i++){
        for(int j=i+1;j<n-2;j++){
            for(int k=j+1;k<n-1;k++){
                for(int l=k+1;l<n;l++){
                if(nums[i]+nums[j]+nums[k]==nums[l]){
                cnt++;
                }
                }
            }

        }
       }

       return cnt;
        
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",other,easy
332,"# Problem Statement
 You are given a sequence of $n$ non-negative integers $a_1, a_2, \ldots, a_n$. Initially, all the elements of the sequence are unpainted. You can paint each number $\RED$ or $\BLUE$ (but not both), or **leave it unpainted**.

For a color $c$, $\text{Count}(c)$ is the number of elements in the sequence painted with that color and $\text{Sum}(c)$ is the sum of the elements in the sequence painted with that color.

For example, if the given sequence is $[2, 8, 6, 3, 1]$ and it is painted this way: $[\myblue{2}, 8, \myred{6}, \myblue{3}, 1]$ (where $6$ is painted red, $2$ and $3$ are painted blue, $1$ and $8$ are unpainted) then $\text{Sum}(\RED)=6$, $\text{Sum}(\BLUE)=2+3=5$, $\text{Count}(\RED)=1$, and $\text{Count}(\BLUE)=2$.

Determine if it is possible to paint the sequence so that $\text{Sum}(\RED) &gt; \text{Sum}(\BLUE)$ and $\text{Count}(\RED) &lt; \text{Count}(\BLUE)$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- print YES if it is possible to paint the given sequence satisfying the above requirements, and NO otherwise.

# Example 1:  
- Input:  
n = 3
a = [1, 2, 3]
- Output:  
NO

# Constraints:  
- $3 \leq n \leq @data$
- $0 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(int &n, vector<int> &a)
    {
        sort(a.begin(), a.end());
        long long i = 1, j = 0, sumi = a[0], sumj = 0, flag = 0;
        while (i + j <= n)
        {
            sumi += a[++i - 1];
            sumj += a[n - (++j)];
            if (sumj > sumi && i + j <= n)
            {
                flag = 1;
                break;
            }
        }
        if (flag)
            return ""YES"";
        else
            return ""NO"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,sort,two_pointers",hard
333,"You are given a string s. Reorder the string using the following algorithm:

    Remove the smallest character from s and append it to the result.
    Remove the smallest character from s that is greater than the last appended character, and append it to the result.
    Repeat step 2 until no more characters can be removed.
    Remove the largest character from s and append it to the result.
    Remove the largest character from s that is smaller than the last appended character, and append it to the result.
    Repeat step 5 until no more characters can be removed.
    Repeat steps 1 through 6 until all characters from s have been removed.

If the smallest or largest character appears more than once, you may choose any occurrence to append to the result.

Return the resulting string after reordering s using this algorithm.

solution main function
```cpp
class Solution {
public:
    string solve(string s) {
        
    }
};
```

Example 1:
Input: s = ""aaaabbbbcccc""
Output: ""abccbaabccba""

Example 2:
Input: s = ""rat""
Output: ""art""

Constraints:


1 <= s.length <= @data
s consists of only lowercase English letters.


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 500, 1000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    string solve(string s) {
        int cnt[26]{};
        for (char& c : s) {
            ++cnt[c - 'a'];
        }
        string ans;
        while (ans.size() < s.size()) {
            for (int i = 0; i < 26; ++i) {
                if (cnt[i]) {
                    ans += i + 'a';
                    --cnt[i];
                }
            }
            for (int i = 25; i >= 0; --i) {
                if (cnt[i]) {
                    ans += i + 'a';
                    --cnt[i];
                }
            }
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string s; cin>>s;
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","string,other",easy
334,"# Problem Statement
In his dream, Cocoly would go on a long holiday with no worries around him. So he would try out for many new things, such as... being a carpenter. To learn it well, Cocoly decides to become an apprentice of Master, but in front of him lies a hard task waiting for him to solve.

Cocoly is given an array $a_1, a_2,\ldots, a_n$. Master calls a set of integers $S$ stable if and only if, for any possible $u$, $v$, and $w$ from the set $S$ (note that $u$, $v$, and $w$ do not necessarily have to be pairwise distinct), sticks of length $u$, $v$, and $w$ can form a non-degenerate triangle$^{\text{}}$.

Cocoly is asked to partition the array $a$ into several (possibly, $1$ or $n$) **non-empty** continuous subsegments$^{\text{}}$, such that: for each of the subsegments, the set containing all the elements in it is stable.

Master wants Cocoly to partition $a$ in **at least two** different$^{\text{}}$ ways. You have to help him determine whether it is possible.

$^{\text{}}$A triangle with side lengths $x$, $y$, and $z$ is called non-degenerate if and only if:

-   $x + y &gt; z$,
-   $y + z &gt; x$, and
-   $z + x &gt; y$.

$^{\text{}}$A sequence $b$ is a subsegment of a sequence $c$ if $b$ can be obtained from $c$ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

$^{\text{}}$Two partitions are considered different if and only if at least one of the following holds:

-   the numbers of continuous subsegments split in two partitions are different;
-   there is an integer $k$ such that the lengths of the $k$\-th subsegment in two partitions are different.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    string solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- print YES if there are at least two ways to partition a, and NO otherwise.

# Example 1:  
- Input:  
n = 4
a = [2, 3, 5, 7]
- Output:  
YES

# Constraints:  
- $2 \leq n \leq @data$
- $1 \leq a[i] \leq 10^5$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(int &n, vector<int> &a)
    {
        for (int i = 1; i < n; i++)
        {
            int x = a[i - 1];
            int y = a[i];
            if (x > y)
            {
                swap(x, y);
            }
            if (2 * x > y)
            {
                return ""YES"";
            }
        }
        return ""NO"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","dp,greedy,math",hard
335,"# Problem Statement
Given $N$, $V$, an array $v$ of length $N$ representing the volume of items, and an array $w$ of length $N$ representing the value of items:  
There are $N$ items and a backpack with a capacity of $V$. Each item can only be used once.  
The $i$-th item has a volume of $v[i]$ and a value of $w[i]$.  

Determine which items to put in the backpack such that the **total volume does not exceed the backpack's capacity** and the **total value is maximized**. Return the maximum total value.

The solution's main function is:  
```cpp
class Solution {
public:
    int solve(int &N, int &V, vector<int> &v, vector<int> &w) {   
        // write your code here
    }
};
```
where:  
- `N` is the number of items,  
- `V` is the capacity of the backpack,  
- `v` is the array of item volumes,  
- `w` is the array of item values.  

# Example 1  
- Input:  
N = 3  
V = 4  
v = [4, 3, 1]  
w = [1, 2, 1]  
- Output:  
2

# Constraints:  
- $1 \leq N, V, v[i], w[i] \leq @data$  
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 10000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &N, int &V, vector<int> &v, vector<int> &w)
    {
        vector<int>dp(V+1);
        for(int i=0;i<N;i++)
            for(int j=V;j>=v[i];j--)
                dp[j]=max(dp[j],dp[j-v[i]]+w[i]);
        return dp[V];
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int N, V;
    cin >> N >> V;
    vector<int> v, w;
    for (int i = 0; i < N; i++)
    {
        int x;
        cin >> x;
        v.push_back(x);
    }
    for (int i = 0; i < N; i++)
    {
        int x;
        cin >> x;
        w.push_back(x);
    }

    // solve
    Solution solution;
    auto result = solution.solve(N, V, v, w);

    // output
    cout << result << ""\n"";

    return 0;
}",dp,easy
336,"You have a certain number of processors, each having 4 cores. The number of tasks to be executed is four times the number of processors. Each task must be assigned to a unique core, and each core can only be used once.

You are given an array processorTime representing the time each processor becomes available and an array tasks representing how long each task takes to complete. Return the minimum time needed to complete all tasks.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& processorTime, vector<int>& tasks) {
        
    }
};
```

Example 1:
Input: processorTime = [8,10], tasks = [2,2,3,1,8,7,4,5]
Output: 16

Example 2:
Input: processorTime = [10,20], tasks = [2,3,1,2,5,8,4,3]
Output: 23

Constraints:


1 <= n == processorTime.length <= @data
0 <= processorTime[i] <= 10^9
1 <= tasks[i] <= 10^9
tasks.length == 4 * n


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& t, vector<int>& v) {
        int n=v.size();
        sort(t.begin(),t.end());
        sort(v.begin(),v.end());
        int j=n-1;
        int m=t.size();
        int ans=0;
        for(int i=0;i<m;i++)
        {
            int c=0;
            while(c<4)
            {
                ans=max(ans,t[i]+v[j]);
                c++;
                j--;
            }
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<int> a,b;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        a.push_back(x);
    }
    for(int i=1;i<=4*n;i++)
    {
        int x; cin>>x;
        b.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(a,b);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","greedy,sort",medium
337,"# Problem Statement
Dima Vatrushin is a math teacher at school. He was sent on vacation for $n$ days for his good work. Dima has long dreamed of going to a ski resort, so he wants to allocate several **consecutive days** and go skiing. Since the vacation requires careful preparation, he will only go for **at least $k$ days**.

You are given an array $a$ containing the weather forecast at the resort. That is, on the $i$\-th day, the temperature will be $a_i$ degrees.

Dima was born in Siberia, so he can go on vacation only if the temperature does not rise above $q$ degrees throughout the vacation.

Unfortunately, Dima was so absorbed in abstract algebra that he forgot how to count. He asks you to help him and count the number of ways to choose vacation dates at the resort.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, int &k, int &q, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the number of ways for Dima to choose vacation dates at the resort, please use `long long` type.

# Example 1:  
- Input:  
n = 3, k = 1, q = 15
a = [-5, 0, -10]
- Output:  
6

# Constraints:  
- $1 \leq k \leq n \leq @data$
- $-10^9 \leq a[i], q \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(int &n, int &k, int &q, vector<int> &a)
    {
        long long ans = 0;
        int suf = 0;
        for (auto x : a)
        {
            suf = x <= q ? suf + 1 : 0;
            ans += max(0, suf - k + 1);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, k, q;
    cin >> n >> k >> q;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, k, q, a);

    // output
    cout << result << ""\n"";

    return 0;
}","math,two_pointers",medium
338,"You are given a string s. The score of a string is defined as the sum of the absolute difference between the ASCII values of adjacent characters.

Return the score of s.

solution main function
```cpp
class Solution {
public:
    int solve(string s) {
        
    }
};
```

Example 1:
Input: s = ""hello""
Output: 13

Example 2:
Input: s = ""zaz""
Output: 50

Constraints:

2 <= s.length <= @data
s consists only of lowercase English letters.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(string s) {
        int score = 0;
        // Iterate over all indices from 0 to the second-to-last index
        // Calculate and accumulate the absolute difference of ASCII values
        // between adjacent characters
        for (int i = 0; i < s.size() - 1; ++i) {
            score += abs(s[i] - s[i + 1]);
        }
        return score;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string s; cin>>s;
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    printf(""%d"",result);
    return 0;
}",string,easy
339,"You are given a string s of length n and an integer k, where n is a multiple of k. Your task is to hash the string s into a new string called result, which has a length of n / k.

First, divide s into n / k
substrings
, each with a length of k. Then, initialize result as an empty string.

For each substring in order from the beginning:

    The hash value of a character is the index of that character in the English alphabet (e.g., 'a'  0, 'b'  1, ..., 'z'  25).
    Calculate the sum of all the hash values of the characters in the substring.
    Find the remainder of this sum when divided by 26, which is called hashedChar.
    Identify the character in the English lowercase alphabet that corresponds to hashedChar.
    Append that character to the end of result.

Return result.

solution main function
```cpp
class Solution {
public:
    string solve(string s, int k) {
        
    }
};
```

Example 1:
Input: s = ""abcd"", k = 2
Output: ""bf""

Example 2:
Input: s = ""mxz"", k = 3
Output: ""i""

Constraints:

1 <= k <= 100
k <= s.length <= @data
s.length is divisible by k.
s consists only of lowercase English letter

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    string solve(string s, int k) {
        string ans="""";
        int cou=0;
        for(int i=0;i<s.size();i++){
            cou+=s[i]-97;
            if((i+1)%k==0) {
                ans.push_back(cou%26+97);
                cou=0;
            }
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    string s;
    cin>>n>>s;
    // solve
    Solution solution;
    auto result = solution.solve(s,n);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","string,other",medium
340,"# Problem Statement
There is a chessboard of size $n$ by $n$. The square in the $i$\-th row from top and $j$\-th column from the left is labelled $(i,j)$.

Currently, Gregor has some pawns in the $n$\-th row. There are also enemy pawns in the $1$\-st row. On one turn, Gregor moves one of **his** pawns. A pawn can move one square up (from $(i,j)$ to $(i-1,j)$) if there is no pawn in the destination square. Additionally, a pawn can move one square diagonally up (from $(i,j)$ to either $(i-1,j-1)$ or $(i-1,j+1)$) if and only if there is an enemy pawn in that square. The enemy pawn is also removed.

Gregor wants to know what is the maximum number of his pawns that can reach row $1$?

Note that only Gregor takes turns in this game, and **the enemy pawns never move**. Also, when Gregor's pawn reaches row $1$, it is stuck and cannot make any further moves.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, string &a, string &b) {
        // write your code here
    }
};
```
where:  
- `n`: the size of the chessboard
- `a` consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to an enemy's pawn in the i-th cell from the left, and 0 corresponds to an empty cell.
- `b` consists of a string of binary digits of length n, where a 1 in the i-th position corresponds to a Gregor's pawn in the i-th cell from the left, and 0 corresponds to an empty cell.
- return: the maximum number of Gregor's pawns which can reach the 1-st row.

# Example 1:  
- Input: 
n = 3
a = ""000""
b = ""111""
- Output:  
3

# Constraints:  
- $2 \leq n \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, string &a, string &b)
    {
        int la = '0', lb = '0', ans = 0;
        for (int i = 0; i < n; ++i)
        {
            if (b[i] == '1' && (lb == '1' || a[i] == '0'))
            {
                ++ans;
                lb = b[i] = '0';
            }
            if (a[i] == '1' && la == '1')
            {
                ++ans;
                la = a[i] = '0';
            }
            la = b[i];
            lb = a[i];
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    string a, b;
    cin >> a >> b;

    // solve
    Solution solution;
    auto result = solution.solve(n, a, b);

    // output
    cout << result << ""\n"";

    return 0;
}","search,dp,graph",easy
341,"Given an integer n, return the least number of perfect square numbers that sum to n.
A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.

solution main function
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

Example 1:
Input: n = 12
Output: 3

Example 2:
Input: n = 13
Output: 2

Constraints:
1 <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 1000000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    bool isPerfectSquare(int x) {
        int y = sqrt(x);
        return y * y == x;
    }

    bool checkAnswer4(int x) {
        while (x % 4 == 0) {
            x /= 4;
        }
        return x % 8 == 7;
    }

    int solve(int n) {
        if (isPerfectSquare(n)) {
            return 1;
        }
        if (checkAnswer4(n)) {
            return 4;
        }
        for (int i = 1; i * i <= n; i++) {
            int j = n - i * i;
            if (isPerfectSquare(j)) {
                return 2;
            }
        }
        return 3;
    }
};","#include <bits/stdc++.h>
#include <iterator>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
            auto result = solution.solve(n);
    
    // output
    cout<<result;
    return 0;
}",math,medium
342,"You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].
The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.
Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.

solution main function
```cpp
class Solution
{
    public:
    int solve(vector<vector<int>>& points)
}
```

Example 1:
Inputpoints = [[0,0],[2,2],[3,10],[5,2],[7,0]]
Output: 20

Example 2:
Inputpoints = [[3,12],[-2,5],[-4,1]]
Output: 18

Constraints:
1 <= points.length <= @data
-10^6 <= xi, yi <= 10^6
All pairs (xi, yi) are distinct.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 100, 1000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<vector<int>>& points) {
        int n = points.size();
        vector<bool> visited(n, false); // To track visited nodes
        vector<int> minDist(n, INT_MAX); // Min distance to the MST for each node

        minDist[0] = 0; // Start with the first point
        int result = 0; // Total cost

        for (int i = 0; i < n; ++i) {
            int minCost = INT_MAX;
            int currentNode = -1;

            // Find the next node with the minimum cost to add to the MST
            for (int j = 0; j < n; ++j) {
                if (!visited[j] && minDist[j] < minCost) {
                    minCost = minDist[j];
                    currentNode = j;
                }
            }

            // Add the selected node to the MST
            visited[currentNode] = true;
            result += minCost;

            // Update the minimum distances for the remaining nodes
            for (int j = 0; j < n; ++j) {
                if (!visited[j]) {
                    int dist = abs(points[currentNode][0] - points[j][0]) +
                               abs(points[currentNode][1] - points[j][1]);
                    minDist[j] = min(minDist[j], dist);
                }
            }
        }

        return result;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    cin>>n;
    vector<vector<int> > g;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        int x,y; cin>>x>>y;
        temp.push_back(x);
        temp.push_back(y);
        g.push_back(temp);
    }
    // solve
    Solution solution;
            auto result = solution.solve(g);
    
    // output
    cout<<result;
    return 0;
}","graph,tree,search",medium
343,"# Problem Statement
You are given an $n \times m$ grid $a$ of non-negative integers. The value $a_{i,j}$ represents the depth of water at the $i$\-th row and $j$\-th column.

A lake is a set of cells such that:

-   each cell in the set has $a_{i,j} > 0$, and
-   there exists a path between any pair of cells in the lake by going up, down, left, or right a number of times and without stepping on a cell with $a_{i,j} = 0$.

The volume of a lake is the sum of depths of all the cells in the lake.

Find the largest volume of a lake in the grid.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &m, vector<vector<int>> &a) {   
        // write your code here
    }
};
```
where:  
- return value is the largest volume of a lake

# Example 1:  
- Input:  
n = 3, m = 3
a = [
  [1, 2, 0],
  [3, 4, 0],
  [0, 0, 5]
]
- Output:  
10 

# Constraints:  
- $1 \leq n * m \leq @data$  
- $0 \leq a[i] \leq 10^3$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[100, 10000, 1000000]",1000.0,"[[14400, 12800, 9600]]","class Solution
{
public:
    int solve(int &n, int &m, vector<vector<int>> &a)
    {
        int dx[] = {-1, 1, 0, 0};
        int dy[] = {0, 0, -1, 1};
        int ans = 0;
        vector<vector<bool>> vis(n, vector<bool>(m, false));
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < m; j++)
            {
                if (!vis[i][j] && a[i][j] > 0)
                {
                    int res = 0;
                    queue<pair<int, int>> q;
                    q.push({i, j});
                    vis[i][j] = true;
                    while (!q.empty())
                    {
                        auto [x, y] = q.front();
                        q.pop();
                        res += a[x][y];
                        for (int k = 0; k < 4; k++)
                        {
                            int nx = x + dx[k];
                            int ny = y + dy[k];
                            if (0 <= nx && nx < n && 0 <= ny && ny < m && a[nx][ny] > 0 && !vis[nx][ny])
                            {
                                q.push({nx, ny});
                                vis[nx][ny] = true;
                            }
                        }
                    }
                    ans = max(ans, res);
                }
            }
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, m;
    cin >> n >> m;
    vector<vector<int>> a(n, vector<int>(m));
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cin >> a[i][j];

    // solve
    Solution solution;
    auto result = solution.solve(n, m, a);

    // output
    cout << result << ""\n"";

    return 0;
}","graph,search,data_structures",easy
344,"There is a restaurant with a single chef. You are given an array customers, where customers[i] = [arrivali, timei]:

    arrivali is the arrival time of the ith customer. The arrival times are sorted in non-decreasing order.
    timei is the time needed to prepare the order of the ith customer.

When a customer arrives, he gives the chef his order, and the chef starts preparing it once he is idle. The customer waits till the chef finishes preparing his order. The chef does not prepare food for more than one customer at a time. The chef prepares food for customers in the order they were given in the input.

Return the average waiting time of all customers. Solutions within 10-5 from the actual answer are considered accepted

solution main function

```cpp
class Solution {
public:
    double solve(vector<vector<int>>& customers) {
        
    }
};
```

Example 1:
Input: customers = [[1,2],[2,5],[4,3]]
Output: 5.00000

Example 2:
Input: customers = [[5,2],[5,4],[10,3],[20,1]]
Output: 3.25000

Constraints:

1 <= customers.length <= @data
1 <= arrivali, timei <= 10^4
arrivali <= arrivali+1

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    double solve(vector<vector<int>>& customers) {
        int nextIdleTime = 0;
        long long netWaitTime = 0;

        for (int i = 0; i < customers.size(); i++) {
            // The next idle time for the chef is given by the time of delivery
            // of current customer's order.
            nextIdleTime = max(customers[i][0], nextIdleTime) + customers[i][1];

            // The wait time for the current customer is the difference between
            // his delivery time and arrival time.
            netWaitTime += nextIdleTime - customers[i][0];
        }

        // Divide by total customers to get average.
        double averageWaitTime =
            static_cast<double>(netWaitTime) / customers.size();
        return averageWaitTime;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector<vector<int> > s;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        int x,y; cin>>x>>y;
        temp.push_back(x);
        temp.push_back(y);
        s.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    // output
    printf(""%.4lf"",result);
    // cout << result << ""\n"";
    // for(auto it:result) cout<<it<<' ';
    return 0;
}",greedy,medium
345,"Given a graph with n vertices (numbered 1 to n) and m undirected edges with non-negative weights, please calculate the distance from vertex s to each vertex. 
The data guarantees that you can reach any point starting from s. 
The `edges` array represents the edges in the graph. `edges[i] = [a, b, c]` indicates that there is an undirected edge with a weight of `c` between node `a` and node `b`.

solution main function
```cpp
class Solution
{
    public:
    vector<int> solve(int n,int s, vector<vector<int>>& edges)
    {

    }
}
```

Example 1:
Inputn = 4, s = 1, edges = [[1,2,2],[2,3,2],[2,4,1],[1,3,5],[3,4,3],[1,4,4]]
Output: [0,2,4,3]

Constraints:

2 <= n <= @data
edges.size <=5*@data
edges[i].size ==3

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution
{
    public:
    vector<int> solve(int n,int s, vector<vector<int>>& edges)
    {
        const int INF=1e8;
        priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q; 
        vector<vector<pair<int,int> > > v;
        vector<int> dis,vis;
        v.resize(n+10);
        dis.resize(n+10,INF);
        vis.resize(n+10,false);
        dis[s]=0; q.push(make_pair(0,s));
        for(auto it:edges)
        {
            int x=it[0],y=it[1],t=it[2];
            v[x].push_back(make_pair(y,t));
            v[y].push_back(make_pair(x,t));
        }
        while(!q.empty())
        {
            pair<int,int> s=q.top();
            int x=s.second; q.pop();
            if(vis[x]) continue;
            vis[x]=true; 
            for(int i=0;i<v[x].size();i++)
            {
                if(dis[v[x][i].first]>dis[x]+v[x][i].second)
                {
                    dis[v[x][i].first]=dis[x]+v[x][i].second;
                    q.push(make_pair(dis[v[x][i].first],v[x][i].first));
                }
            }
        }
        vector<int> ans;
        for(int i=1;i<=n;i++)
            ans.push_back(dis[i]);
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m,s; cin>>n>>m>>s;
    vector< vector<int> > edges;
    for(int i=1,x,y,z;i<=m;i++)
    {
        cin>>x>>y>>z;
        vector<int> temp;
        temp.push_back(x);
        temp.push_back(y);
        temp.push_back(z);
        edges.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(n,s,edges);
    
    // output
    for(int i=0;i<n;i++) cout<<result[i]<<' ';
    // cout << result << ""\n"";

    return 0;
}",graph,medium
346,"# Problem Statement
Rudolf and Bernard decided to play a game with their friends. $n$ people stand in a circle and start throwing a ball to each other. They are numbered from $1$ to $n$ in the clockwise order.

Let's call a transition a movement of the ball from one player to his neighbor. The transition can be made clockwise or counterclockwise.

Let's call the clockwise (counterclockwise) distance from player $y_1$ to player $y_2$ the number of transitions clockwise (counterclockwise) that need to be made to move from player $y_1$ to player $y_2$. For example, if $n=7$ then the clockwise distance from $2$ to $5$ is $3$, and the counterclockwise distance from $2$ to $5$ is $4$.

Initially, the ball is with the player number $x$ (players are numbered clockwise). On the $i$\-th move the person with the ball throws it at a distance of $r_i$ ($1 \le r_i \le n - 1$) clockwise or counterclockwise. For example, if there are $7$ players, and the $2$nd player, after receiving the ball, throws it a distance of $5$, then the ball will be caught by either the $7$th player (throwing clockwise) or the $4$th player (throwing counterclockwise). 

The game was interrupted after $m$ throws due to unexpected rain. When the rain stopped, the guys gathered again to continue. However, no one could remember who had the ball. As it turned out, Bernard remembered the distances for each of the throws and the direction for **some** of the throws (clockwise or counterclockwise).

Rudolf asks you to help him and based on the information from Bernard, calculate the numbers of the players who could have the ball after $m$ throws.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &m, int &x, vector<pair<int, char>> &a) {   
        // write your code here
    }
};
```
where:  
- `n`: the number of players, `m`: the number of throws, `x`: the initial player with the ball
- `a`: the distance and direction of each throw, `a[i].first` represents the distance of the $i$-th throw, `a[i].second` represents the direction of the $i$-th throw, `a[i].second` is '0' for clockwise, '1' for counterclockwise, '?' for unknown
- return: the number of players who could have the ball

# Example 1:  
- Input:  
n = 6, m = 3, x = 2
a = [(2,'?'), (2,'?'), (2,'?')]
- Output:  
3

# Constraints:  
- $2 \leq n \leq @data$
- $1 \leq m \leq @data$
- $1 \leq x \leq n$
- $1 \leq a[i].first \leq n - 1$
- $a[i].second is '0' or '1' or '?'$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 5000]",1000.0,"[[6400, 640, 256]]","class Solution
{
public:
    int solve(int &n, int &m, int &x, vector<pair<int, char>> &a)
    {
        vector<int> dp(n);
        x--;
        dp[x] = 1;
        for (int i = 0; i < m; i++)
        {
            auto [r, c] = a[i];
            vector<int> g(n);
            for (int j = 0; j < n; j++)
            {
                if (dp[j])
                {
                    if (c != '1')
                        g[(j + r) % n] = 1;
                    if (c != '0')
                        g[(j - r + n) % n] = 1;
                }
            }
            dp = g;
        }
        return count(dp.begin(), dp.end(), 1);
    }
};



","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, m, x;
    cin >> n >> m >> x;
    vector<pair<int, char>> a(m);
    for (int i = 0; i < m; i++)
        cin >> a[i].first >> a[i].second;

    // solve
    Solution solution;
    auto result = solution.solve(n, m, x, a);

    // output
    cout << result << ""\n"";

    return 0;
}","dp,search",medium
347,"You have a pointer at index 0 in an array of size arrLen. At each step, you can move 1 position to the left, 1 position to the right in the array, or stay in the same place (The pointer should not be placed outside the array at any time).

Given two integers steps and arrLen, return the number of ways such that your pointer is still at index 0 after exactly steps steps. Since the answer may be too large, return it modulo 10^9 + 7.

solution main function

```cpp
class Solution {
public:
    int solve(int steps, int arrLen) {
        
    }
};
```

Example 1:
Input: steps = 3, arrLen = 2
Output: 4

Example 2:
Input: steps = 3, arrLen = 2
Output: 4

Constraints:

1 <= steps <= @data
1 <= arrLen <= @data

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[50, 100, 1000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(int steps, int arrLen) {
        int MOD = 1e9 + 7;
        arrLen = min(arrLen, steps);
        vector<int> dp(arrLen, 0);
        vector<int> prevDp(arrLen, 0);
        prevDp[0] = 1;
        
        for (int remain = 1; remain <= steps; remain++) {
            fill(dp.begin(),dp.end(),0);
            
            for (int curr = arrLen - 1; curr >= 0; curr--) {
                int ans = prevDp[curr];
                
                if (curr > 0) {
                    ans = (ans + prevDp[curr - 1]) % MOD;
                }
                
                if (curr < arrLen - 1) {
                    ans = (ans + prevDp[curr + 1]) % MOD;
                }
                
                dp[curr] = ans;
            }
            
            prevDp = dp;
        }
        
        return dp[0];
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    // solve
    Solution solution;
    auto result = solution.solve(n,m);
    
    // output
    cout << result << ""\n"";

    return 0;
}",dp,medium
348,"# Problem Statement
There are two screens which can display sequences of uppercase Latin letters. Initially, both screens display nothing.

In one second, you can do one of the following two actions:

-   choose a screen and an uppercase Latin letter, and append that letter to **the end** of the sequence displayed on that screen;
-   choose a screen and copy the sequence from it to the other screen, **overwriting the sequence that was displayed on the other screen**.

You have to calculate the minimum number of seconds you have to spend so that the first screen displays the sequence $s$, and the second screen displays the sequence $t$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(string &s, string &t) {
        // write your code here
    }
};
```
where:  
- return:  the minimum possible number of seconds you have to spend so that the first screen displays the sequence s, and the second screen displays the sequence t.

# Example 1:  
- Input:  
s = ""GARAGE""
t = ""GARAGEFORSALE""
- Output:  
14


# Constraints:  
- $1 \leq s.length, t.length \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(string &s, string &t)
    {
        int i = 0;
        while (i < s.size() && i < t.size() && s[i] == t[i])
            i++;
        int ans = s.size() + t.size() - max(0, i - 1);
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    string s, t;
    cin >> s >> t;

    // solve
    Solution solution;
    auto result = solution.solve(s, t);

    // output
    cout << result << ""\n"";

    return 0;
}","string,greedy,two_pointers",hard
349,"A happy string is a string that:

    consists only of letters of the set ['a', 'b', 'c'].
    s[i] != s[i + 1] for all values of i from 1 to s.length - 1 (string is 1-indexed).

For example, strings ""abc"", ""ac"", ""b"" and ""abcbabcbcb"" are all happy strings and strings ""aa"", ""baa"" and ""ababbc"" are not happy strings.

Given two integers n and k, consider a list of all happy strings of length n sorted in lexicographical order.

Return the kth string of this list or return an empty string if there are less than k happy strings of length n.

solution main function
```cpp
class Solution {
public:
    vector<int> solve(int label) {
        
    }
};
```

Example 1:
Input: n = 1, k = 3
Output: ""c""

Example 2:
Input: n = 1, k = 4
Output: """"

Constraints:


1 <= n <= @data
1 <= k <= 100


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    string solve(int n, int &k, int p = 0, char last_ch = 0) {
        if (p == n)
            --k;
        else
            for (char ch = 'a'; ch <= 'c'; ++ch) {
                if (ch != last_ch) {
                    auto res = solve(n, k, p + 1, ch);
                    if (k == 0)
                        return string(1, ch) + res;
                }
            }
        return """";
}
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,k; cin>>n>>k;
    // solve
    Solution solution;
    auto result = solution.solve(n,k);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","math,search,string",medium
350,"# Problem Statement
When Valera has got some free time, he goes to the library to read some books. Today he's got t free minutes to read. That's why Valera took n books in the library and for each book he estimated the time he is going to need to read it. Let's number the books by integers from 1 to n. Valera needs ai minutes to read the i-th book.

Valera decided to choose an arbitrary book with number i and read the books one by one, starting from this book. In other words, he will first read book number i, then book number i+1, then book number i+2 and so on. He continues the process until he either runs out of the free time or finishes reading the n-th book. Valera reads each book up to the end, that is, he doesn't start reading the book if he doesn't have enough free time to finish reading it.

Print the maximum number of books Valera can read.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &t, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the maximum number of books Valera can read.

# Example 1:  
- Input:  
n = 4, t = 5, a = [3, 1, 2, 1]
- Output:  
3

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq t \leq 10^9$
- $1 \leq a[i] \leq 10^4$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, int &t, vector<int> &a)
    {
        int i = 0, j = 0, k = 0, mx = 0, sum = 0;
        while (i < n)
        {
            if (sum + a[i] <= t)
            {
                k++;
                sum += a[i];
            }
            else
            {
                i--;
                k--;
                sum -= a[j++];
            }
            i++;
            if (mx < k)
                mx = k;
        }
        return mx;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, t;
    cin >> n >> t;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, t, a);

    // output
    cout << result << ""\n"";

    return 0;
}","search,two_pointers",medium
351,"# Problem Statement
Rostam's loyal horse, Rakhsh, has seen better days. Once powerful and fast, Rakhsh has grown weaker over time, struggling to even move. Rostam worries that if too many parts of Rakhsh's body lose strength at once, Rakhsh might stop entirely. To keep his companion going, Rostam decides to strengthen Rakhsh, bit by bit, so no part of his body is too frail for too long.

Imagine Rakhsh's body as a line of spots represented by a binary string $s$ of length $n$, where each $0$ means a weak spot and each $1$ means a strong one. Rostam's goal is to make sure that no interval of $m$ consecutive spots is entirely weak (all $0$s).

Luckily, Rostam has a special ability called Timar, inherited from his mother Rudabeh at birth. With Timar, he can select any segment of length $k$ and instantly strengthen all of it (changing every character in that segment to $1$). The challenge is to figure out the minimum number of times Rostam needs to use Timar to keep Rakhsh moving, ensuring there are no consecutive entirely weak spots of length $m$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &m, int &k, string &s) {
        // write your code here
    }
};
```
where:  
- the return value is the minimum number of times Timar is used

# Example 1:  
- Input:  
n = 5, m = 1, k = 1
s = ""10101""
- Output:  
2

# Constraints:  
- $1 \leq m, k \leq n \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[100, 10000, 1000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, int &m, int &k, string &s)
    {
        int cnt = 0, ans = 0;
        int r = 0;
        for (int l = 1; l <= n; l++)
        {
            if (s[l - 1] == '1')
                cnt = 0;
            else
            {
                if (s[l - 1] == '0' && l > r)
                    cnt++;
                if (cnt == m)
                {
                    ans++;
                    cnt = 0;
                    r = l + k - 1;
                }
            }
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, m, k;
    cin >> n >> m >> k;
    string s;
    cin >> s;

    // solve
    Solution solution;
    auto result = solution.solve(n, m, k, s);

    // output
    cout << result << ""\n"";

    return 0;
}","two_pointers,data_structures",medium
352,"# Problem Statement
You are given a binary array $a$ of $n$ elements, a binary array is an array consisting only of $0$s and $1$s.

A blank space is a segment of **consecutive** elements consisting of only $0$s.

Your task is to find the length of the longest blank space.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {   
        // write your code here
    }
};
```
where:  
- return the length of the longest blank space.

# Example 1:  
- Input:  
n = 5
a = [1, 0, 0, 1, 0]
- Output:  
2

# Constraints:  
- $1 \leq n \leq @data$  
- $0 \leq a_i \leq 1$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[100, 10000, 1000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        int ans = 0;
        int t = 0;
        for (int i = 0; i < n; i++)
        {
            if (a[i] == 0)
                t++;
            else
                t = 0;
            ans = max(ans, t);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (auto &x : a)
        cin >> x;
    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",greedy,easy
353,"Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing.

    For example, if word = ""abcdefd"" and ch = ""d"", then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be ""dcbaefd"".

Return the resulting string.

solution main function

```cpp
class Solution {
public:
    string solve(string word, char ch) {
        
    }
};
```

Example 1:
Input: word = ""abcdefd"", ch = ""d""
Output: ""dcbaefd""

Example 2:
Input: word = ""xyxzxe"", ch = ""z""
Output: ""zxyxxe""

Constraints:

1 <= word.length <= @data
word consists of lowercase English letters.
ch is a lowercase English letter.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    string solve(string word, char ch) {
        int left = 0;

        for (int right = 0; right < word.length(); right++) {
            // We found ch - reverse characters up to ch by swapping
            if (word[right] == ch) {
                while (left < right) {
                    swap(word[right], word[left]);
                    left++;
                    right--;
                }
                return word;
            }
        }
        return word;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string s,ch;
    cin>>ch>>s;
    // solve
    Solution solution;
    auto result = solution.solve(s,ch[0]);
    
    // output
    cout<<result;
    return 0;
}","string,two_pointers",easy
354,"Given two arrays of integers nums and index. Your task is to create target array under the following rules:

    Initially target array is empty.
    From left to right read nums[i] and index[i], insert at index index[i] the value nums[i] in target array.
    Repeat the previous step until there are no elements to read in nums and index.

Return the target array.

It is guaranteed that the insertion operations will be valid.

solution main function
```cpp
class Solution {
public:
    vector<int> solve(vector<int>& nums, vector<int>& index) {
        
    }
};
```

Example 1:
Input: nums = [0,1,2,3,4], index = [0,1,2,2,1]
Output: [0,4,1,3,2]

Example 2:
Input: nums = [1,2,3,4,0], index = [0,1,2,3,0]
Output: [0,1,2,3,4]

Constraints:


1 <= nums.length, index.length <= @data
nums.length == index.length
0 <= nums[i] <= 100
0 <= index[i] <= i


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> solve(vector<int>& nums, vector<int>& arr) {
        int n= arr.size();
        vector<int>tar;
        tar.push_back(nums[0]);
        for(int i = 1; i < n; i++)
        {
            tar.insert(tar.begin() + arr[i], nums[i]);
        }

        return tar;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;cin>>n;
    vector<int> a,b;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        a.push_back(x);
    }
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        b.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(a,b);
    
    // output
    for(auto it:result) cout<<it<<' ';
    // cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",other,easy
355,"Given two integer arrays nums1 and nums2, sorted in non-decreasing order, return the minimum integer common to both arrays. If there is no common integer amongst nums1 and nums2, return -1.

Note that an integer is said to be common to nums1 and nums2 if both arrays have at least one occurrence of that integer.
solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& nums1, vector<int>& nums2) {
        
    }
};
```

Example 1:
Input: nums1 = [1,2,3], nums2 = [2,4]
Output: 2

Example 2:
Input: nums1 = [1,2,3,6], nums2 = [2,3,4,5]
Output: 2

Constraints:

1 <= nums1.length, nums2.length <= @data
1 <= nums1[i], nums2[j] <= 10^9
Both nums1 and nums2 are sorted in non-decreasing order.

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums1, vector<int>& nums2) {
        // Binary search should be done on the larger array
        // If nums1 is longer, call getCommon with the arrays swapped
        if (nums1.size() > nums2.size()) {
            return solve(nums2, nums1);
        }

        // Search for each element of nums1 in nums2
        // Return the first common element found
        for (int num : nums1) {
            if (binarySearch(num, nums2)) {
                return num;
            }
        }

        // Return -1 if there are no common elements
        return -1;
    }

private:
    bool binarySearch(int target, vector<int>& nums) {
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                return true;
            }
        }
        return false;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m;
    vector<int> a,b;
    cin>>n>>m;
    for(int i=1,x;i<=n;i++)
    {
        cin>>x;
        a.push_back(x);
    }
    for(int i=1,x;i<=m;i++)
    {
        cin>>x;
        b.push_back(x);
    }
    sort(a.begin(),a.end());
    sort(b.begin(),b.end());
    // solve
    Solution solution;
    auto result = solution.solve(a,b);
    
    // output
    cout<<result;
    return 0;
}","two_pointers,binary",easy
356,"The middle order and post order of a binary tree are given. Find its preordering. (Convention tree nodes are represented by different capital letters).

solution main function
```cpp
class Solution
{
public:
string solve(string mid,string suf)
}
```

Pass in parameters:
Two strings of uppercase letters representing the middle and back order of a binary tree

Return parameters:
A string representing the first order of a binary tree.

Example 1:
Input: mid=""BADC"",suf=""BDCA""
Output: ""ABCD""

Constraints:
The string length is less than or equal to @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[3, 5, 8]",1000.0,"[[256, 128, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution
{
public:
    string solve(string mid, string suf)
    {
        if (mid.size() == 0) return """";

        char ch = suf[suf.size() - 1];
        int k = mid.find(ch);

        return string(1, ch) + solve(mid.substr(0, k), suf.substr(0, k)) + solve(mid.substr(k + 1), suf.substr(k, mid.size() - k - 1));
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string mid,suf;cin>>mid>>suf;

    // solve
    Solution solution;
            auto result = solution.solve(mid,suf);
    
    // output
    cout << result << ""\n"";

    return 0;
}",tree,easy
357,"# Problem Statement
There is a grid, consisting of $2$ rows and $n$ columns. Each cell of the grid is either free or blocked.

A free cell $y$ is reachable from a free cell $x$ if at least one of these conditions holds:

-   $x$ and $y$ share a side;
-   there exists a free cell $z$ such that $z$ is reachable from $x$ and $y$ is reachable from $z$.

A connected region is a set of free cells of the grid such that all cells in it are reachable from one another, but adding any other free cell to the set violates this rule.

The given grid contains at most $1$ connected region. Your task is to calculate the number of free cells meeting the following constraint:

-   if this cell is blocked, the number of connected regions becomes exactly $3$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, string &s1, string &s2) { 
        // write your code here
    }
};
```
where:  
- `s1` and `s2` are two strings of two rows of the grid, each character is `.` or `x`, `.` means free, `x` means blocked
- return the maximum number of free cells that meet the condition

# Example 1:  
- Input:  
-   
n = 8
s1 = "".......x""
s2 = "".x.xx...""
- Output:  
1

# Constraints:  
- $1 \leq n \leq @data$
- The given grid contains at most $1$ connected region
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[100, 10000, 1000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, string &s1, string &s2)
    {
        int ans = 0;
        for (int i = 1; i < n - 1; i++)
        {
            if (s1[i] == '.' && s1[i - 1] == '.' && s1[i + 1] == '.' && s2[i] == '.' && s2[i - 1] == 'x' && s2[i + 1] == 'x')
                ans++;
            if (s2[i] == '.' && s2[i - 1] == '.' && s2[i + 1] == '.' && s1[i] == '.' && s1[i - 1] == 'x' && s1[i + 1] == 'x')
                ans++;
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{

    // input
    int n;
    cin >> n;
    string s1, s2;
    cin >> s1 >> s2;
    // solve
    Solution solution;
    auto result = solution.solve(n, s1, s2);

    // output
    cout << result << ""\n"";

    return 0;
}",two_pointers,medium
358,"# Problem Statement:
Given an array $a$ of $n$ elements, print any value that appears at least three times or print -1 if there is no such value.

The main function of the solution is defined as: 
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {   
        // write your code here
    }
};
```
Where:  
- return the minimum value that appears at least three times, or -1 if there is no such value.

# Example 1:
- Input:  
n = 5  
a = [1, 2, 3, 2, 2]
- Output:  
2

# Constraints:
- $0 \leq n \leq @data$
- $1 \leq  a[i] \leq n$ 
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        sort(a.begin(), a.end());
        int cnt = 1;
        for (int i = 1; i < n; i++)
        {
            if(a[i]==a[i-1])cnt++;
            else cnt = 1;
            if(cnt==3)return a[i];
        }
        return -1;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","sort,greedy",easy
359,"# Problem Statement
There are $n$ flowers in a row, the $i$\-th of them initially has a positive height of $h_i$ meters.

Every second, the wind will blow from the left, causing the height of some flowers to decrease.

Specifically, every second, for each $i$ from $1$ to $n$, in this order, the following happens:

-   If $i = n$ or $h_i &gt; h_{i + 1}$, the value of $h_i$ changes to $\max(0, h_i - 1)$.

How many seconds will pass before $h_i=0$ for all $1 \le i \le n$ for the first time?

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &h) {
        // write your code here
    }
};
```
where:  
- return: the number of seconds that will pass before hi=0 for all 1in.

# Example 1:  
- Input:  
n = 3
h = [1, 1, 2]
- Output:  
4

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq h[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &h)
    {
        int ans = 0;
        for (int i = n - 1; i >= 0; i--)
        {
            ans = max(ans, i + h[i]);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","dp,sort",medium
360,"Given a 0-indexed string s, permute s to get a new string t such that:

    All consonants remain in their original places. More formally, if there is an index i with 0 <= i < s.length such that s[i] is a consonant, then t[i] = s[i].
    The vowels must be sorted in the nondecreasing order of their ASCII values. More formally, for pairs of indices i, j with 0 <= i < j < s.length such that s[i] and s[j] are vowels, then t[i] must not have a higher ASCII value than t[j].

Return the resulting string.

The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in lowercase or uppercase. Consonants comprise all letters that are not vowels.

solution main function

```cpp
class Solution {
public:
    string solve(string s) {
        
    }
};
```

Example 1:
Input: s = ""lEetcOde""
Output: ""lEOtcede""

Example 2:
Input: s = ""lYmpH""
Output: ""lYmpH""

Constraints:


1 <= s.length <= @data
s consists only of letters of the English alphabet in uppercase and lowercase.


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 256]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    // Returns true if the character is a vowel.
    bool isVowel(char c) {
        return c == 'a' || c == 'e' || c == 'o'|| c == 'u'|| c == 'i' 
            || c == 'A' || c == 'E' || c == 'O'|| c == 'U'|| c == 'I';
    }
    
    string solve(string s) {
        unordered_map<char, int> count;

        // Store the frequencies for each character.
        for (char c : s) {
            if (isVowel(c)) {
                count[c]++;
            }
        }

        // Sorted string having all the vowels.
        string sortedVowel = ""AEIOUaeiou"";
        string ans;
        int j = 0;
        for (int i = 0; i < s.size(); i++) {
            if (!isVowel(s[i])) {
                ans += s[i];
            } else {
                // Skip to the character which is having remaining count.
                while (count[sortedVowel[j]] == 0) {
                    j++;
                }

                ans += sortedVowel[j];
                count[sortedVowel[j]]--;
            }
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string s; cin>>s;
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    cout<<result;
    return 0;
}","sort,string",easy
361,"Given the array queries of positive integers between 1 and m, you have to process all queries[i] (from i=0 to i=queries.length-1) according to the following rules:

    In the beginning, you have the permutation P=[1,2,3,...,m].
    For the current i, find the position of queries[i] in the permutation P (indexing from 0) and then move this at the beginning of the permutation P. Notice that the position of queries[i] in P is the result for queries[i].

Return an array containing the result for the given queries.

solution main function
```cpp
class Solution {
public:
    vector<int> solve(vector<int>& queries, int m) {
        
    }
};
```

Example 1:
Input: queries = [3,1,2,1], m = 5
Output: [2,1,2,1] 

Example 2:
Input: queries = [4,1,2,2], m = 4
Output: [3,1,2,0]

Constraints:

1 <= m <= @data
1 <= queries.length <= m
1 <= queries[i] <= m

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int querySum(vector<int>& BIT, int x) {
        int sum = 0;
        for (; x > 0; x -= (x & -x)) {
            sum += BIT[x];
        }
        return sum;
    }
    void update(vector<int>& BIT, int x, const int val) {
        for (; x < BIT.size(); x += (x & -x)) {
            BIT[x] += val;
        }
    }
    vector<int> solve(vector<int>& queries, int m) {
        if (m == 1) {
            return {0};
        }
        int n = queries.size();
        vector<int> ans, tree(m + n + 1, 0), hash(m + 1);
        for (int i = 1; i <= m; i++) {
            hash[i] = n + i;
            update(tree, n + i, 1);
        }
        for (auto q : queries) {
            ans.push_back(querySum(tree, hash[q] - 1));
            update(tree, hash[q], -1);
            update(tree, n, 1);
            hash[q] = n--;
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s,m);
    
    // output
    for(auto it:result) cout<<it<<' ';
    // cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",other,medium
362,"# Problem Statement
Monocarp is playing a computer game. Now he wants to complete the first level of this game.

A level is a rectangular grid of $2$ rows and $n$ columns. Monocarp controls a character, which starts in cell $(1, 1)$ at the intersection of the $1$\-st row and the $1$\-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell $(x_1, y_1)$ to cell $(x_2, y_2)$ in one step if $|x_1 - x_2| \le 1$ and $|y_1 - y_2| \le 1$. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell $(2, n)$ at the intersection of row $2$ and column $n$.

Help Monocarp determine if it is possible to complete the level.

Solution Function**  
The solution's main function is:  
```cpp
class Solution {
public:
    string solve(int &n, string &s1, string &s2) {
        // write your code here
    }
};
```
where:  
- `n` is an integer representing the number of columns in the grid.
- `s1` is a string representing the first row of the grid.
- `s2` is a string representing the second row of the grid.
- The function should return a string: `""YES""` if it is possible to complete the level, or `""NO""` otherwise.

# Example 1  
- Input:  
n = 6
s1 = 010101
s2 = 101010
- Output:  
YES

**Constraints**  
- $3 \leq n \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve(int &n, string &s1, string &s2)
    {
        for (int i = 0; i < n; i++)
            if (s1[i] == '1' && s2[i] == '1')
                return ""NO"";
        return ""YES"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    string s1, s2;
    cin >> s1 >> s2;

    // solve
    Solution solution;
    auto result = solution.solve(n, s1, s2);

    // output
    cout << result << ""\n"";

    return 0;
}","search,dp,greedy",medium
363,"There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i].
A node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node).
Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.

solution main function
```cpp
class Solution
{
    public:
    vector<int> solve(vector<vector<int>>& graph)
}
```

Example 1:
Inputgraph = [[1,2],[2,3],[5],[0],[5],[],[]]
Output: [2,4,5,6]

Example 2:
Inputgraph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
Output: [4]

Constraints:
n == graph.length
1 <= n <= @data
0 <= graph[i].length <= n
0 <= graph[i][j] <= n - 1
graph[i] is sorted in a strictly increasing order.
The graph may contain self-loops.
The number of edges in the graph will be in the range [1, 4 * n].
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 100, 10000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> solve(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<bool> vis(n);
        vector<bool> safe(n);
        auto dfs = [&](auto dfs, int u) -> void {
            vis[u] = true;
            for(int v : graph[u]) {
                if(!vis[v]) { 
                    dfs(dfs, v);
                    if(!safe[v]) { 
                        safe[u] = false;
                        return ;
                    }
                } else if(!safe[v]) { 
                    safe[u] = false;
                    return ;
                }
            }
            safe[u] = true;
        };

        for(int i = 0;i < n;i ++) {
            if(!vis[i]) dfs(dfs, i);
        }
        vector<int> ans;
        for(int i = 0;i < n;i ++) {
            if(safe[i]) ans.push_back(i);
        }
        return move(ans);
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m;
    cin>>n>>m;
    vector<vector<int> > g;
    vector<int> e[n+1];
    for(int i=1;i<=m;i++)
    {
        int x,y; cin>>x>>y;
        e[x].push_back(y);
    }
    for(int i=0;i<n;i++)
        g.push_back(e[i]);
    // solve
    Solution solution;
            auto result = solution.solve(g);
    
    // output
    for(auto it:result)
        cout<<it<<' ';
    return 0;
}","graph,search",medium
364,"Given a 2D grid of size m x n, you should find the matrix answer of size m x n.

The cell answer[r][c] is calculated by looking at the diagonal values of the cell grid[r][c]:

    Let leftAbove[r][c] be the number of distinct values on the diagonal to the left and above the cell grid[r][c] not including the cell grid[r][c] itself.
    Let rightBelow[r][c] be the number of distinct values on the diagonal to the right and below the cell grid[r][c], not including the cell grid[r][c] itself.
    Then answer[r][c] = |leftAbove[r][c] - rightBelow[r][c]|.

A matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until the end of the matrix is reached.

    For example, in the below diagram the diagonal is highlighted using the cell with indices (2, 3) colored gray:
        Red-colored cells are left and above the cell.
        Blue-colored cells are right and below the cell.


solution main function
```cpp
class Solution {
public:
    vector<vector<int>> solve(vector<vector<int>>& grid) {
        
    }
};
```

Example 1:
Input: grid = [[1,2,3],[3,1,5],[3,2,1]]
Output: Output: [[1,1,0],[1,0,1],[0,1,1]]

Example 2:
Input: grid = [[1]]
Output: Output: [[0]]


Constraints:

m == grid.length
n == grid[i].length
1 <= m, n, grid[i][j] <= 50

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[50, 100, 500]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<vector<int>> solve(vector<vector<int>>& grid) {
        int width = grid[0].size();
        int length = grid.size();
        

        for (int i = 0 ;i < width ;i++) {
            unordered_map<int, pair<int, int>> elementMap;
            makeElementMap(elementMap, grid, 0, i);

            int left = 0;
            int right = elementMap.size();
            int j = 0;

            while((i+j < width) && (j < length)) {
                int element = grid[j][i+j];
                auto position = elementMap[element];

                if (position.second == j) {
                    right -= 1;
                }

                grid[j][i+j] = abs(left - right);
    
                if (position.first == j) {
                    left += 1;
                }
                j += 1;
            }
        }   

        for (int i = 1 ;i < length ;i++) {
            unordered_map<int, pair<int, int>> elementMap;
            makeElementMap(elementMap, grid, i, 0);

            int left = 0;
            int right = elementMap.size();
            int j = 0;

            while((i+j < length) && (j < width)) {
                int element = grid[i+j][j];
                auto position = elementMap[element];

                if (position.second == j) {
                    right -= 1;
                }

                grid[i+j][j] = abs(left - right);
    
                if (position.first == j) {
                    left += 1;
                }

                j += 1;
            }
        }   

        return grid;
    }

    void makeElementMap(unordered_map<int, pair<int, int>>& elementMap, vector<vector<int>>& grid, int startX, int startY) {
        int offset = 0;
        while ((startX + offset < grid.size()) && (startY + offset < grid[0].size())) {
            int element = grid[startX+offset][startY+offset];

            if (0 == elementMap.count(element)) {
                elementMap[element] = std::pair<int, int>(offset, offset);
            } else {
                elementMap[element].second = offset;
            }

            offset += 1;
        }
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m; cin>>n>>m;
    vector<vector<int> > s;
    for(int i=1;i<=n;i++)
    {
        vector<int> temp;
        for(int j=1;j<=m;j++)
        {
            int x; cin>>x;
            temp.push_back(x);
        }
        s.push_back(temp);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    // cout<<result;
    for(auto s:result)
    {
        for(auto it:s)
            printf(""%d "",it);
        putchar('\n');
    }
    return 0;
}",other,medium
365,"Given an array of integers arr and an integer d. In one step you can jump from index i to index:

    i + x where: i + x < arr.length and  0 < x <= d.
    i - x where: i - x >= 0 and  0 < x <= d.

In addition, you can only jump from index i to index j if arr[i] > arr[j] and arr[i] > arr[k] for all indices k between i and j (More formally min(i, j) < k < max(i, j)).

You can choose any index of the array and start jumping. Return the maximum number of indices you can visit.

Notice that you can not jump outside of the array at any time.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& arr, int d) {
        
    }
};
```

Example 1:
Input: arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2
Output: 4

Example 2:
Input: arr = [3,3,3,3,3], d = 3
Output: 1

Constraints:


1 <= arr.length <= @data
1 <= arr[i] <= 10^5
1 <= d <= arr.length


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 10000]",1000.0,"[[80000, 40000, 20000]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& arr, int d) {
        arr.push_back(INT_MAX); 
        uint32_t sz = arr.size();
        vector<int> score(sz, 0);
        stack<uint32_t> st;
        vector<uint32_t> duplicates;
        int best = 0;
        for(uint32_t i = 0; i < sz; i++) {
            // remove any elements exceeded by current
            duplicates.resize(0); 
            while(!st.empty() && (arr[i] > arr[st.top()] || i - st.top() > d)) {
                uint32_t j = st.top(); st.pop();
                if(!st.empty()) {
                    if(arr[st.top()] > arr[j]) {
                        score[st.top()] = max(score[st.top()], 1 + score[j]);
                        while(duplicates.size() > 0) {
                            if(duplicates.back() - st.top() <= d) {
                                score[st.top()] = max(score[st.top()], 1 + score[duplicates.back()]);
                            }
                            duplicates.pop_back();
                        }
                    } else {
                        duplicates.push_back(j);
                    }
                }
                if(i - j <= d) {
                    score[i] = max(score[i], score[j] + 1); 
                } 
            }
            st.push(i); 
        }
        score.pop_back();
        arr.pop_back();
        //return max(best + 1, score[sz - 1]); 
        return *max_element(score.begin(), score.end()) + 1;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,d; cin>>n>>d;
    vector<int> s;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        s.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(s,d);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}","dynamic_programming,sort",hard
366,"# Problem Statement
You have an integer array $a$ of length $n$. There are two kinds of operations you can make.

- Remove an integer from $a$. This operation costs $c$.
- Insert an arbitrary positive integer $x$ to any position of $a$ (to the front, to the back, or between any two consecutive elements). This operation costs $d$.

You want to make the final array a permutation of **any** positive length. Please output the minimum cost of doing that. Note that you can make the array empty during the operations, but the final array must contain at least one integer.

A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).

Note that the answer may be large, so you should use a type.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, int &c, int &d, vector<int> &a) {   
        // write your code here
    }
};
```
where:  
- Return 64-bit integer type of the minimum cost

# Example 1:  
- Input:  
n = 3, c = 3, d = 3
a = [1, 2, 3]
- Output:  
0

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq c, d \leq 10^9$
- $1 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[100, 10000, 1000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(int &n, int &c, int &d, vector<int> &a)
    {
        sort(a.begin(), a.end());
        long long ans = 1LL * c * n + d;
        int t = 0;
        for (int i = 0; i < n; i++)
        {
            if (i == 0 || a[i] != a[i - 1])
                t++;
            ans = min(ans, 1LL * c * n + 1LL * d * a[i] - 1LL * (c + d) * t);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, c, d;
    cin >> n >> c >> d;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, c, d, a);

    // output
    cout << result << ""\n"";

    return 0;
}","math,sort",hard
367,"# Problem Statement
While exploring the jungle, you have bumped into a rare orangutan with a bow tie! You shake hands with the orangutan and offer him some food and water. In return...

The orangutan has gifted you an array $a$ of length $n$. Using $a$, you will construct two arrays $b$ and $c$, both containing $n$ elements, in the following manner:

-   $b_i = \min(a_1, a_2, \ldots, a_i)$ for each $1 \leq i \leq n$.
-   $c_i = \max(a_1, a_2, \ldots, a_i)$ for each $1 \leq i \leq n$.

Define the score of $a$ as $\sum_{i=1}^n c_i - b_i$ (i.e. the sum of $c_i - b_i$ over all $1 \leq i \leq n$). Before you calculate the score, you can **shuffle** the elements of $a$ however you want.

Find the maximum score that you can get if you shuffle the elements of $a$ optimally.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the maximum score that you can get.

# Example 1:  
- Input:  
n = 1
a = [69]
- Output:  
0

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq 10^3$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        int mx = *max_element(a.begin(), a.end());
        int mn = *min_element(a.begin(), a.end());
        return (mx - mn) * (n - 1);
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",sort,easy
368,"# Problem Statement
You are given an array $a$ of length $n$. Start with $c = 0$. Then, for each $i$ from $1$ to $n$ (in increasing order) do **exactly one** of the following:

-   Option $1$: set $c$ to $c + a_i$.
-   Option $2$: set $c$ to $|c + a_i|$, where $|x|$ is the absolute value of $x$.

Let the maximum final value of $c$ after the procedure described above be equal to $k$. Find $k$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return the value of $k$.

# Example 1:  
- Input:  
n = 4
a = [10, -9, -3, 4]
- Output: 
6 


# Constraints:  
- $2 \leq n \leq @data$
- $-10^9 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(int &n, vector<int> &a)
    {
        long long c1 = 0, c2 = 0;
        for (int i = 0; i < n; i++)
        {
            long long pre1 = c1, pre2 = c2;
            c1 = max({pre1 + a[i], abs(pre2 + a[i])});
            c2 = pre2 + a[i];
        }
        return c1;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",dp,medium
369,"Give an integer N and K transformation rules.
Rules:
- Change one digit to another.
- The right part of the rule cannot be zero.
Find out how many different integers can be produced by any number of transformations (0 or more).
Only the number of outputs is required.

solution main function
```cpp
class Solution
{
public:
string solve(string N, int K, vector<pair<int,int> > &rules)
}
```
Example 1:
Input: N = 234, K = 2, rules = [ [2, 5], [3, 6] ]
Output: 4

Constraints:
0<N<10^@data,0<K<@data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[5, 10, 15]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution
{
public:
	bool tag[10][10]={};
	int d[10]={};
	int p[1000]={};
    string solve(string a, int n, vector<pair<int,int> > &rules)
    {
        string ans;
        int x,y;
        for(int i=0;i<n;i++)
            tag[rules[i].first][rules[i].second]=1;
	    for(int k=1;k<=9;k++)
	        for(int i=0;i<=9;i++)
	            for(int j=1;j<=9;j++)
	                if(tag[i][k]&&tag[k][j]) tag[i][j]=1;
        for(int i=0;i<10;i++)
        {
            tag[i][i]=1;
            for(int j=0;j<10;j++)
                if(tag[i][j])
                d[i]++;
        }
        int z=0;
        p[0]=1;
        for(int i=0;a[i];i++)
        {
            z=0;
            int x=d[a[i]-'0'];
            for(int i=0;i<500;i++)
            {
                p[i]=(p[i]*x+z);
                z=p[i]/10;
                p[i]%=10;
            }
        }
        int i=500;
        while(p[i]==0) i--;
        for(;i>=0;i--) ans.push_back(p[i]+'0');
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    string N;
    int K; cin >> N >> K;
    vector<pair<int,int> > rules;
    for (int i = 0; i < K; i++)
    {
        int x,y; cin >>x>>y;
        rules.push_back({x,y});
    }

    // solve
    Solution solution;
            auto result = solution.solve(N,K,rules);
    
    // output
    cout << result ;

    return 0;
}",graph,hard
370,"You are given two 0-indexed arrays, nums1 and nums2, consisting of non-negative integers. There exists another array, nums3, which contains the bitwise XOR of all pairings of integers between nums1 and nums2 (every integer in nums1 is paired with every integer in nums2 exactly once).

Return the bitwise XOR of all integers in nums3.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& nums1, vector<int>& nums2) {
        
    }
};
```

Example 1:
Input: nums1 = [2,1,3], nums2 = [10,2,5,0]
Output: 13

Example 2:
Input: nums1 = [1,2], nums2 = [3,4]
Output: 0

Constraints:


1 <= nums1.length, nums2.length <= @data
0 <= nums1[i], nums2[j] <= 10^9


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums1, vector<int>& nums2) {
        // Initialize XOR results for both arrays
        int xor1 = 0;
        int xor2 = 0;

        // Get lengths of both arrays
        int len1 = nums1.size();
        int len2 = nums2.size();

        // If nums2 length is odd, each element in nums1 appears odd times in
        // final result
        if (len2 % 2 != 0) {
            for (int num : nums1) {
                xor1 ^= num;
            }
        }

        // If nums1 length is odd, each element in nums2 appears odd times in
        // final result
        if (len1 % 2 != 0) {
            for (int num : nums2) {
                xor2 ^= num;
            }
        }

        // Return XOR of both results
        return xor1 ^ xor2;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m;
    vector<int> a,b;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        a.push_back(x);
    }
     for(int i=1;i<=m;i++)
    {
        int x; cin>>x;
        b.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(a,b);
    
    // output
    cout<<result;
    return 0;
}",bit_manipulation,medium
371,"# Problem Statement
You are given a rooted tree consisting of $n$ vertices numbered from $1$ to $n$. The root is vertex $1$. There is also a string $s$ denoting the color of each vertex: if $s_i = \texttt{B}$, then vertex $i$ is black, and if $s_i = \texttt{W}$, then vertex $i$ is white.

A subtree of the tree is called balanced if the number of white vertices equals the number of black vertices. Count the number of balanced subtrees.

A tree is a connected undirected graph without cycles. A rooted tree is a tree with a selected vertex, which is called the root. In this problem, all trees have root $1$.

The tree is specified by an array of parents $a_2, \dots, a_n$ containing $n-1$ numbers: $a_i$ is the parent of the vertex with the number $i$ for all $i = 2, \dots, n$. The parent of a vertex $u$ is a vertex that is the next vertex on a simple path from $u$ to the root.

The subtree of a vertex $u$ is the set of all vertices that pass through $u$ on a simple path to the root. 

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a, string &s) {
        // write your code here
    }
};
```
where:  
- `a`: contains $n-1$ integers, $a_i$ is the parent of the vertex with the number $i$ for all $i = 2, \dots, n$.
- `s`: 'B' or 'W' denoting the color of each vertex.
- return: the number of balanced subtrees.

# Example 1:  
- Input: 
n = 7
a = [1, 1, 2, 3, 3, 5]
s = ""WBBWWBW"" 
- Output:  
2

# Constraints:  
- $2 \leq n \leq @data$
- $1 \leq a[i] < i$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 1280, 640]]","class Solution
{
public:
    int solve(int &n, vector<int> &a, string &s)
    {
        vector<int> b(n);
        for (int i = 0; i < n - 1; i++)
            a[i]--;
        for (int i = 0; i < n; i++)
        {
            b[i] = (s[i] == 'W' ? 1 : -1);
        }
        for (int i = n - 2; i >= 0; i--)
        {
            b[a[i]] += b[i + 1];
        }
        return count(b.begin(), b.end(), 0);
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n - 1);
    for (int i = 0; i < n - 1; i++)
    {
        cin >> a[i];
    }
    string s;
    cin >> s;
    // solve
    Solution solution;
    auto result = solution.solve(n, a, s);

    // output
    cout << result << ""\n"";

    return 0;
}","search,dp,graph,tree",hard
372,"# Problem Statement
Gridlandia has been hit by flooding and now has to reconstruct all of it's cities. Gridlandia can be described by an $n \times m$ matrix.

Initially, all of its cities are in economic collapse. The government can choose to rebuild certain cities. Additionally, any collapsed city which has at least one vertically neighboring rebuilt city and at least one horizontally neighboring rebuilt city can ask for aid from them and become rebuilt **without help from the government**. More formally, collapsed city positioned in $(i, j)$ can become rebuilt if **both** of the following conditions are satisfied:

-   At least one of cities with positions $(i + 1, j)$ and $(i - 1, j)$ is rebuilt;
-   At least one of cities with positions $(i, j + 1)$ and $(i, j - 1)$ is rebuilt.

If the city is located on the border of the matrix and has only one horizontally or vertically neighbouring city, then we consider only that city.

The government wants to know the minimum number of cities it has to rebuild such that **after some time** all the cities can be rebuild.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &m) { 
        // write your code here
    }
};
```
where:  
- `n` is the column number of the cities, and `m` is the row number of the cities
- return the minimum number of cities that need to be rebuilt

# Example 1:  
- Input:  
n = 2, m = 2
- Output:  
2

# Constraints:  
- $1 \leq n, m \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10000, 1000000, 100000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, int &m)
    {
        return max(n, m);
    }
};


","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, m;
    cin >> n >> m;

    // solve
    Solution solution;
    auto result = solution.solve(n, m);

    // output
    cout << result << ""\n"";

    return 0;
}","math,sort,data_structures",hard
373,"You are given a 0-indexed string s and a dictionary of words dictionary. You have to break s into one or more non-overlapping substrings such that each substring is present in dictionary. There may be some extra characters in s which are not present in any of the substrings.
Return the minimum number of extra characters left over if you break up s optimally.


solution main function
```cpp
class Solution {
public:
    int solve(string s, vector<string>& dictionary) {

    }
};
```

Example 1:
Inputs = ""leetscode"", dictionary = [""leet"",""code"",""leetcode""]
Output: 1

Example 2:
Inputs = ""sayhelloworld"", dictionary = [""hello"",""world""]
Output: 3


Constraints:
1 <= s.length <= @data
1 <= dictionary.length <= @data
1 <= dictionary[i].length <= 50
dictionary[i] and s consists of only lowercase English letters
dictionary contains distinct words
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[10, 100, 1000]",1000.0,"[[12800, 1280, 128]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(string s, vector<string>& dictionary) {
        int n = s.size(), m = dictionary.size();
        vector<int> dp(n + 1);
        for (int i = 0; i <= n; i++) dp[i] = i;
        auto func = [&](int p, int q) {
            if (p + dictionary[q].size() > n) return false;
            for (int i = 0; i < dictionary[q].size(); i++) {
                if (s[p + i] != dictionary[q][i]) return false;
            }
            return true;
        };
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < dictionary.size(); j++) {
                if (func(i, j)) {
                    // cout << i << ' ' << j << '\n';
                    dp[i + dictionary[j].size()] = min(dp[i], dp[i + dictionary[j].size()]);
                }
            }
            dp[i + 1] = min(dp[i] + 1, dp[i + 1]); 
        }
        // for (int i = 0; i <= n; i++) cout << dp[i] << ' ';
        // cout << '\n';
        return dp[n];

    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    cin>>n;
    vector<string> dic;
    string s;
    for(int i=1;i<=n;i++)
    {
        cin>>s;
        dic.push_back(s);
    }
    cin>>s;
    // solve
    Solution solution;
            auto result = solution.solve(s,dic);
    
    // output
    cout<<result;
    return 0;
}","dp,string",medium
374,"# Problem Statement
Karina has an array of $n$ integers $a_1, a_2, a_3, \dots, a_n$. She loves multiplying numbers, so she decided that the beauty of a pair of numbers is their product. And the beauty of an array is the maximum beauty of a pair of **adjacent** elements in the array.

For example, for $n = 4$, $a=[3, 5, 7, 4]$, the beauty of the array is $\max$($3 \cdot 5$, $5 \cdot 7$, $7 \cdot 4$) = $\max$($15$, $35$, $28$) = $35$.

Karina wants her array to be as beautiful as possible. In order to achieve her goal, she can remove some elements (possibly zero) from the array. After Karina removes all elements she wants to, the array must contain at least two elements.

Unfortunately, Karina doesn't have enough time to do all her tasks, so she asks you to calculate the maximum beauty of the array that she can get by removing any number of elements (possibly zero).

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, vector<int> &a) {   
        // write your code here
    }
};
```
where:  
- return value is a 64-bit integer representing the maximum beauty of the array

# Example 1:  
- Input:  
n = 4
a = [5, 0, 2, 1]
- Output:  
10

# Constraints:  
- $2 \leq n \leq @data$  
- $-10^9 \leq a_i \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve(int &n, vector<int> &a)
    {
        long long ans = -1E18, mn = 1E18, mx = -1E18;
        for (int i = 0; i < n; i += 1)
        {
            long long x = a[i];
            if (i)
                ans = max({ans, x * mx, x * mn});
            mn = min(mn, x);
            mx = max(mx, x);
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,math,sort",easy
375,"The factorial of a positive integer n is the product of all positive integers less than or equal to n.
    For example, factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1.
We make a clumsy factorial using the integers in decreasing order by swapping out the multiply operations for a fixed rotation of operations with multiply '*', divide '/', add '+', and subtract '-' in this order.
    For example, clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1.
However, these operations are still applied using the usual order of operations of arithmetic. We do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right.
Additionally, the division that we use is floor division such that 10 * 9 / 8 = 90 / 8 = 11.
Given an integer n, return the clumsy factorial of n.

solution main function
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

Example 1:
Input: n = 4
Output: 7

Example 2:
Input: n = 10
Output: 12

Constraints:
1 <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 1000000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(int n) {
        if (n == 1) {
            return 1;
        } else if (n == 2) {
            return 2;
        } else if (n == 3) {
            return 6;
        } else if (n == 4) {
            return 7;
        }

        if (n % 4 == 0) {
            return n + 1;
        } else if (n % 4 <= 2) {
            return n + 2;
        } else {
            return n - 1;
        }
    }
};","#include <bits/stdc++.h>
#include <iterator>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
            auto result = solution.solve(n);
    
    // output
    cout<<result;
    return 0;
}",math,hard
376,"# Problem Statement
In the snake exhibition, there are $n$ rooms (numbered $0$ to $n - 1$) arranged in a circle, with a snake in each room. The rooms are connected by $n$ conveyor belts, and the $i$\-th conveyor belt connects the rooms $i$ and $(i+1) \bmod n$. In the other words, rooms $0$ and $1$, $1$ and $2$, $\ldots$, $n-2$ and $n-1$, $n-1$ and $0$ are connected with conveyor belts.

The $i$\-th conveyor belt is in one of three states:

-   If it is clockwise, snakes can only go from room $i$ to $(i+1) \bmod n$.
-   If it is anticlockwise, snakes can only go from room $(i+1) \bmod n$ to $i$.
-   If it is off, snakes can travel in either direction.

Each snake wants to leave its room and come back to it later. A room is **returnable** if the snake there can leave the room, and later come back to it using the conveyor belts. How many such **returnable** rooms are there?

The main function of the solution is:
```cpp
class Solution {
public:
    int solve(int &n, string &s) {
        // write your code here
    }
};
```
where:
- `n` is the number of rooms,
- `s` is a string of length $n$ that represents the state of each conveyor belt. If the $i$-th conveyor belt is clockwise, `s[i] = '>'`; if it is counterclockwise, `s[i] = '<'`; if it is off, `s[i] = '-'`.
- The return value is the number of returnable rooms.

# Example 1  
- Input:  
n = 5
s = "">>>>>""
- Output:  
5

# Constraints  
- $2 \leq n \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, string &s)
    {
        int ans = 0;
        bool flaga = 1, flagb = 1;
        for (int i = 0; i < n; i++)
            if (s[i] != '-')
            {
                if (s[i] == '>')
                    flaga = 0;
                if (s[i] == '<')
                    flagb = 0;
            }
        if (flaga || flagb)
            return n;
        else
        {
            for (int i = 0; i < n; i++)
                if (s[i] == '-' || s[(i + 1) % n] == '-')
                    ans++;
            return ans;
        }
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
	// input
	int n;
	cin >> n;
	string s;
	cin >> s;

	// solve
	Solution solution;
	auto result = solution.solve(n, s);

	// output
	cout << result << ""\n"";

	return 0;
}",graph,hard
377,"Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.
The answer is modulus 998244353.

solution main function
```cpp
class Solution {
public:
    int solve(int n) {

    }
};
```

Example 1:
Input: n = 3
Output: 5

Example 2:
Input: n = 1
Output: 1

Constraints:
1 <= n <= @data
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 1000000]",1000.0,"[[12800, 6400, 3200]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    const long long mod=998244353;
    int solve(int n) {
        long long C = 1;
        vector<long long> inv(n+3);
        inv[0]=inv[1]=1;
        for(int i=2;i<=n+1;i++)
            inv[i]=((mod-mod/i)*inv[mod%i])%mod;
        for (int i = 0; i < n; ++i) {
            C = C * 2ll%mod * (2ll * i + 1ll)%mod * inv[i+2]%mod;
        }
        return (int)C;
    }
    int power(long long x,long long y)
    {
        long long temp=1;
        while(y)
        {
            if(y&1) temp=temp*x%mod;
            x=x*x%mod; y>>=1;
        }
        return temp;
    }
    int solve2(int n) {
        long long C = 1;
        for (int i = 0; i < n; ++i) {
            C = C * 2ll%mod * (2ll * i + 1ll)%mod * power(i+2,mod-2)%mod;
        }
        return (int)C;
    }
};","#include <bits/stdc++.h>
#include <iterator>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    // solve
    Solution solution;
            auto result = solution.solve(n);
    
    // output
    cout<<result;
    return 0;
}",math,medium
378,"Alice and Bob play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].

The objective of the game is to end with the most stones. The total number of stones across all the piles is odd, so there are no ties.

Alice and Bob take turns, with Alice starting first. Each turn, a player takes the entire pile of stones either from the beginning or from the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins.

Assuming Alice and Bob play optimally, return true if Alice wins the game, or false if Bob wins.

solution main function

```cpp
class Solution {
public:
    bool solve(vector<int>& piles) {
        
    }
};
```

Example 1:
Input: piles = [5,3,4,5]
Output: true

Example 2:
Input: piles = [3,7,2,3]
Output: true

Constraints:


2 <= piles.length <= @data
piles.length is even.
1 <= piles[i] <= 500
sum(piles[i]) is odd.


Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[64000, 6400, 640]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    bool solve(vector<int>& piles) {
        return true;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; vector<int> num;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
    int result = solution.solve(num);
    
    // output
    cout<<result;
    return 0;
}",math,easy
379,"# Problem Statement
Three friends gathered to play a few games of chess together.

In every game, two of them play against each other. The winner gets $2$ points while the loser gets $0$, and in case of a draw, both players get $1$ point each. Note that the same pair of players could have played any non-negative number of times (possibly zero). It is also possible that no games were played at all.

You've been told that their scores after all the games were played were $p_1$, $p_2$ and $p_3$. Additionally, it is guaranteed that $p_1 \leq p_2 \leq p_3$ holds.

Find the maximum number of draws that could have happened and print it. If there isn't any way to obtain $p_1$, $p_2$ and $p_3$ as a result of a non-negative number of games between the three players, print $-1$ instead.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &p1, int &p2, int &p3) {
        // write your code here
    }
};
```
where:  
- return: the maximum possible number of draws that could've happened, or 1 if the scores aren't consistent with any valid set of games and results.

# Example 1:  
- Input:  
p1 = 0, p2 = 1, p3 = 1
- Output:  
1

# Constraints:  
- $1 \leq p1 \leq p2 \leq p3 \leq @data$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &p1, int &p2, int &p3)
    {
        int s = p1 + p2 + p3, m = max({p1, p2, p3});
        if (s % 2)
        {
            return -1;
        }
        else
        {
            return min(s - m, s / 2);
        }
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int p1, p2, p3;
    cin >> p1 >> p2 >> p3;

    // solve
    Solution solution;
    auto result = solution.solve(p1, p2, p3);

    // output
    cout << result << ""\n"";

    return 0;
}","math,dp",medium
380,"Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer.

solution main function

```cpp
class Solution {
public:
    int solve(vector<int>& arr) {
        
    }
};
```

Example 1:
Input: arr = [1,2,2,6,6,6,6,7,10]
Output: 6

Example 2:
Input: arr = [1,1]
Output: 1

Constraints:

1 <= arr.length <= @data
0 <= arr[i] <= 10^5

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[6400, 640, 64]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& arr) {
        int n = arr.size();
        vector<int> candidates = {arr[n / 4], arr[n / 2], arr[3 * n / 4]};
        int target = n / 4;
        
        for (int candidate : candidates) {
            int left = lower_bound(arr.begin(), arr.end(), candidate) - arr.begin();
            int right = upper_bound(arr.begin(), arr.end(), candidate) - arr.begin() - 1;
            if (right - left + 1 > target) {
                return candidate;
            }
        }
        
        return -1;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n; cin>>n;
    vector< int > a;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        a.push_back(x);
    }
    // solve
    Solution solution;
    auto result = solution.solve(a);
    
    // output
    cout << result << ""\n"";

    return 0;
}",math,easy
381,"# Problem Statement
There are $n$ block towers, numbered from $1$ to $n$. The $i$\-th tower consists of $a_i$ blocks.

In one move, you can move one block from tower $i$ to tower $j$, but only if $a_i &gt; a_j$. That move increases $a_j$ by $1$ and decreases $a_i$ by $1$. You can perform as many moves as you would like (possibly, zero).

What's the largest amount of blocks you can have on the tower $1$ after the moves?

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: 

# Example 1:  
- Input:  
n = 3
a = [1, 2, 3]
- Output:  
3

# Constraints:  
- $2 \leq n \leq @data$
- $1 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        sort(a.begin() + 1, a.end());
        for (int i = 1; i < n; i++)
        {
            if (a[i] > a[0])
            {
                a[0] = (a[0] + a[i] + 1) / 2;
            }
        }
        return a[0];
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","greedy,sort",hard
382,"# Problem Statement
Sasha found an array $a$ consisting of $n$ integers and asked you to paint elements.

You have to paint each element of the array. You can use as many colors as you want, but each element should be painted into exactly one color, and for each color, there should be at least one element of that color.

The cost of one color is the value of $\max(S) - \min(S)$, where $S$ is the sequence of elements of that color. The cost of the whole coloring is the **sum** of costs over all colors.

For example, suppose you have an array $a = [\color{red}{1}, \color{red}{5}, \color{blue}{6}, \color{blue}{3}, \color{red}{4}]$, and you painted its elements into two colors as follows: elements on positions $1$, $2$ and $5$ have color $1$; elements on positions $3$ and $4$ have color $2$. Then:

-   the cost of the color $1$ is $\max([1, 5, 4]) - \min([1, 5, 4]) = 5 - 1 = 4$;
-   the cost of the color $2$ is $\max([6, 3]) - \min([6, 3]) = 6 - 3 = 3$;
-   the total cost of the coloring is $7$.

For the given array $a$, you have to calculate the **maximum** possible cost of the coloring.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {   
        // write your code here
    }
};
``` 
where:  
- return: return the maximum possible cost of the coloring

# Example 1:  
- Input:  
n = 5
a = [1, 5, 6, 3, 4]
- Output:  
7

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq 10^3$  
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        sort(a.begin(), a.end());
        int ans = 0;
        for (int i = 0; i < n - 1 - i; i++)
            ans += a[n - 1 - i] - a[i];
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","two_pointers,greedy,sort",medium
383,"# Problem Statement
Even in university, students need to relax. That is why Sakurakos teacher decided to go on a field trip. It is known that all of the students will be walking in one line. The student with index $i$ has some topic of interest which is described as $a_i$. As a teacher, you want to minimise the disturbance of the line of students.

The disturbance of the line is defined as the number of neighbouring people with the same topic of interest. In other words, disturbance is the number of indices $j$ ($1 \le j < n$) such that $a_j = a_{j + 1}$.

In order to do this, you can choose index $i$ ($1\le i\le n$) and swap students at positions $i$ and $n-i+1$. You can perform any number of swaps.

Your task is to determine the minimal amount of disturbance that you can achieve by doing the operation described above any number of times.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {   
        // write your code here
    }
};
```
where:  
- the return value is the minimal amount of disturbance that you can achieve by doing the operation described above any number of times

# Example 1:  
- Input:  
n = 5
a = [1, 1, 1, 2, 3]
- Output:  
1

# Constraints:  
- $2 \leq n \leq @data$
- $1 \leq a[i] \leq n$ 
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[100, 10000, 1000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, vector<int> &a)
    {
        int ans = 0;
        for (int i = 1; i <= n - 1 - i; i++)
        {
            int x = a[i];
            int y = a[n - 1 - i];
            int z = a[i - 1];
            int w = a[n - i];
            ans += min((x == z) + (y == w), (x == w) + (y == z));
        }
        if (n % 2 == 0)
            ans += (a[n / 2 - 1] == a[n / 2]);
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","dp,greedy,two_pointers",hard
384,"Given an integer n (in base 10) and a base k, return the sum of the digits of n after converting n from base 10 to base k.

After converting, each digit should be interpreted as a base 10 number, and the sum should be returned in base 10.

solution main function
```cpp
class Solution {
public:
    int solve(int n, int k) {
        
    }
};
```

Example 1:
Input: n = 34, k = 6
Output: 9

Example 2:
Input: n = 10, k = 10
Output: 1

Constraints:

1 <= n <= @data
2 <= k <= 10

Time limit: @time_limit ms
Memory limit: @memory_limit KB","[1000, 10000, 100000]",1000.0,"[[25600, 12800, 6400]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(int n, int k) {
        int res = 0;
        for (; n > 0; n /= k)
            res += n % k;
        return res;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,m;cin>>n>>m;
    // solve
    Solution solution;
    auto result = solution.solve(n,m);
    
    // output
    // for(auto it:result) cout<<it<<' ';
    cout<<result;
    // for(auto s:result)
    // {
    //     for(auto it:s)
    //         printf(""%d "",it);
    //     putchar('\n');
    // }
    return 0;
}",math,easy
385,"Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.
Note that the same word in the dictionary may be reused multiple times in the segmentation.

solution main function
```cpp
class Solution {
public:
    bool solve(string s, vector<string>& wordDict) {

    }
};
```

Example 1:
Input: s = ""leetcode"", wordDict = [""leet"",""code""]
Output: true

Example 2:
Input: s = ""applepenapple"", wordDict = [""apple"",""pen""]
Output: true


Constraints:
1 <= s.length <= data
1 <= wordDict.length <= data
1 <= wordDict[i].length <= 20
s and wordDict[i] consist of only lowercase English letters.
All the strings of wordDict are unique.
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 500, 1000]",1000.0,"[[12800, 1280, 128]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    bool solve(string s, vector<string>& wordDict) {
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for (int i = 1; i < dp.size(); i++) {
            for (auto w : wordDict) {
                int len =  w.size();
                if (i - len >= 0) {
                    if (dp[i - len] && s.substr(i - len, len) == w) {
                        dp[i] = true;
                        break;
                    }
                }
            }
        }
        return dp.back();
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n;
    cin>>n;
    vector<string> dic;
    string s;
    for(int i=1;i<=n;i++)
    {
        cin>>s;
        dic.push_back(s);
    }
    cin>>s;
    // solve
    Solution solution;
            int result = solution.solve(s,dic);
    
    // output
    cout<<result;
    return 0;
}","string,dp,STL",medium
386,"You are given a binary array nums and an integer k.
A k-bit flip is choosing a subarray of length k from nums and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.
Return the minimum number of k-bit flips required so that there is no 0 in the array. If it is not possible, return -1.
A subarray is a contiguous part of an array.

solution main function
```cpp
class Solution {
public:
    int solve(vector<int>& nums, int k) {

    }
};
```

Example 1:
Input: nums = [0,1,0], k = 1
Output: 2

Example 2:
Input: nums = [1,1,0], k = 2
Output: -1

Constraints:
1 <= nums.length <= @data
1 <= k <= nums.length
Time limit: @time_limit ms
Memory limit: @memory_limit KB","[100, 1000, 100000]",1000.0,"[[12800, 1280, 128]]","#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int solve(vector<int>& nums, int k) {
        int ans = 0;
        int n = nums.size();
        int cnt = 0;
        for(int i=0;i<n;i++) {
            if(i>=k&&nums[i-k]>1) {
                cnt^=1;
                nums[i-k]-=2;
            }
            if(nums[i]==cnt) {
                if(i+k>n) return -1;
                cnt^=1;
                nums[i]+=2;
                ans++;
            }
        }
        return ans;
    }
};","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main(int argc, char *argv[])
{
    
    // input
    int n,k; cin>>n>>k;
    vector<int> num;
    for(int i=1;i<=n;i++)
    {
        int x; cin>>x;
        num.push_back(x);
    }
    // solve
    Solution solution;
            int result = solution.solve(num,k);
    
    // output
    cout<<result;
    return 0;
}",bit_manipulation,medium
387,"# Problem Statement
Rudolf has a string $s$ of length $n$. Rudolf considers the string $s$ to be ugly if it contains the substring$^\dagger$ ""pie"" or the substring ""map"", otherwise the string $s$ will be considered beautiful.

For example, ""ppiee"", ""mmap"", ""dfpiefghmap"" are ugly strings, while ""mathp"", ""ppiiee"" are beautiful strings.

Rudolf wants to shorten the string $s$ by removing some characters to make it beautiful.

The main character doesn't like to strain, so he asks you to make the string beautiful by removing the minimum number of characters. He can remove characters from **any** positions in the string (not just from the beginning or end of the string).

$^\dagger$ String $a$ is a substring of $b$ if there exists a **consecutive** segment of characters in string $b$ equal to $a$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, string &s) {   
        // write your code here
    }
};
```
where:  
- the return value is the minimum number of characters to be removed to make the string beautiful

# Example 1:  
- Input:  
n = 9
s = ""mmapnapie""
- Output:  
2

# Constraints:  
- $1 \leq n \leq @data$
- $s[i]$ is a lowercase letter
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[100, 10000, 1000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve(int &n, string &s)
    {
        int ans = 0;
        for (int i = 0; i < n; i++)
        {
            if (i + 3 <= n && s.substr(i, 3) == ""pie"")
                ans++;
            if (i + 3 <= n && s.substr(i, 3) == ""map"")
                ans++;
            if (i + 5 <= n && s.substr(i, 5) == ""mapie"")
                ans--;
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    string s;
    cin >> s;

    // solve
    Solution solution;
    auto result = solution.solve(n, s);

    // output
    cout << result << ""\n"";

    return 0;
}","math,dp,greedy,string",easy
388,"# Problem Statement
Alice and Bob are playing a game. They have an array of positive integers $a$ of size $n$.

Before starting the game, Alice chooses an integer $k \ge 0$. The game lasts for $k$ stages, the stages are numbered from $1$ to $k$. During the $i$\-th stage, Alice must remove an element from the array that is less than or equal to $k - i + 1$. After that, if the array is not empty, Bob must add $k - i + 1$ to an arbitrary element of the array. Note that both Alice's move and Bob's move are two parts of the same stage of the game. If Alice can't delete an element during some stage, she loses. If the $k$\-th stage ends and Alice hasn't lost yet, she wins.

Your task is to determine the maximum value of $k$ such that Alice can win if both players play optimally. Bob plays against Alice, so he tries to make her lose the game, if it's possible.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the maximum value of k such that Alice can win if both players play optimally.

# Example 1:  
- Input:  
n = 3
a = [1, 1, 2]
- Output:  
2

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[20000, 200000, 2500000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve1(int &n, vector<int> &a)
    {
        vector<int> cnt(n);
        for (int i = 0; i < n; i++)
        {
            if (a[i] <= n)
            {
                cnt[a[i] - 1]++;
            }
        }
        for (int i = 1; i < n; i++)
        {
            cnt[i] += cnt[i - 1];
        }

        int ans = n;
        for (int i = 0; i < n; i++)
        {
            ans = min(ans, max(cnt[i] - i, i));
        }

        return ans;
    }
    int solve2(int &n, vector<int> &a)
    {
        sort(a.begin(), a.end());
        int l = 0, r = n;
        while (l <= r)
        {
            if (l == r)
                return l;
            int mid = (l + r + 1) / 2;
            int x = mid;
            for (int i = n; i >= mid; i--)
            {
                if (a[i - 1] <= x)
                {
                    x--;
                }
            }
            if (x == 0)
                l = mid;
            else
                r = mid - 1;
        }
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","binary,data_structures,sort",hard
389,"# Problem Statement
You are given an array $a_1, a_2, \dots a_n$. Count the number of pairs of indices $1 \leq i, j \leq n$ such that $a_i &lt; i &lt; a_j &lt; j$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the number of pairs of indices satisfying the condition in the statement.

# Example 1:  
- Input:  
n = 8
a = [1, 1, 2, 3, 8, 2, 1, 4]
- Output:  
3

# Constraints:  
- $2 \leq n \leq @data$
- $0 \leq a[i] \leq 10^9$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve1(int &n, vector<int> &a)
    {
        vector<int> sum(n + 1);
        for (int i = 0; i < n; i++)
        {
            sum[i + 1] = sum[i] + (a[i] < i + 1);
        }

        long long ans = 0;
        for (int i = 0; i < n; i++)
        {
            if (a[i] < i + 1 && a[i] > 0)
            {
                ans += sum[min(n, a[i] - 1)];
            }
        }
        return ans;
    }
    long long solve2(int &n, vector<int> &a)
    {
        long long ans = 0;
        for (int i = 0; i < n; i++)
        {
            if (a[i] < i + 1 && a[i] > 0)
            {
                for (int j = 0; j < min(n, a[i] - 1); j++)
                {
                    if (a[j] < j + 1)
                    {
                        ans++;
                    }
                }
            }
        }

        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}","sort,dp,greedy",hard
390,"# Problem Statement:
An integer array $a_1, a_2, \ldots, a_n$ is being transformed into an array of lowercase English letters using the following prodecure:

While there is at least one number in the array:

-   Choose any number $x$ from the array $a$, and any letter of the English alphabet $y$.
-   Replace all occurrences of number $x$ with the letter $y$.

For example, if we initially had an array $a = [2, 3, 2, 4, 1]$, then we could transform it the following way:

-   Choose the number $2$ and the letter c. After that $a = [c, 3, c, 4, 1]$.
-   Choose the number $3$ and the letter a. After that $a = [c, a, c, 4, 1]$.
-   Choose the number $4$ and the letter t. After that $a = [c, a, c, t, 1]$.
-   Choose the number $1$ and the letter a. After that $a = [c, a, c, t, a]$.

After the transformation all letters are united into a string, in our example we get the string ""cacta"".

Having the array $a$ and the string $s$ determine if the string $s$ could be got from the array $a$ after the described transformation?

The main function of the solution is defined as: 
```cpp
class Solution {
public:
    string solve(int &n, vector<int> &a, string &s) {   
        // write your code here
    }
};
```

Where:  
- `n` is an integer representing the length of the array and string.  
- `a` is an integer array.  
- `s` is a string consisting of lowercase English letters.  
- The return value is ""YES"" if the string $s$ could be got from the array $a$ after the described transformation, otherwise return ""NO"".

# Example 1:
- Input:  
n = 5  
a = [2, 3, 2, 4, 1]  
s = ""cacta""
- Output:  
YES

# Constraints:
- $1 \leq n \leq @data$  
- $1 \leq a[i] \leq n$  
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB","[10, 1000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    string solve1(int &n, vector<int> &a, string &s)
    {
        vector<int> mp(n + 1, -1);
        for (int i = 0; i < n; i++)
        {
            if (mp[a[i]] == -1)
                mp[a[i]] = s[i];
            else if (mp[a[i]] != s[i])
                return ""NO"";
        }
        return ""YES"";
    }
    string solve2(int &n, vector<int> &a, string &s)
    {
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (a[i] == a[j] && s[i] != s[j])
                    return ""NO"";
            }
        }
        return ""YES"";
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];
    string s;
    cin >> s;

    // solve
    Solution solution;
    auto result = solution.solve(n, a, s);

    // output
    cout << result << ""\n"";

    return 0;
}",greedy,medium
391,"# Problem Statement
Given an array $a$ of length $n$, where $2 \leq a[i] \leq n$, you need to find the smallest prime factor of each number and return the XOR sum of all results.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the XOR sum of the smallest prime factor of each number in the array.

# Example 1:  
- Input:  
n = 4
a = [2, 4, 3, 4]
- Output:  
1

# Constraints:  
- $1 \leq n \leq @data$
- $2 \leq a[i] \leq n$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10000, 100000, 1000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve1(int &n, vector<int> &a)
    {
        vector<int> prime;
        vector<int> min_prime(n + 1, 0);
        for (int i = 2; i <= n; i++)
        {
            if (min_prime[i] == 0)
            {
                prime.push_back(i);
                min_prime[i] = i;
            }
            for (int j = 0; j < prime.size() && i * prime[j] <= n; j++)
            {
                min_prime[i * prime[j]] = prime[j];
                if (i % prime[j] == 0)
                    break;
            }
        }
        int res = 0;
        for (int i = 0; i < n; i++)
        {
            res ^= min_prime[a[i]];
        }
        return res;
    }
    int solve2(int &n, vector<int> &a)
    {
        int res = 0;
        for (int i = 0; i < n; i++)
        {
            int min_prime = a[i];
            for (int j = 2; j * j <= a[i]; j++)
            {
                if (a[i] % j == 0)
                {
                    min_prime = j;
                    break;
                }
            }
            res ^= min_prime;
        }
        return res;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
    {
        cin >> a[i];
    }
    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",math,easy
392,"# Problem Statement
Given an array $a$ of length $n$. You need to count the number of inversions in the array.

An inversion is defined as a pair of elements $a[i]$ and $a[j]$ such that $i < j$ and $a[i] > a[j]$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the number of inversions in the array.

# Example 1:  
- Input:  
n = 5
a = [3, 1, 2, 5, 4]
- Output:  
3

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq n$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve1(int &n, vector<int> &a)
    {
        long long ans = 0;
        vector<int> bit(n + 2);
        for (int i = n - 1; i >= 0; i--)
        {
            for (int j = a[i] - 1; j; j -= j & -j)
                ans += bit[j];
            for (int j = a[i]; j <= n; j += j & -j)
                bit[j]++;
        }
        return ans;
    }
    long long solve2(int &n, vector<int> &a)
    {
        long long ans = 0;
        for (int i = 0; i < n; i++)
            for (int j = i + 1; j < n; j++)
                if (a[i] > a[j])
                    ans++;
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",data_structures,easy
393,"# Problem Statement
Given an array $a$ of length $n$, where the elements are integers. You need to count the number of subarrays whose sum is 0.

The sum of a subarray is defined as the sum of elements from index $l$ to $r$, i.e., $a[l] + a[l+1] + \dots + a[r]$.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the number of subarrays whose sum is 0.

# Example 1:  
- Input:  
n = 5
a = [1, -1, 2, -2, 0]
- Output:  
6

# Constraints:  
- $1 \leq n \leq @data$
- $-n \leq a[i] \leq n$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 1280, 64]]","class Solution
{
public:
    long long solve1(int &n, vector<int> &a)
    {
        vector<int> prefix(n + 1);
        for (int i = 0; i < n; i++)
            prefix[i + 1] = prefix[i] + a[i];
        unordered_map<long long, int> mp;
        long long result = 0;
        mp[0] = 1;
        for (int i = 1; i <= n; i++)
        {
            if (mp.find(prefix[i]) != mp.end())
                result += mp[prefix[i]];
            mp[prefix[i]]++;
        }
        return result;
    }
    long long solve2(int &n, vector<int> &a)
    {
        long long result = 0;
        for (int i = 0; i < n; i++)
        {
            long long sum = 0;
            for (int j = i; j < n; j++)
            {
                sum += a[j];
                if (sum == 0)
                    result++;
            }
        }
        return result;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",data_structures,medium
394,"# Problem Statement
A permutation $a$ of length $n$ consists of integers from $1$ to $n$, with each integer appearing exactly once. For each number $a[i]$, define its contribution as the length of the cycle that $a[i]$ belongs to. The cycle is defined by starting from $a[i]$, then visiting the next element $a[a[i]]$, then $a[a[a[i]]]$, and so on, until returning to $a[i]$. Please calculate the sum of the contributions of $a$.Note that the index of $a$ starts from $1$, you may need to convert it to start from $0$.
The main function of the solution is defined as:  
```cpp
class Solution {
public:
    long long solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the sum of the contributions of $a$.

# Example 1:  
- Input:  
n = 4
a = [2, 1, 3, 4]
- Output:  
6

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq 10^9$
- $a[i]$ is distinct
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    long long solve1(int &n, vector<int> &a)
    {
        vector<int> vis(n);
        long long ans = 0;
        for (int i = 0; i < n; i++)
            a[i]--;
        for (int i = 0; i < n; i++)
        {
            if (vis[i])
                continue;
            int j = i;
            int cnt = 0;
            while (!vis[j])
            {
                vis[j] = 1;
                cnt++;
                j = a[j];
            }
            ans += 1ll * cnt * cnt;
        }
        return ans;
    }
    long long solve2(int &n, vector<int> &a)
    {
        long long ans = 0;
        for (int i = 0; i < n; i++)
            a[i]--;
        for (int i = 0; i < n; i++)
        {
            int j = i;
            int cnt = 1;
            j = a[j];
            while (j != i)
            {
                cnt++;
                j = a[j];
            }
            ans += cnt;
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",search,hard
395,"# Problem Statement
Given an array $a$ of length $n$,$2\leq a[i] \leq n$, determine whether each number in the array is a prime number. For each number, if it is a prime, represent it as 1; otherwise, represent it as 0. Finally, store the result as a binary string of length $n$ in the given string.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    void solve(int &n, vector<int> &a, string &res) {
        // write your code here
    }
};
```
where:  
- return: 01 string representing whether each number in the array is a prime number.The string is stored in the given string `res`.

# Example 1:  
- Input:  
n = 2
a = [2, 4]
- Output:  
res = ""10""

# Constraints:  
- $1 \leq n \leq @data$
- $2 \leq a[i] \leq n$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 960, 64]]","class Solution
{
public:
    void solve1(int &n, vector<int> &a, string &res)
    {
        vector<int> prime;
        vector<bool> is_prime(n + 1, true);
        is_prime[0] = is_prime[1] = false;
        for (int i = 2; i <= n; i++)
        {
            if (is_prime[i])
                prime.push_back(i);
            for (int j = 0; j < prime.size() && i * prime[j] <= n; j++)
            {
                is_prime[i * prime[j]] = false;
                if (i % prime[j] == 0)
                    break;
            }
        }
        res = """";
        for(int i = 0; i < n; i++)
            res += is_prime[a[i]] ? ""1"" : ""0"";
    }
    void solve2(int &n, vector<int> &a, string &res)
    {
        res = """";
        for (int i = 0; i < n; i++)
        {
            bool is_prime = true;
            for (int j = 2; j * j <= a[i]; j++)
            {
                if (a[i] % j == 0)
                {
                    is_prime = false;
                    break;
                }
            }
            res+= is_prime ? ""1"" : ""0"";
        }
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    string result;
    solution.solve(n, a, result);

    // output
    cout << result << ""\n"";

    return 0;
}",math,easy
396,"# Problem Statement
Given an array $a$ of length $n$, where $2 \leq a[i] \leq n$, you need to find the modular inverse of each number modulo 998244353. Return the XOR of all the results.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the XOR of all the results.

# Example 1:  
- Input:  
n = 2
a = [2, 4]
- Output:  
828375040

# Constraints:  
- $1 \leq n \leq @data$
- $2 \leq a[i] \leq n$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[20000, 200000, 2000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve1(int &n, vector<int> &a)
    {
        vector<int> inv(n + 1);
        const int mod = 998244353;
        for (int i = 1; i <= n; i++)
            inv[i] = i == 1 ? 1 : (long long)(mod - mod / i) * inv[mod % i] % mod;
        int res = 0;
        for (int i = 0; i < n; i++)
            res = res ^ inv[a[i]];
        return res;
    }
    int solve2(int &n, vector<int> &a)
    {
        const int mod = 998244353;
        int ans = 0;
        for (int i = 0; i < n; i++)
        {
            int res = 1;
            int b = mod - 2;
            int v = a[i];
            while (b)
            {
                if (b & 1)
                    res = (long long)res * v % mod;
                v = (long long)v * v % mod;
                b >>= 1;
            }
            ans ^= res;
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",math,medium
397,"# Problem Statement
Given an integer $n$ and an array $a$ of length $n$, where $2 \leq a[i] \leq n$, you need to calculate the $a[i]$-th term of the Fibonacci sequence, then take the result modulo 998244353, and finally return the XOR sum of all results.

The Fibonacci sequence is defined as follows:
- $F(0) = 0$
- $F(1) = 1$
- $F(i) = F(i-1) + F(i-2)$ for $i \geq 2$

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the xor sum of all results.

# Example 1:  
- Input:  
n = 3
a = [1, 2, 3]
- Output:  
2

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq n$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[10000, 100000, 1000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    const int MOD = 998244353;
    array<array<long long, 2>, 2> mat;
    array<array<long long, 2>, 2> result;
    array<array<long long, 2>, 2> temp;
    void matrix_multiply(const array<array<long long, 2>, 2> &A, const array<array<long long, 2>, 2> &B, array<array<long long, 2>, 2> &C)
    {
        for (int i = 0; i < 2; i++)
        {
            for (int j = 0; j < 2; j++)
            {
                C[i][j] = 0;
                for (int k = 0; k < 2; k++)
                {
                    C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD;
                }
            }
        }
    }

    void matrix_pow(int power)
    {
        result = {{{1, 0}, {0, 1}}};
        while (power > 0)
        {
            if (power & 1)
            {
                matrix_multiply(result, mat, temp);
                result = temp;
            }
            matrix_multiply(mat, mat, temp);
            mat = temp;
            power >>= 1;
        }
    }

    int fib(int n)
    {
        if (n == 0)
            return 0;
        mat = {{{1, 1}, {1, 0}}};
        matrix_pow(n - 1);
        return result[0][0];
    }
    int solve1(int &n, vector<int> &a)
    {
        vector<int> fib(n + 1);
        fib[0] = 0;
        fib[1] = 1;
        for (int i = 2; i <= n; i++)
        {
            fib[i] = (fib[i - 1] + fib[i - 2]) % MOD;
        }

        int xor_sum = 0;
        for (int num : a)
        {
            xor_sum ^= fib[num];
        }
        return xor_sum;
    }
    int solve2(int &n, vector<int> &a)
    {
        int xor_sum = 0;
        for (int num : a)
        {
            xor_sum ^= fib(num);
        }
        return xor_sum;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",math,medium
398,"# Problem Statement
Given an array $a$ of length $n$ and an integer $k$. For each element $a[i]$ in the array, where $1 \leq a[i] \leq n$, assume there are $a[i]$ people standing in a circle, numbered from $1$ to $a[i]$. Starting from the person numbered $1$, count up to $k$ and the person at position $k$ is eliminated. Then, start counting again from the next person. This process continues until only one person remains in the circle. You need to calculate the position of the last remaining person for each $a[i]$ and return the XOR sum of all results.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &k, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: The XOR sum of all results.

# Example 1:  
- Input:  
n = 2, k = 2
a = [1, 2] 
- Output:  
0

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq k \leq 10^3$
- $1 \leq a[i] \leq n$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve1(int &n, int &k, vector<int> &a)
    {
        vector<int> dp(n + 1);
        dp[1] = 0;
        for (int m = 2; m <= n; m++)
        {
            dp[m] = (dp[m - 1] + k) % m;
        }
        int xor_sum = 0;
        for (int num : a)
        {
            xor_sum ^= (dp[num] + 1);
        }
        return xor_sum;
    }
    int solve2(int &n, int &k, vector<int> &a)
    {
        int xor_sum = 0;
        for (int num : a)
        {
            int x = 0;
            for (int i = 1; i <= num; i++)
            {
                x = (x + k) % i;
            }
            xor_sum ^= (x + 1);
        }
        return xor_sum;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, k;
    cin >> n >> k;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, k, a);

    // output
    cout << result << ""\n"";

    return 0;
}",math,medium
399,"# Problem Statement
Given an integer $n$, you need to answer $m$ queries. Each query provides a range $[l, r]$, and you are required to count the number of 1s in the binary representation of each number in the range $[l, r]$. Return the XOR sum of all query results.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, int &m, vector<array<int, 2>> &q) {
        // write your code here
    }
};
```
where:  
- `q`: $m$ queries, each query gives a range $[l, r]$, $q[i][0]$ represents the left endpoint $l$ of query $i$, $q[i][1]$ represents the right endpoint $r$ of query $i$.
- Return: return the XOR sum of all query results.

# Example 1:  
- Input:  
n = 5
m = 1
q = [[1, 3]]
- Output:  
4 

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq l \leq r \leq n$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[1000, 10000, 100000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve1(int &n, int &m, vector<array<int, 2>> &q)
    {
        vector<int> cnt(n + 1);
        for(int i=1;i<=n;i++)
        {
            cnt[i] = cnt[i-1] + __builtin_popcount(i);
        }
        int ans = 0;
        for(auto &i:q)
        {
            ans ^= cnt[i[1]] - cnt[i[0]-1];
        }
        return ans;
    }
    int solve2(int n, int m, vector<array<int, 2>> q)
    {
        int ans = 0;
        for(auto &i:q)
        {
            int cnt = 0;
            for(int j=i[0];j<=i[1];j++)
            {
                cnt += __builtin_popcount(j);
            }
            ans ^= cnt;
        }
        return ans;
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n, m;
    cin >> n >> m;
    vector<array<int, 2>> q(m);
    for (int i = 0; i < m; i++)
    {
        cin >> q[i][0] >> q[i][1];
    }

    // solve
    Solution solution;
    auto result = solution.solve(n, m, q);

    // output
    cout << result << ""\n"";

    return 0;
}",greedy,medium
400,"# Problem Statement
Given an array $a$ of length $n$, return the count of the most frequently occurring element in the array.

The main function of the solution is defined as:  
```cpp
class Solution {
public:
    int solve(int &n, vector<int> &a) {
        // write your code here
    }
};
```
where:  
- return: the count of the most frequently occurring element in the array.

# Example 1:  
- Input:  
n = 5
a = [1, 2, 2, 3, 3]
- Output:  
2

# Constraints:  
- $1 \leq n \leq @data$
- $1 \leq a[i] \leq n$
- Time limit: @time_limit ms  
- Memory limit: @memory_limit KB  ","[20000, 200000, 2000000]",1000.0,"[[6400, 640, 64]]","class Solution
{
public:
    int solve1(int &n, vector<int> &a)
    {
        sort(a.begin(), a.end());
        int ans = 0;
        int pre = -1;
        int cnt = 0;
        for (int i = 0; i < n; i++)
        {
            if (a[i] == pre)
                cnt++;
            else
            {
                ans = max(ans, cnt);
                cnt = 1;
                pre = a[i];
            }
        }
        ans = max(ans, cnt);
        return ans;
    }
    int solve2(int &n, vector<int> &a)
    {
        vector<int> cnt(n + 1, 0);
        for (int i = 0; i < n; i++)
            cnt[a[i]]++;
        return *max_element(cnt.begin(), cnt.end());
    }
};

","#include <bits/stdc++.h>
#include ""std.h""
using namespace std;
int main()
{
    // input
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // solve
    Solution solution;
    auto result = solution.solve(n, a);

    // output
    cout << result << ""\n"";

    return 0;
}",sort,hard
